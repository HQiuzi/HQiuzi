---
title: 2021-08-17-庄懂的技术美术入门课学习笔记（三）
date: 2021-08-17 16:24:40
katex: true
tags:
  - 环境光
  - AO
categories:
  - 庄懂的技术美术入门课学习笔记
---

# AO（Ambient Occlusion）环境光遮蔽

> AO是来描绘物体和物体[相交](https://baike.baidu.com/item/相交/10077492)或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：
>
> AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。

## 在blender中导出AO贴图

1. 创建一个新的图片文件。打开图片预览。

2. 然后在渲染属性中设置烘焙类型为环境光遮蔽。

   ![image-20210817171811952](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817171811952.png)

   3. 烘焙后即可看到AO贴图，另存为图片即可。

      ![image-20210817171900860](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817171900860.png)

## 3个方向的环境光

输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。

![image-20210817164458000](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817164458000.png)

根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。

### ShaderForge实现

![image-20210817173142732](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817173142732.png)

最后获得的结果如图：

![image-20210817173346922](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817173346922.png)

### Code

>**Key Point:**
>
>1. 面板贴图参数定义：`_Occlusion("AO贴图",2d)= "white" {}`  
>
>`uniform sampler2D _Occlusion;`
>
>2. 输入模型uv0：
>
>  `float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0`
>
>3. 输出结构添加uv：
>
>  `float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图`
>
>4. 定点着色器对uv赋值：
>
>   `o.uv = v.uv0;`
>
>5. 片元着色器中根据输出的uv采样AO贴图：
>
>   `float occlusion=tex2D(_Occlusion,i.uv);`

<details>
    <summary>MyThreeColAmbientShader.shader</summary>

```c#
Shader "Class3/MyThreeColAmbientShader"
{
    Properties {
		_Occlusion("AO贴图",2d)= "white" {}
		_EnvUpCol("顶部颜色",color)=(1.0,1.0,1.0,1.0)
		_EnvDownCol("底部颜色",color)=(0.0,0.0,0.0,1.0)
		_EnvSideCol("侧面颜色",color)=(0.5,0.5,0.5,1.0)

		}
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform sampler2D _Occlusion;
			uniform float3 _EnvUpCol;
			uniform float3 _EnvDownCol;
			uniform float3 _EnvSideCol;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//将模型uv信息输入进来
            };
            struct VertexOutput {
                float4 posCS : SV_POSITION;
				float3 nDirWS : TEXCOORD0;
				float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图
				
            };

			//输入结构>>>顶点Shader>>>输出结构
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.uv = v.uv0;

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				//准备向量 
				float3 nDir = i.nDirWS;

				//计算各部位遮罩
				float upMask = max(0.0,nDir.g);
				float downMask = max(0.0,-nDir.g);
				float sideMask = max(0.0,1-upMask-downMask);


				//混合颜色
				float3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;

				//采样Occlusion贴图
				float occlusion=tex2D(_Occlusion,i.uv);
				//AO
				float3 finalRGB = envCol*occlusion;


                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}

```

</details>

# 投影

## Unity内置投影代码调用方法

![image-20210817181801721](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817181801721.png)

![image-20210817181543732](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817181543732.png)

