---
title: 2021-08-17-庄懂的技术美术入门课学习笔记（三）
date: 2021-08-17 16:24:40
katex: true
tags:
  - 环境光
  - AO
  - 投影
categories:
  - 庄懂的技术美术入门课学习笔记
---

> 对应课程7-8课内容

# AO（Ambient Occlusion）环境光遮蔽

> AO是来描绘物体和物体[相交](https://baike.baidu.com/item/相交/10077492)或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：
>
> AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。

## 在blender中导出AO贴图

1. 创建一个新的图片文件。打开图片预览。

2. 然后在渲染属性中设置烘焙类型为环境光遮蔽。

   ![image-20210817171811952](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171811952.png)

   3. 烘焙后即可看到AO贴图，另存为图片即可。

      ![image-20210817171900860](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171900860.png)

## 3个方向的环境光

输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。

![image-20210817164458000](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817164458000.png)

根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。

### ShaderForge实现

![image-20210817173142732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173142732.png)

最后获得的结果如图：

![image-20210817173346922](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173346922.png)

### Code

>**Key Point:**
>
>1. 面板贴图参数定义：`_Occlusion("AO贴图",2d)= "white" {}`  
>
>`uniform sampler2D _Occlusion;`
>
>2. 输入模型uv0：
>
>  `float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0`
>
>3. 输出结构添加uv：
>
>  `float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图`
>
>4. 定点着色器对uv赋值：
>
>   `o.uv = v.uv0;`
>
>5. 片元着色器中根据输出的uv采样AO贴图：
>
>   `float occlusion=tex2D(_Occlusion,i.uv);`

<details>
    <summary>MyThreeColAmbientShader.shader</summary>

```c#
Shader "Class3/MyThreeColAmbientShader"
{
    Properties {
		_Occlusion("AO贴图",2d)= "white" {}
		_EnvUpCol("顶部颜色",color)=(1.0,1.0,1.0,1.0)
		_EnvDownCol("底部颜色",color)=(0.0,0.0,0.0,1.0)
		_EnvSideCol("侧面颜色",color)=(0.5,0.5,0.5,1.0)

		}
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform sampler2D _Occlusion;
			uniform float3 _EnvUpCol;
			uniform float3 _EnvDownCol;
			uniform float3 _EnvSideCol;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//将模型uv信息输入进来
            };
            struct VertexOutput {
                float4 posCS : SV_POSITION;
				float3 nDirWS : TEXCOORD0;
				float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图
				
            };

			//输入结构>>>顶点Shader>>>输出结构
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.uv = v.uv0;

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				//准备向量 
				float3 nDir = i.nDirWS;

				//计算各部位遮罩
				float upMask = max(0.0,nDir.g);
				float downMask = max(0.0,-nDir.g);
				float sideMask = max(0.0,1-upMask-downMask);


				//混合颜色
				float3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;

				//采样Occlusion贴图
				float occlusion=tex2D(_Occlusion,i.uv);
				//AO
				float3 finalRGB = envCol*occlusion;


                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}

```

</details>

# 投影

## Unity内置投影代码调用方法

> 注意要包含的库文件：
>
> ```c#
> #include "AutoLight.cginc"  //使用unity投影必须包含
> #include "Lighting.cginc"  //使用unity投影必须包含
> ```

![image-20210817181801721](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181801721.png)

![image-20210817181543732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181543732.png)

# 综合应用-简化理解光照的构成

![image-20210817205326280](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817205326280.png)

![image-20210817205548075](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817205548075.png)

对于上述模型，把之前学习的内容结合起来：

注意Lambert+Phong之后要和光源遮挡相乘之后才得到光源的结果。

![image-20210817205808746](D:\Blog\blog\images\2021-08-17-庄懂的技术美术入门课学习笔记（三）\image-20210817205808746.png)

## Code

<details>
    <summary>OldSchoolPlusShader.shader</summary>

```c#
Shader "Class3/OldSchoolPlusShader"
{
    Properties {
		_BaseCol("基本颜色",color)=(1.0,0.0,0.0,1.0)
		_LightCol("光照颜色",color)=(1.0,1.0,1.0,1.0)
		_SpecularPow("高光次幂",range(1,90))= 30
		_Intensity("光照强度",range(0,5))=1

		_EnvIntensity("环境光强度",range(0,5))=1
		_Occlusion("AO贴图",2d)= "white" {}
		_EnvUpCol("顶部颜色",color)=(1.0,1.0,1.0,1.0)
		_EnvDownCol("底部颜色",color)=(0.0,0.0,0.0,1.0)
		_EnvSideCol("侧面颜色",color)=(0.5,0.5,0.5,1.0)

		}
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
			#include "AutoLight.cginc"  //使用unity投影必须包含
			#include "Lighting.cginc"  //使用unity投影必须包含
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform float3 _BaseCol;
			uniform float3 _LightCol;
			uniform float _SpecularPow;
			uniform float _Intensity;
			uniform float _EnvIntensity;
			uniform sampler2D _Occlusion;
			uniform float3 _EnvUpCol;
			uniform float3 _EnvDownCol;
			uniform float3 _EnvSideCol;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//将模型uv信息输入进来
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float4 posWS : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float2 uv : TEXCOORD2;//追加uv输出用于采样AO贴图
				LIGHTING_COORDS(3,4)
				
            };

			//输入结构>>>顶点Shader>>>输出结构
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.uv = v.uv0;

				TRANSFER_VERTEX_TO_FRAGMENT(o)

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
			//准备向量 
				float3 nDir = normalize(i.nDirWS);
				float3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				float3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS.xyz);
				float3 rDir = reflect(-lDir,nDir);

				float shadow = LIGHT_ATTENUATION(i);

////// Light:
				float nDotl = dot(nDir,lDir);
				float vDotr = dot(vDir,rDir);

				float lambert = max(0.0,nDotl);
				float phong = pow(max(0.0,vDotr),_SpecularPow);

				///add shadow
				
				float3 lightRes =_LightCol*(_BaseCol*lambert+phong)*_Intensity*shadow;

////// env:
				

				//计算各部位遮罩
				float upMask = max(0.0,nDir.g);
				float downMask = max(0.0,-nDir.g);
				float sideMask = 1.0-upMask-downMask;


				//混合颜色
				float3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;

				//采样Occlusion贴图
				float occlusion=tex2D(_Occlusion,i.uv);
				//AO
				float3 envRes = envCol*_BaseCol*_EnvIntensity*occlusion;

				float3 finalRGB = lightRes+envRes;

                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}

```

</details>
