---
title: 2021-08-16-庄懂的技术美术入门课学习笔记（二）
date: 2021-08-16 22:14:03
katex: true
tags:
  - 反射
  - Phong
  -	Blinn-Phong
  - 参数
  - BRDF
categories:
  - 庄懂的技术美术入门课学习笔记
---

> 对应课程4~6课内容

# 常用向量



![image-20210816222259466](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816222259466.png)

# 反射

## 漫反射Diffuse

![image-20210816222732514](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816222732514.png)

## 镜面反射Specular

![image-20210816222904721](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816222904721.png)

### Phong

> 公式：r dot v（反射方向点乘观察方向）

#### ShaderForge实现

1. 先对l取反方向，然后求以N为对称的向量得到反射方向，然后再和观察方向点乘。记得要把负值变成0。

   1.5 这一步等效于ViewReflect点乘光照方向$rDir=Reflect(-lDir,nDir)$
   
2. 用power结点得到高光。

> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。
>
> 注意前面lDir要乘-1！

![image-20210816234350760](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816234350760.png)

### Blinn-Phong

> Blinn-Phong的计算消耗少一些，但效果没有Phong真实，二者的高光范围有差别。
>
> 公式：n dot h （法线方向点乘半角方向）
>
> 半角：视角方向和观察方向的中间角

#### ShaderForge实现

n和h点乘后和0取max，然后再用power结点得到高光。

![image-20210816233430097](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816233430097.png)







# 应用

用Phong获得高光部分，然后和漫反射的结果add一下，得到一种常用的光照模型。

代码如下：

### Lambert+Blinn-Phong/Phong

> 获得世界空间坐标：
>
> ```c#
> o.posWS = mul(unity_ObjectToWorld,v.vertex);
> ```
>
> 求观察向量：
>
> ```c#
> float3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS)
> ```
>
> 求两个向量a、b的中间角：
> $$ normalize(\vec{a}+\vec{b}) $$



<details>
	<summary>OldSchoolShader.shader(相当于Lambert+Blinn-Phong)</summary>



```c#
Shader "Class2/OldSchoolShader" {
    Properties {
		_MainCol("颜色",color)=(1.0,1.0,1.0,1.0)
		_SpecularPow("高光次幂",range(1,90))=30
    }
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform float3 _MainCol;
			uniform float _SpecularPow;
            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
            };
            struct VertexOutput {
                float4 posCS : SV_POSITION;
				float3 posWS : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				
            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);//世界空间
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				//准备向量 
				float3 nDir = i.nDirWS;
				float3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				float3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS);
				float3 hDir = normalize(vDir+lDir);
				float3 rDir = reflect(-lDir,nDir);

				//中间值
				
				float nDotl = dot(nDir, lDir );//点乘
				float nDoth = dot(nDir,hDir);//Blinn-Phong
				float rDotv= dot(rDir,vDir);//Phong

				//光照模型
				float lambert = max(0.0, nDotl);//把负数部分取0
				float blinnPhong = pow(max(0.0,nDoth),_SpecularPow);
				float phong = pow(max(0.0,rDotv),_SpecularPow);
				float3 finalBP = _MainCol * lambert + blinnPhong;
				float3 finalP = _MainCol * lambert + phong;

                return float4(finalBP,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}
```

</details>


### 使用贴图来给物体不同部分不同光滑度
如果想使物体的不同部分看起来有不同的光滑度/粗糙度，可以用一个贴图来作为Lerp的蒙版，然后设置两种SpecularPower

![image-20210817154859550](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817154859550.png)

为了增强这种效果，可以对高光Power后再和贴图的一个通道做一次乘法，即可产生不均匀的高光。

![image-20210817155011644](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817155011644.png)

**样例1：每颗葡萄的高光范围不同**

![image-20210817155050682](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817155050682.png)

**样例2：铁上有脱落的漆皮（漆皮的光滑程度更高）**

同样直接用step处理后的贴图对两种specularPower做插值得到高光，然后用同样的贴图对两种颜色做插值，和漫反射结果相乘后加上高光即可。

![image-20210817160509757](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817160509757.png)


# 代码规范

## 参数格式

![image-20210816235743704](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210816235743704.png)

# 情报

## BRDF双向反射分布函数

> 通俗理解：
>
> 想象你有一个不透明的桌面，一个激光发射器。你先让激光向下垂直地射在那个桌面上，这样你就可以在桌面上看到一个亮点，接着你从各个不同的方向来观察那个亮点，你会发现亮点的亮度随着观察方向的不同而发生了改变。然后你站着不动，改变激光发射方向和桌面的夹角，你又会发现亮点的亮度发生了改变。这就是说，一个表面对不同的光线入射角和反射角的组合，拥有不同的反射率。BRDF就是用来对这种反射性质进行定义的。

![image-20210817161630691](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817161630691.png)

其他的BRDF效果：可用BRDF Explorer查看其他模型

![image-20210817161932407](D:\Blog\blog\images\2021-08-16-庄懂的技术美术入门课学习笔记（二）\image-20210817161932407.png)

