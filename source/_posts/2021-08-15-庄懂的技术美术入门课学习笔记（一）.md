---
title: 2021-08-15-庄懂的技术美术入门课学习笔记（一）
date: 2021-08-15 19:31:53
katex: true
tags:
  - 光照模型
  - Lambert
  - 卡通渲染
  - 半色调Halftone
  - 3S效果
  - 菲涅尔
categories:
  - 庄懂的技术美术入门课学习笔记
---

# 开始学习

[视频链接](https://space.bilibili.com/6373917/video)

[Shader Forge中文文档](https://acegikmo.com/shaderforge/nodes/?lang=zh_cn)



<!-- more -->

> 对应课程0~3课内容

## 光照模型

### Lambert光照模型

根据向量点乘的图形学含义，令

- 模型表面的垂直方向为向量nDir（法线方向）

- 光照方向的反方向为向量lDir

- 输出nDir·lDir的结果为下图的光照表现：

  ![image-20210815210059777](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815210059777.png)

其中明暗交接处之后的（即点积小于0的部分）都为纯黑色。由于负数是无意义的光照，把负数部分都取0，即为Lambert光照模型。

![image-20210815210900380](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815210900380.png)

#### ShaderForge实现

上述公式，两个向量点乘，输出到Emission上。然后用Clamp结点来限制一下范围0-1

![image-20210815212830722](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815212830722.png)

#### 代码实现

```c#
			struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float3 nDirWS : TEXCOORD0;
            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				float3 nDir = i.nDirWS;
				float3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				
				float nDotl = dot(nDir, lDir );//点乘
				float lambert = max(0.0, nDotl);//把负数部分取0

                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba
            }
```

完整代码：

<details>
  <summary>LambertShader.shader</summary>

```c#
Shader "Class1/LambertShader" {
    Properties {
    }
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0
            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float3 nDirWS : TEXCOORD0;
            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				float3 nDir = i.nDirWS;
				float3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				
				float nDotl = dot(nDir, lDir );//点乘
				float lambert = max(0.0, nDotl);//把负数部分取0

                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}
```

</details>


### 半Lambert光照模型

Lambert在明暗交界线后的部分是死黑的，半Lambert模型就是整体*0.5+0.5,让暗部显得更透气，但这样没有了明暗交界线。

![image-20210815211247604](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815211247604.png)

#### ShaderForge实现

把点乘的结果用multiply*0.5再add0.5

![image-20210815213237161](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815213237161.png)

## 调子映射

![image-20210815213947360](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815213947360.png)

ShaderForge：

在上面半Lambert模型的基础上，把输出的点乘结果和另一个常量通过Append结点结合成一个向量。这样可以得到一个uv坐标，对输入的RampTex图像文件根据该坐标采样，即可输出上面的映射后结果。

![image-20210815214138597](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815214138597.png)



## 应用

### 卡通渲染效果

> 在最亮部可能出现暗点，需要把贴图的Wrap Mode修改为Clamp而不是Repeat。
>
> 目前的描边会有比较明显的锯齿，卡渲一般会加抗锯齿后处理。

![image-20210815221158922](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210815221158922.png)

### 次表面散射效果（SSS效果）

> 次表面散射(Sub-Surface-Scattering)简称3S，用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。
>
> 主要用于模拟不完全透明材质内部表现出来的一种真实光影特效次表面散射材质是高质量渲染中最复杂的材质之一，次表面反射一般是在半透明的材质上表现最为明显，如蜡烛、大理石、玉石、等上表现最为明显。我们知道，当灯光照射到玻璃或清澈的液体表面时，灯光会穿透这些介质，[菲涅尔反射](https://baike.baidu.com/item/菲涅尔反射/6556664)的3S效果可用来模拟灯光进入介质内部后发生的散射。最典型的就是一根点亮的蜡烛，仔细观察你会[发现](https://baike.baidu.com/item/发现/75066)在烛光的照耀下，蜡烛靠近火焰的那端显出的半透明效果。实际上，3S的最大用处之一在于表现灯光照射下的人的皮肤。



上面的调子映射的v坐标采样值直接用了一个常数，即RampTex的上下没有变化。

若我们让RampTex的上下有变化，然后用一个Slider来调节v坐标采样的值，则可以实现光穿透效果的平滑变化。

![image-20210816202038366](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816202038366.png)



### 玉石效果

底色部分同上。

**1. 一个高光点**：

同样提取点积的结果后，在输出时加一个if结点，输入A，B为一个参数阈值，当A>B时输出1，小于时输出0，则可以得到高光点。

![image-20210816103327816](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816103327816.png)



**2. 两个高光点**：

给lDir加一个参数偏移向量，即光照方向的偏移值，再做点积。最后把两个If输出的结果用Max结点合起来再用Clamp结点来限制范围在0-1内。



**3. 把高光和底色合起来**：

用Lerp结点。

Lerp结点的意思：相当于ps里的两个图层，A在B上面，然后给A加一个蒙版。但在Lerp中黑白和这里的蒙版相反，即T中白色的部分露出B结点的颜色。

![image-20210816104447153](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816104447153.png)

![image-20210816105416138](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816105416138.png)

关键部分的结点连接：

![image-20210816105608144](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816105608144.png)

**4. 菲涅耳结点：**

>*什么是菲涅耳效应？*
>
>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。
>
>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？
>
>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：
>
>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)

给材质添加菲涅耳效果：

记得在Exp输入中给一个常量，然后用Multiply结点给它乘一个颜色。然后用Blend结点把上面得到的结果和菲涅耳效果叠加（Screen处的下拉选项为叠加方式）

![image-20210816112113052](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816112113052.png)

最后效果：

![image-20210816121532159](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816121532159.png)

### 条纹排线效果

**1.屏幕坐标**

直接根据屏幕坐标取UV，则uv直接根据屏幕大小来展平，不会随着物体的放大缩小旋转而改变。

若乘一个深度Depth结点，则uv会根据物体的深度而变化。

**2.step结点**

和if类似，若A<=B，则输出1，否则输出0。

上面两步的效果如下：使用点乘的结果输入step的B输入，则<0，即暗部完全为黑色，中间为条纹，亮部为白色。

![image-20210816123439908](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816123439908.png)

**3. 添加颜色**

使用Lerp结点添加一个亮部颜色和一个暗部颜色，然后用上面获得的黑白结果做蒙版遮罩即可。相当于把上面的黑色替换为A输入，白色替换为B输入。

最后可以给一个模型的基础颜色再和上面的结果相加，做一个比较平滑的颜色效果。

![image-20210816124408419](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816124408419.png)

### Halftone半色调效果

**1. 生成点阵纹理**

获取屏幕坐标，然后乘一个较大的值20，利用Frac结点取余得到一个比较密集的条纹形状。

然后使用Remap进行重映射到-0.5到0.5，再使用length结点得到一个密集的有渐变的点阵图像。length结点的公式如下：输入两个分量a和b，输出
$$
a^2+b^2=c^2
$$
![image-20210816161533779](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816161533779.png)

>  注意如果不进行重映射到-0.5到0.5，则生成的图像为一个四分之一圆形：
>
> ![image-20210816162045714](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816162045714.png)

**2. 结合lambert光照模型**

获取法向量和光线方向向量点积的值，然后做一个重映射，从1-0重映射到-0.5-2。

> 注意这里原本是1-0，也就是说把亮部映射到负值，暗部映射到正值。因为对于亮部来说，不管上面length后得到的点阵图取0-1内的任何值，它的负数次幂都大于1。即亮部会呈现为全白，不会有点阵。
>
> 对于暗部，假设映射到1-2范围内的部分映射后取值为a，对于任何0-1的数的a次幂的结果均会比原来的取值更小，当小于0.5时四舍五入取整后这部分则为全黑。

然后使用**Power结点**，把重映射的结果输入Exp。

> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。

![image-20210816164734797](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816164734797.png)_Power结点公式_

然后用round结点把渐变部分取整变成黑白即可。

![image-20210816165823653](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816165823653.png)



### 参数面板

创建一个模拟平行光（输入参数为光线方向、颜色、强度）

![image-20210816200645649](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816200645649.png)



### 风格化-把暗部做三层分离

输入一个可调节的参数vector4，然后将点积的结果和vector4的XYZ三个通道用step结点进行对比，可以得到三个分层的亮部遮罩。

![image-20210816203911475](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816203911475.png)

然后可以将上面得到的结果作为遮罩，然后分别给亮部和暗部一个颜色。

![image-20210816211440348](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816211440348.png)


# 情报

## Lut图

![image-20210816215734597](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816215734597.png)

## Houdini



![image-20210816220236911](D:\Blog\blog\images\2021-08-15-庄懂的技术美术入门课学习笔记（一）\image-20210816220236911.png)
