---
title: 2021-08-06-Frontier开发笔记（二）
date: 2021-08-06 20:51:37
tags:
  - Unity
  - 场景切换
  - GameManager
  - 单例模式
  - UI隐藏
  - 状态切换
  
categories:
  - Frontier开发笔记
---

# 重载当前的Scene

```c#
using UnityEngine.SceneManagement;

public void restart()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    }
```

退出游戏：

```c#
public void EndGame()
    {
        Application.Quit();
    }
```

 

<!-- more -->

# Game Manager

>  由于“游戏管理器”控制的都是整个游戏中一些共有的信息，所以我们不会同时需要两个游戏管理器，因此游戏管理器将是一个单例对象。

单例模式：

创建一个静态对象`static GameManager current`

直接在Awake里定义gm为this：

```c#
private void Awake()
    {
        current = this;
    }
```

然后直接用`GameManager.current`即可调用里面的变量和函数。



# UI

#### 新建UI

<div class="warning">

> 注意需要修改Canvas的设置，否则调整比例后位置可能会错乱。默认是constant with pixel size

</div>

![image-20210808163903666](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808163903666-16284119455091.png)



![image-20210808174522165](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808174522165-16284159238313.png)_设置界面UI_

<div class="warning">

> 注意当给GUI控件挂事件回调函数时，要选择上面Dynamic String的，不能选择下面静态变量。

</div>

#### 想要让Panel暂时隐藏或显示？

注意不能漏任何组件，否则可能无法交互。

![image-20210808164106909](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808164106909-16284120682902.png)

以TipUI为例：

获取`CanvasGroup`组件，设置它的透明度、可交互、可被射线撞击等等属性。

```c#
public class TipUI : MonoBehaviour
{
    private CanvasGroup _canvasGroup;
    private Node _currentNode;
    public Text tipText;
    // Start is called before the first frame update
    void Start()
    {
        _canvasGroup = gameObject.GetComponent<CanvasGroup>();//获得组件
        GameEvents.current.onOpenTipGUI += OpenTip;
    }
    //显示
    private void OpenTip(int cost,Node node)
    {
        _canvasGroup.alpha = 1;
        _canvasGroup.interactable = true;
        _canvasGroup.blocksRaycasts = true;

        tipText.text = "开发该地块需要"+cost+"经济值，是否开发？";
        _currentNode = node;
    }

    public void UnlockNode()
    {
        Debug.Log("是");
        _currentNode.Unlock();
        HideTip();
    }
    //隐藏
    public void HideTip()
    {
        _canvasGroup.alpha = 0;
        _canvasGroup.interactable = false;
        _canvasGroup.blocksRaycasts = false;
    }
}
```

然后只要调用函数`GameEvents.current.OpenTipGUI()`即可控制显示。





# 状态切换

使用`BuildingController.cs`来管理建筑的状态。

先定义枚举状态：`public enum BuildingStates { WORKING,WAITING,DEAD }`

然后在Start时初始化一个`BuildingStates`: `buildingStates = BuildingStates.WORKING;`

在Update()函数中调用`SwitchStates()`:

```c#
public void SwitchStates()
    {
        switch (buildingStates)
        {
            case BuildingStates.WORKING:
                //时间到了
                if (timeLeft <= 0)
                {
                    CoinShow(bs.BDCoin);
                    buildingStates = BuildingStates.WAITING;
                }
                else
                {
                    timeLeft -= Time.deltaTime;
                }
                break;
            case BuildingStates.WAITING:
                
                break;
            case BuildingStates.DEAD:
                //特殊土地，已经不能再使用，需要手动拆除。
                Renderer renderer = GetComponent<Renderer>();
                renderer.material.SetColor("_Color", Color.red);
                currentNode.canSpecial = false;
                break;
            default:
                break;
        }


        if (greenTimeLeft <= 0)
        {
            //GreenAdd(bs.BDGreen);
            GameManager.getGM.Green += bs.BDGreen;
            greenTimeLeft = updateTime;
        }
        else
        {
            greenTimeLeft -= Time.deltaTime;
        }
    }
```

## 特殊建筑

对于有使用轮次限制的特殊建筑，定义子类`SpecialLandController` 继承`BuildingController`，对ToWorking函数重写。使用变量count来记录工作的轮次。

> 注意只有被public和protected修饰的父类变量能被子类使用，所以要记得修改父类变量或函数的作用范围。

```c#
public class SpecialLandController : BuildingController
{
    [SerializeField]
    private int count = 0;

    public int times = 10;

    protected new void Start()
    {
        this.onToWorking += ToWorking;    // 事件注册
        init();
    }

    public new void ToWorking()
    {
        Debug.Log("子");
        timeLeft = updateTime;
        bs.GetCoin();
        count++;

        if (count >= times)
        {
            buildingStates = BuildingStates.DEAD;
        }
        else
        {
            buildingStates = BuildingStates.WORKING;
        }
        
        
    }
}
```



# 鼠标滚轮缩放Camera视图

## 小窗口显示整体地图

复制一个Camera，然后修改TargetTexture 为一个新建的RenderTexture，然后在GUI中新建RawImage，把Texture设置为摄像机输出的RenderTexture即可。

## 滚轮缩放

在Update函数中：  `Mathf.Clamp()`函数用于固定在最大和最小值范围内。

-=是鼠标滚轮上划视图放大，下滑缩小；+=反之。

```c#
//获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值
currentScale -= Input.GetAxis("Mouse ScrollWheel") * scaleSpeed;
currentScale = Mathf.Clamp(currentScale, minScale, maxScale);
```



<details>
  <summary>FollowMouseScale.cs</summary>


```c#
using UnityEngine;
using UnityEngine.UI;

public class FollowMouseScale : MonoBehaviour
{
    public GameObject mapPanel;
    public float scaleSpeed = 5.0f;
    private float minScale = 1.0f;
    private float maxScale = 150.0f;
    private float currentScale;
    private float defaultScale;

    // Use this for initialization

    void Start()
    {
        //根据当前摄像机是正交还是透视进行对应赋值

        if (Camera.main.orthographic == true)
        {
            currentScale = Camera.main.orthographicSize;
        }
        else
        {
            currentScale = Camera.main.fieldOfView;
        }
        defaultScale = currentScale;
    }

    // Update is called once per frame

    void Update()
    {

        //获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值
        currentScale -= Input.GetAxis("Mouse ScrollWheel") * scaleSpeed;
        currentScale = Mathf.Clamp(currentScale, minScale, maxScale);
        //根据当前摄像机是正交还是透视进行对应赋值，放大缩小

        if (Camera.main.orthographic == true)
        {
            Camera.main.orthographicSize = currentScale;
        }

        else
        {
            Camera.main.fieldOfView = currentScale;
        }
        //显示小窗口
        if (currentScale < defaultScale)
        {
            mapPanel.SetActive(true);
        }
        else
        {
            mapPanel.SetActive(false);
        }
    }

}
```
</details>





------
<div class="success">

> 至此Demo的基本功能已经实现了，现完成下述功能：
>
> 1. 初始化游戏的基本数值
> 2. 可动态增加不同地块种类和对应的建筑种类，方便快速管理属性值
> 3. 实现基本的经济系统
> 4. 让建筑根据固定时间间隔切换状态，并且在点击收取金币后才进入下一个工作状态。
> 5. 实现特殊的建筑行为
> 6. 鼠标滚轮缩放视图

</div>

<div class="info">

> 下一步要做的主要是美术部分：
>
> 2. 添加三种地块的建筑和材质模型
> 3. 添加鼠标悬停和点击的shader
> 4. 添加动画
> 5. 更改UI


</div>

