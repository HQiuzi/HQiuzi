---
title: 2021-08-20-庄懂的技术美术入门课学习笔记（六）
date: 2021-08-20 22:27:31
tags:
  - Hero Shader In Dota2
  - 贴图使用
  - 透明剪切
  - 轮廓光
  - 自发光
  - 双面显示
  - 贴图资源优化
categories:
  - 庄懂的技术美术入门课学习笔记
---

# 完整任务-Hero Shader In Dota2

[链接](https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish#overview)

[模型下载](https://www.dota2.com/workshop/requirements/ogre_magi)

# 资源优化

可以直接在ps通道里面操作。把图像转为灰度格式，然后选中用来合并的文件的r/g/b通道，粘贴图像。

在输出时输出**tga图像**，勾选**alpha通道**，并选择**32位**格式。

在unity导入图片时不要勾选alpha is transparency。

1. 将basecolor 和 translucency贴图合并为一张。transluency作为alpha通道。

   ![image-20210821200527858](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200527858.png)

2. specularMask，RimMask，TinyBaseMask，SpecularExponent作为RGBA四个通道合并为一张。注意处理图片上下翻转的问题。

   ![image-20210821200700134](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200700134.png)

3. FresnelWrapColor，FresnelWrapRim，FresnelWrapSpec作为RGB通道合并为一张。

   ![image-20210821200826441](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200826441.png)

4. 剩下一系列图片都类似处理一遍。

# 属性面板

```c#
    Properties {
		[Header(Texture)]
		_MainTex("RGB:颜色,A:透贴",2D )= "white" {}
		_MaskTex("R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂")="white"{}
		[Normal]_NormTex("法线贴图",2D) = "bump" {}
		_MetalnessMask("金属度遮罩",2D) = "black" {}
		_EmissionMask("自发光遮罩",2D) = "black" {}
		_DiffuseWrapTex("颜色Wrap图",2D) = "gray"{}
		_FresnelWrapTex("菲涅尔Wrap图",2D) = "gray"{}
		_CubeMap("环境球", cube ) = "_Skybox"{}

		}
```

# 向量准备和获取贴图信息

> 注意这里使用specInt对cubemapMip做插值。

```c#
				float3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				//向量准备
				float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);
				float3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world
				float3 vrDirWS = reflect(-vDirWS,nDirWS);
				float3 rDirWS = reflect(-lDir,nDirWS);

				float shadow = LIGHT_ATTENUATION(i);

				//采样纹理
				half4 mainTex = tex2D(_MainTex,i.uv0);
				half4 maskTex = tex2D(_MaskTex,i.uv0);
				half metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可
				half emissionMask = tex2D(_EmissionMask,i.uv0).r;
				half cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值
				half3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));
				half3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);//注意用vDotn来采样

				//获取信息
				half3 baseColor = mainTex.rgb;
				half opacity = mainTex.a;
				half specInt = maskTex.r;
				half rimInt = maskTex.g;
				half specTint = maskTex.b;
				half specExp = maskTex.a;
```

# 光照模型

![image-20210821220939073](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821220939073.png)



## 漫反射和镜面反射颜色

> specTint指高光染色，一般只有金属的高光有颜色。
>
> 所以将漫反射和镜面反射分开来处理，分别用metalnessMask和specTint来做插值。

```c#
//漫反射颜色用metalness，镜面反射颜色用tintmask
half3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);
half3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;
```

## Fresnel的处理

> 金属的fresnel程度比较弱，所以插值时根据matellic来插值，注意顺序。

![image-20210821222652945](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821222652945.png)

```c#
//Fresnel
half3 fresnel = lerp(fresnelTex,0.0,metalnessMask);
half fresnelCol = fresnel.r;
half fresnelRim = fresnel.g;//轮廓光
half fresnelSpec = fresnel.b;//镜面反射用
```

输出fresnel的效果如图，可以看见金属部分的fresnel效果被明显削弱。

![image-20210821223506595](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821223506595.png)



## 主光

### 漫反射：使用Diffuse Mask

第一节课学习的内容，用一个常数和halfLambert组成uv坐标，对该图片采样。

`half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));`

这样可以给皮肤叠加3S效果。上面采样的结果如下：

![image-20210822112047972](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822112047972.png)

```c#
//主光：halflambert
half halfLambert = nDotl*0.5+0.5;
half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));
half3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;//记得乘主光颜色
```



### 镜面反射

由于美术给的贴图的SpecExp范围在0-1，不足以控制高光次幂的范围，所以需要在属性面板上添加一个_SpecPow来调节。

高光强度同样加一个_SpecInt调节。

```c#
[Header(Specular)]
[PowerSlider(2)] _SpecPow("高光次幂",range(1,90))= 30
_SpecInt("高光强度",range(0.0,10.0))=5.0
```

计算主光镜面反射步骤：

> 注意phong的结果要和fresnelSpec混合起来，混合的方式是max，也可以相加

```c#
//镜面反射
//主光
half phong = pow(max(0.0,vDotr),specExp*_SpecPow);
half spec = phong*max(0.0,nDotl);//Phong*Lambert
spec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max
spec = spec*_SpecInt;//乘一个高光强度方便调节范围
half3 dirSpec = specCol*spec*_LightColor0;//记得乘主光颜色
```

得到结果：

![image-20210822120043210](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822120043210.png)

## 环境光

### 漫反射

```c#
//环境：单色光
half3 envDiff = _EnvCol*_EnvDiffInt*diffCol;//环境光颜色*环境光漫反射强度*漫反射颜色
```

### 镜面反射

使用cubemap

1. 计算反射率：考虑非金属（fresnel）和金属（metalness）的最大值
2. 混合高光颜色，反射率、反射环境和强度

```c#
//cubemap
half reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值
half envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度
```

## 轮廓光

> 只保留角色上半部分的轮廓光：乘max(0.0,nDirWS.g)
>
> 定义轮廓光时使用HDR，使其可以直接调强度。

```c#
//轮廓光
half3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);
```

![image-20210822124126070](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822124126070.png)

## 自发光

```c#
//Emission
half3 emissionRes = diffCol*_EmissionInt*emissionMask;
```

# 透明剪切

添加_Cutoff属性。

```c#
[HideInInspector] _Cutoff("Alpha cutoff",range(0.0,1.0)) = 0.5//必须叫_Cutoff,不能有差别
    

clip(opacity - _Cutoff);
```

![image-20210822153014157](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153014157.png)

## 透明剪切投影修正

此时透明剪切的投影是错误的。

原因是原来Fallback 到“Diffuse”，投影不支持剪切。

```c#
//在属性面板中添加_Color
[HideInInspector] _Color("Main Color",Color) = (1.0,1.0,1.0,1.0)
uniform half _Color;

//声明正确的回退shader
FallBack "Legacy Shaders/Transparent/Cutout/VertexLit"
```

![image-20210822153513102](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153513102.png)

# 开启双面显示

在PassTags后面声明`Cull off`即可。

![image-20210822153833360](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153833360.png)

# 完整代码

<details>
    <summary>MagiShader.shader</summary>

```c#
Shader "Magi/MagiShader"
{
    Properties {
		[Header(Texture)]
		_MainTex("RGB:颜色,A:透贴",2D )= "white" {}
		_MaskTex("R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂",2D)="white"{}
		[Normal]_NormTex("法线贴图",2D) = "bump" {}
		_MetalnessMask("金属度遮罩",2D) = "black" {}
		_EmissionMask("自发光遮罩",2D) = "black" {}
		_DiffuseWrapTex("颜色Wrap图",2D) = "gray"{}
		_FresnelWrapTex("菲涅尔Wrap图",2D) = "gray"{}
		_CubeMap("环境球", cube ) = "_Skybox"{}

		[Header(Diffuse)]
		_EnvCol("环境光颜色",color)=(1.0,1.0,1.0,1.0)

		[Header(Specular)]
		[PowerSlider(2)] _SpecPow("高光次幂",range(1,90))= 30
		_SpecInt("高光强度",range(0.0,10.0))=5.0
		_EnvSpecInt("环境镜面反射强度",range(0.0,10.0))=1.0

		[Header(RimLight)]
		[HDR] _RimCol("轮廓光颜色",color)=(1.0,1.0,1.0,1.0)
		[Header(Emission)]
		_EmissionInt("自发光强度",range(0.0,10.0))=1.0

		[HideInInspector] _Cutoff("Alpha cutoff",range(0.0,1.0)) = 0.5
		[HideInInspector] _Color("Main Color",Color) = (1.0,1.0,1.0,1.0)
		}
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            Cull off
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
			#include "AutoLight.cginc"  //使用unity投影必须包含
			#include "Lighting.cginc"  //使用unity投影必须包含

			#include "../cginc/MyCginc.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			//texture
			uniform sampler2D _MainTex;
			uniform sampler2D _MaskTex;
			uniform sampler2D _NormTex;
			uniform sampler2D _MetalnessMask;
			uniform sampler2D _EmissionMask;
			uniform sampler2D _DiffuseWrapTex;
			uniform sampler2D _FresnelWrapTex;
			uniform samplerCUBE _CubeMap;
			//DIFFUSE
			uniform half3 _EnvCol;

			//SPECULAR
			uniform half _SpecPow;
			uniform half _SpecInt;
			uniform half _EnvSpecInt;

			//rimLight
			uniform half3 _RimCol;

			//Emission
			uniform half _EmissionInt;
			
			uniform half _Cutoff;
			uniform half _Color;


            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//将模型uv信息输入进来
				float4 tangent : TANGENT;//切线
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float2 uv0 : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float3 tDirWS : TEXCOORD2;
				float3 bDirWS : TEXCOORD3;
				float4 posWS : TEXCOORD4;//世界定点信息
				LIGHTING_COORDS(5,6)
				
            };

			//输入结构>>>顶点Shader>>>输出结构
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);
				o.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);
				o.uv0 = v.uv0;

				TRANSFER_VERTEX_TO_FRAGMENT(o)

                return o;
            }

            float4 frag(VertexOutput i) : COLOR {
			//准备向量 

				float3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				//向量准备
				float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);
				float3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world
				float3 vrDirWS = reflect(-vDirWS,nDirWS);
				float3 rDirWS = reflect(-lDir,nDirWS);

				float shadow = LIGHT_ATTENUATION(i);


				float nDotl = dot(nDirWS,lDir);
				float vDotr = dot(vDirWS,rDirWS);
				float vDotn = dot(vDirWS,nDirWS);

				//采样纹理
				half4 mainTex = tex2D(_MainTex,i.uv0);
				half4 maskTex = tex2D(_MaskTex,i.uv0);
				half metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可
				half emissionMask = tex2D(_EmissionMask,i.uv0).r;
				half cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值
				half3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));
				half3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);
				//获取信息
				half3 baseColor = mainTex.rgb;
				half opacity = mainTex.a;
				half specInt = maskTex.r;
				half rimInt = maskTex.g;
				half specTint = maskTex.b;
				half specExp = maskTex.a;

				//漫反射颜色用metalness，镜面反射颜色用tintmask
				half3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);
				half3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;

				//Fresnel
				half3 fresnel = lerp(fresnelTex,0.0,metalnessMask);
				half fresnelCol = fresnel.r;
				half fresnelRim = fresnel.g;//轮廓光
				half fresnelSpec = fresnel.b;//镜面反射用


				//镜面反射
				//主光
				half phong = pow(max(0.0,vDotr),specExp*_SpecPow);
				half spec = phong*max(0.0,nDotl);//Phong*Lambert
				spec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max
				spec = spec*_SpecInt;//乘一个高光强度方便调节范围
				half3 dirSpec = specCol*spec*_LightColor0;
				//cubemap
				half reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值
				half3 envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度

				//fresnel
				half3 specRes = dirSpec*shadow+envSpec;

				//漫反射
				//主光：halflambert
				half halfLambert = nDotl*0.5+0.5;
				half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));
				half3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;
				//环境：单色光
				half3 envDiff = _EnvCol*diffCol;//环境光颜色*漫反射颜色
				half3 diffRes = dirDiff*shadow+envDiff;

				//轮廓光
				half3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);
			
				//Emission
				half3 emissionRes = diffCol*_EmissionInt*emissionMask;

				clip(opacity - _Cutoff);

				half3 res = specRes+diffRes+rimLight+emissionRes;

                return float4(res,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
	//声明正确的回退shader
    FallBack "Legacy Shaders/Transparent/Cutout/VertexLit"
}

```

</details>

#  最终效果



![image-20210822170059378](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822170059378.png)
