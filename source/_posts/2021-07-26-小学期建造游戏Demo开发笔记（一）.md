---
title: 2021-07-26-小学期建造游戏Demo开发笔记（一）
date: 2021-07-26 22:47:18
tags:
  - Action
  - 数值管理
  - ScriptObject
  - UI跟随物体
  - Unity
categories:
  - 小学期建造游戏Demo开发笔记

---

# 学习资料

* [Micael 的3DRPS游戏开发教程系列](https://space.bilibili.com/370283072/channel/seriesdetail?sid=211995)

<!-- more -->

# 开始学习

## 代码结构设计

## 在Grid上建造

获取世界坐标，转化为网格的坐标，然后在对应的位置新建物体。



## 游戏数值管理
### 保存数值：ScriptableObject

新建脚本，继承`ScriptableObject`类。
另外需要在菜单中添加项，方便对每个数值新建一个SO。
下面以不同建筑的数值管理为例，新建脚本`BuildingData_SO.cs`，用来保存数值。

```c#
[CreateAssetMenu(fileName="BuildingData",menuName= "ScriptableObjects/Building Status")]
public class BuildingData_SO : ScriptableObject
{
    [Header("Building Info")]
    public int green;
    public int coin;
    public int costCoin;
    public int updateTime;

    [Header("Other Info")]
    public string intro;

}
```
然后右键`ScriptableObjects/Building Status`，新建一个`ScriptableObjects`，然后修改名称和默认数值。如下图所示。

![image-20210728005217041](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728005217041-16274047480671.png)_一个数值模板_

### 读取和修改数值

​	上面的类只能保存数值而不能挂在物体上，需要新建一个类，继承`MonoBehavior`类，然后读取上面的Data，对于每个数值新建类，添加get和set函数。

```c#
public class BuildingStatus : MonoBehaviour
{
    public BuildingData_SO buildingData;

    #region Read from BuildingData_SO
    public int BDGreen {
        get
        {
            if (buildingData != null)
            {
                return buildingData.green;
            }
            else return 0;
        }
        set
        {
            buildingData.green = value;
        }
    }
    #endregion
}
```

### UI跟随物体定位

> [教程](https://www.bilibili.com/video/BV1ew41197m1)

#### Canvas设置

新建Canvas，首先要设置Canvas的渲染模式。默认渲染模式是Overlay，需要改成WorldSpace。记得把主摄像机拖进来。

然后重置canvas的位置。

![image-20210728183939840](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728183939840-16274687829251.png)

然后在Canvas中新建UI，调整坐标和缩放，放置于需要放置的物体上。然后把该UI拖到资源文件夹中变成Prefab，删去检视视图中的UI。

对于每个建筑的Prefab，在里面新增一个空的子物体，标记每种建筑的UI 需要显示的位置。如下图所示。

![image-20210728185002113](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728185002113-16274694030602.png)



#### 设置UI位置和朝向相机

<div class="warning">

> 注意下述语句需要在`LateUpdate()`中执行

</div>

UI位置使用`coinUI.position = coinPoint.position;`

获取主摄像机的transform，朝向相机直接用语句`coinUI.forward = -cam.forward;`

------



#### 添加事件Action

在`GameEvent.cs`中统一管理游戏事件。GameEvent是一个单例，也就是说只有一个GameEvent对象，所以用来管理UI的出现等等事件。

对于每个对象本身的事件，则写在对象的脚本中。

> Action 是对委托的一种封装，可以直接对Action进行+=和-=操作

以一部分代码为例：使用`public event Action<String> onGameMessage`定义Action。

```c#
public class GameEvents : MonoBehaviour
{   
    // 单例
    public static GameEvents current;
    
    private void Awake()
    {
        current = this;
    }
    
    // 广播游戏消息（UI显示）
    public event Action<String> onGameMessage;
    public void GameMessage(String message)
    {
        if (onGameMessage != null)
        {
            onGameMessage(message);
        }    
    }
}
```

然后在其他脚本中可以进行**事件注册**：

```c#
private void Awake()
    {
        GameEvents.current.onCoinShow += ShowCoin;    // 事件注册
     }
//定义函数
private void ShowCoin(int coin)
    {
        if (coin != null && coin>0)
        {
            coinUI.gameObject.SetActive(true);
            _textMeshProUGUI.SetText("+"+coin);
            timeLeft = visibleTime;
        }
        else
        {
            Destroy(coinUI.gameObject);
        }
    }
```

**调用事件**：

`GameEvents.current.GameMessage()`



#### 固定时间后消失

当显示UI时初始化：`timeLeft = visibleTime;`

在`LateUpdate()`中：

```c#
if (timeLeft <= 0)
{
    coinUI.gameObject.SetActive(false);
}
else
{
    timeLeft -= Time.deltaTime;
}
```

------



#### 完整代码

<details>
  <summary>CoinUI.cs</summary>

  ```c#
   public class CoinUI : MonoBehaviour
{
    public GameObject coinPrefab;
    public Transform coinPoint;
    public float visibleTime;
    public bool isVisible=true;

    private TextMeshProUGUI _textMeshProUGUI;
    private float timeLeft;

    Transform coinUI;
    Transform cam;
    BuildingController currentController;

    private void Start()
    {
        currentController = GetComponent<BuildingController>();
        currentController.onCoinShow += ShowCoin;    // 事件注册
        currentController.onCoinHide += HideCoin;    // 事件注册
        coinPoint = transform.Find("CoinPoint");
    }

    void OnEnable()
    {
        cam = Camera.main.transform;
        foreach(Canvas canvas in FindObjectsOfType<Canvas>())
        {
            if(canvas.renderMode == RenderMode.WorldSpace)
            {
                coinUI = Instantiate(coinPrefab, canvas.transform).transform;
                coinUI.gameObject.SetActive(false);
                _textMeshProUGUI = coinUI.transform.Find("Text").GetComponent<TextMeshProUGUI>();

            }
        }
    }
    private void ShowCoin(int coin)
    {
        Debug.Log("收入：" + coin);
        if (coin != null && coin>0)
        {
            coinUI.gameObject.SetActive(true);
            _textMeshProUGUI.text="+"+coin;
            timeLeft = visibleTime;
        }
        else
        {
            Destroy(coinUI.gameObject);
        }
    }
    private void HideCoin()
    {
        coinUI.gameObject.SetActive(false);
    }

    void LateUpdate()
    {
        if (coinUI != null)
        {
            coinUI.position = coinPoint.position;
            coinUI.forward = cam.forward;

            if (!isVisible)
            {
                if (timeLeft <= 0)
                {
                    HideCoin();
                }
                else
                {
                    timeLeft -= Time.deltaTime;
                }
            }
            
        }
    }

}
  ```

</details>




<details>
  <summary>CoinCount.cs</summary>

~~~c#
```c#
    public class CoinCount : MonoBehaviour
{
    private TextMeshProUGUI _textMeshProUGUI;

    // Start is called before the first frame update
    void Awake()
    {
        _textMeshProUGUI = transform.GetComponentsInChildren<TextMeshProUGUI>()[0];

        // 添加事件响应
        GameEvents.current.onCoinCountChange += ChangeCoinCount;
    }

    private void ChangeCoinCount(int coin)
    {
        
        int allCoin = GameManager.getGM.Coin;
        String str = String.Format("经济值："+allCoin);
        _textMeshProUGUI.SetText(str);
        Debug.Log("剩余：" + allCoin);
    }
}
```
~~~

</details>



   





