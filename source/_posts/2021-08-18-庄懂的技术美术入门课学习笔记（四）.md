---
title: 2021-08-18-庄懂的技术美术入门课学习笔记（四）
date: 2021-08-18 16:16:26
tags:
  - 法线
  - 菲涅尔
  - Matcap贴图
  - Cubemap贴图
categories:
  - 庄懂的技术美术入门课学习笔记
---

> 对应课程9-10课内容

# 法线

> [TBN空间](https://blog.csdn.net/bonchoix/article/details/8619624)

## ShaderForge自主实现读取法线贴图

法线贴图的信息是经过编码的，需要通过`UnpackNormal(tex2D(normalMap,uv))`来解码。

![image-20210818182522503](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182522503.png)

前面这部分也可以用Transform结点代替。记得要改下面的设置：From Tangent to World

![image-20210818213856432](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213856432.png)

结点输出结果如下：输出的法线信息不会随模型旋转而改变。![image-20210818182418574](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182418574.png)

## Code

<details>
    <summary>ReadNormalShader.shader</summary>


```c#

Shader "Class4/ReadNormalShader" {
    Properties {
		_NormalMap("法线贴图",2D) = "bump" {}
    }
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform sampler2D _NormalMap;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float4 tangent : TANGENT;
				float2 uv0 :TEXCOORD0;

            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float2 uv0 :TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float3 tDirWS : TEXCOORD2;
				float3 bDirWS : TEXCOORD3;

            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.uv0 = v.uv0;
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);
				o.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
////// Lighting:
////// Emissive:
				//准备向量
				float3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0));
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));

				float3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				
				//准备点积信息
				float nDotl = dot(nDirWS, lDir );//点乘
				float lambert = max(0.0, nDotl);//把负数部分取0

                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}
```

</details>



# 菲涅尔

>*什么是菲涅耳效应？*
>
>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。
>
>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？
>
>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：
>
>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)

![image-20210818204437765](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818204437765.png)

<div class="warning">

> 菲涅尔用于影响环境光的镜面反射效果

</div>

## Shader Forge实现

用观察方向和法线方向点乘，然后再通过One Minus结点，得到中间黑四周亮的效果。

然后可以加一个Power结点，用EXP来控制范围。

![image-20210818213335314](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213335314.png)

ShaderForge也自带Fresnel结点。





# 环境的镜面反射



## Matcap

> 思路：
>
> 1. 获得法线贴图后，把结果从切线空间转到观察空间。
> 2. 然后提取出R和G通道，remap到0-1后作为uv采样一张matcap贴图。（R通道沿屏幕朝左是-1，朝右是1；G通道沿屏幕朝下是-1，朝上是1）
> 3. 切换金属和非金属可以在把法线的结果从切线空间转到世界空间后再加一个菲涅尔效果，然后用菲涅尔次幂来调节。

![image-20210818221223851](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818221223851.png)

### Code

在参数输入面板时注意默认值：`_Matcap("Matcap", 2D ) = "gray"{}`

注意处理matcap贴图时需要先把观察空间的法线结果取r和g通道，reshape到0-1范围内作为uv坐标`float2 matcapUV = nDirVS.rg * 0.5 + 0.5;`，然后再用该uv坐标对贴图进行采样`float matcap = tex2D(_Matcap, matcapUV);`

<details>
    <summary>MatcapShader.shader</summary>

```c#
Shader "Class4/MatcapShader"
{
    Properties {
		_NormalMap("法线贴图",2D) = "bump" {}
		_Matcap("Matcap", 2D ) = "gray"{}
		_FresnelExp("菲涅尔次幂",range(0,10)) = 1
		_EnvSpecInt("环境镜面反射强度",range(0,5))=0.2
    }
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform sampler2D _NormalMap;
			uniform sampler2D _Matcap;
			uniform float _FresnelExp;
			uniform float _EnvSpecInt;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//uv0
				float4 tangent : TANGENT;//切线
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float2 uv0 : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float3 tDirWS : TEXCOORD2;
				float3 bDirWS : TEXCOORD3;
				float4 posWS : TEXCOORD4;//世界定点信息
            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);
				o.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);
				o.uv0=v.uv0;
                return o;
            }
            float4 frag(VertexOutput i) : COLOR {

				//向量准备
				float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);
				float3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world
				float3 nDirVS = mul(UNITY_MATRIX_V,float4(nDirWS,0.0));//world to view

				//中间量准备
				float2 matcapUV = nDirVS.rg * 0.5 + 0.5;//reshape
				float nDotv = dot(nDirWS,vDirWS);

				//光照模型
				float matcap = tex2D(_Matcap, matcapUV);
				float fresnel = pow(1.0 - nDotv,_FresnelExp);

				float3 envSpecLighting = matcap*fresnel*_EnvSpecInt;


                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}


```

</details>

## CubeMap

### 生成Mipmap

从网上下载一张HDR的全景图片，然后在ps里修改图像大小为512*512，修改为8位图像，再另存为tga格式。

#### 导入Unity

注意修改Texture设置为Shape，另外Mapping的方式设置为latitude，默认是错的；为了让低精度的效果更自然，需要选择Convolution Type为Specular。FixupEdge Seams最好也勾上。

![image-20210819114859407](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819114859407.png)

### ShaderForge实现

主要思路是获得观察方向，然后通过观察方向在物体表面反弹后的方向来对cubemap采样。所以输入Cubemap的是vrDir。

Normalmap+Transform结点(切线空间转世界空间)相当于获得物体法线。

![image-20210819113658345](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819113658345.png)

另外一个输入MIP指的是mip级别，相当于调节粗糙值。

可以在贴图的预览处调节滑块预览不同mip值的效果。

![image-20210819115506510](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819115506510.png)

### Code

注意参数面板的类型设置：

```c#
NormalMap("法线贴图",2D) = "bump" {}
_CubeMap("环境球", Cube ) = "Skybox"{}

//对于cubemap使用特殊的samplerCUBE采样
uniform sampler2D _NormalMap;
uniform samplerCUBE _CubeMap;

//片元着色器中读取Cubemap
float3 vrDirWS = reflect(-vDirWS,nDirWS);//记得获取观察方向的反射方向
float3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));
```

<details>
    <summary>CubemapShader.shader</summary>

```c#

Shader "Class4/CubemapShader" {
    Properties {
		_NormalMap("法线贴图",2D) = "bump" {}
		_CubeMap("环境球", Cube ) = "_Skybox"{}
		_CubemapMip("环境球MIP",range(0,7)) = 0
		_FresnelExp("菲涅尔次幂",range(0,10)) = 1
		_EnvSpecInt("环境镜面反射强度",range(0,5))=0.2
		_Occlusion ("AO",2D) = "white" {}
    }
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform sampler2D _NormalMap;
			uniform samplerCUBE _CubeMap;
			uniform sampler2D _Occlusion;
			uniform float _CubemapMip;
			uniform float _FresnelExp;
			uniform float _EnvSpecInt;
			

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float4 tangent : TANGENT;//切线
				float2 uv0 : TEXCOORD0;
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float2 uv0 : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float3 tDirWS : TEXCOORD2;
				float3 bDirWS : TEXCOORD3;
				float4 posWS : TEXCOORD4;//世界定点信息
            };
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);
				o.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);
				o.uv0 = v.uv0;
                return o;
            }
            float4 frag(VertexOutput i) : COLOR {

				//向量准备
				float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);
				float3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world

				float3 vrDirWS = reflect(-vDirWS,nDirWS);

				//中间量,做Fresnel
				float vdotn = dot(vDirWS,nDirWS);

				//cubemap
				float3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));

				float fresnel = pow(1.0-vdotn,_FresnelExp);
				float occlusion = tex2D(_Occlusion,i.uv0).r;
				float3 envSpecLighting = cubemap*fresnel*_EnvSpecInt*occlusion;



                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}

```

</details>

# 综合应用

![image-20210819172558238](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819172558238.png)

## Code

> mul()表示向量和矩阵相乘
>
> 获得环境光源的信息：
>
> 方向：`float lDir= _WorldSpaceLightPos0.xyz;`
>
> 颜色：`_LightColor0`

<details>
    <summary>OldSchoolProShader</summary>

```c#
Shader "Class4/OldSchoolProShader"
{
    Properties {
		[Header(Texture)]
		_Occlusion("AO贴图",2d)= "white" {}
		_NormalMap("法线贴图",2D) = "bump" {}
		_CubeMap("环境球", cube ) = "_Skybox"{}

		[Header(Diffuse)]
		_BaseCol("基本颜色",color)=(1.0,0.0,0.0,1.0)
		//_LightCol("光照颜色",color)=(1.0,1.0,1.0,1.0)
		_Intensity("光照强度",range(0,5))=1
		_EnvIntensity("环境光强度",range(0,5))=1
		_EnvUpCol("顶部颜色",color)=(1.0,1.0,1.0,1.0)
		_EnvDownCol("底部颜色",color)=(0.0,0.0,0.0,1.0)
		_EnvSideCol("侧面颜色",color)=(0.5,0.5,0.5,1.0)

		[Header(Specular)]
		_SpecularPow("高光次幂",range(1,90))= 30
		_CubemapMip("环境球MIP",range(0,7)) = 0
		_FresnelExp("菲涅尔次幂",range(0,10)) = 1
		_EnvSpecInt("环境镜面反射强度",range(0,5))=0.2


		}
    SubShader {
        Tags {
            "RenderType"="Opaque"
        }
        LOD 100
        Pass {
            Name "FORWARD"
            Tags {
                "LightMode"="ForwardBase"
            }
            
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
			#include "AutoLight.cginc"  //使用unity投影必须包含
			#include "Lighting.cginc"  //使用unity投影必须包含
            #pragma multi_compile_fwdbase_fullshadows
            #pragma multi_compile_fog
            #pragma target 3.0

			uniform float3 _BaseCol;
			//uniform float3 _LightCol;
			uniform float _SpecularPow;
			uniform float _Intensity;
			uniform float _EnvIntensity;
			uniform sampler2D _Occlusion;
			uniform float3 _EnvUpCol;
			uniform float3 _EnvDownCol;
			uniform float3 _EnvSideCol;

			uniform sampler2D _NormalMap;
			uniform samplerCUBE _CubeMap;
			uniform float _CubemapMip;
			uniform float _FresnelExp;
			uniform float _EnvSpecInt;

            struct VertexInput {
                float4 vertex : POSITION;
				float3 normal : NORMAL;//获取法线信息
				float2 uv0 : TEXCOORD0;//将模型uv信息输入进来
				float4 tangent : TANGENT;//切线
            };
            struct VertexOutput {
                float4 pos : SV_POSITION;
				float2 uv0 : TEXCOORD0;
				float3 nDirWS : TEXCOORD1;
				float3 tDirWS : TEXCOORD2;
				float3 bDirWS : TEXCOORD3;
				float4 posWS : TEXCOORD4;//世界定点信息
				LIGHTING_COORDS(5,6)
				
            };

			//输入结构>>>顶点Shader>>>输出结构
            VertexOutput vert (VertexInput v) {
                VertexOutput o = (VertexOutput)0;
                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间
				o.posWS = mul(unity_ObjectToWorld,v.vertex);
				o.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息
				o.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);
				o.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);
				o.uv0 = v.uv0;

				TRANSFER_VERTEX_TO_FRAGMENT(o)

                return o;
            }
            float4 frag(VertexOutput i) : COLOR {
			//准备向量 

				float3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化
				//向量准备
				float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);
				float3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;
				float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);
				float3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world
				float3 vrDirWS = reflect(-vDirWS,nDirWS);
				float3 rDirWS = reflect(-lDir,nDirWS);

				float shadow = LIGHT_ATTENUATION(i);

////// Light:
				float nDotl = dot(nDirWS,lDir);
				float vDotr = dot(vDirWS,rDirWS);
				float vDotn = dot(vDirWS,nDirWS);

				float lambert = max(0.0,nDotl);
				//float specCol = var_SpecTex.rgb;
				//float specPow = lerp(_SpecularPow,1.0,var_SpecTex.a);  //高光贴图,用rgb通道存储颜色，a通道存储光滑度
				float phong = pow(max(0.0,vDotr),_SpecularPow);

				///直接光照
				float3 lightRes =_LightColor0*(_BaseCol*lambert+phong)*_Intensity*shadow;

////// env:

				//环境光漫反射
				float upMask = max(0.0,nDirWS.g);
				float downMask = max(0.0,-nDirWS.g);
				float sideMask = 1.0-upMask-downMask;
				float3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;

				//环境光镜面反射
				//float cubemapMip=lerp(_CubemapMip,1.0,var_SpecTex.a);  //高光贴图
				float3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));
				float fresnel = pow(1.0-vDotn,_FresnelExp);

				//环境光遮罩
				float occlusion=tex2D(_Occlusion,i.uv0);

				//环境光
				float3 envSpec = cubemap*_EnvSpecInt*fresnel;
				float3 envDiff = envCol*_BaseCol*_EnvIntensity;
				float3 envRes = (envSpec+envDiff)*occlusion;

				float3 finalRGB = lightRes+envRes;

                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}

```

</details>

