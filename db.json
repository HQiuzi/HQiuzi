{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/yun/source/Yun.png","path":"Yun.png","modified":1,"renderable":1},{"_id":"themes/yun/source/yun.ico","path":"yun.ico","modified":1,"renderable":1},{"_id":"themes/yun/source/yun.svg","path":"yun.svg","modified":1,"renderable":1},{"_id":"themes/yun/source/js/gallery-decrypt.js","path":"js/gallery-decrypt.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/hexo-theme-yun.js","path":"js/hexo-theme-yun.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/say.js","path":"js/say.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"themes/yun/source/css/hexo-theme-yun.styl","path":"css/hexo-theme-yun.styl","modified":1,"renderable":1},{"_id":"themes/yun/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/comments/disqus.js","path":"js/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/analytics/leancloud-visitors.js","path":"js/analytics/leancloud-visitors.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/ui/banner.js","path":"js/ui/banner.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/ui/fireworks.js","path":"js/ui/fireworks.js","modified":1,"renderable":1},{"_id":"themes/yun/source/js/ui/mode.js","path":"js/ui/mode.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/style/banner.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1627277680915},{"_id":"source/_data/yun.yml","hash":"340e0a7a8e9039b1a2e76b7c70af6b0505da9106","modified":1630229761742},{"_id":"source/_posts/2021-07-26-小学期建造游戏Demo开发笔记（一）.md","hash":"7c234cefdd8b71fbe1ffa6307701f178afe6e8c0","modified":1630229062693},{"_id":"source/_posts/2021-07-26-日记.md","hash":"5b8b191aca2fd5624e31c47c13926cb1f2bab490","modified":1630227256664},{"_id":"source/_posts/2021-07-26-第一篇博客.md","hash":"f5d0d226e31eaeff3e06a68ef8ead786c41a5c10","modified":1630227265104},{"_id":"source/_posts/2021-08-06-小学期建造游戏Demo开发笔记（二）.md","hash":"1a125f1122077d4a8c6acdd1fa4109cffff23fe4","modified":1630226467037},{"_id":"source/_posts/2021-08-14-天使坠落绘画过程记录.md","hash":"04bddabf5c1dc52ce6acc036335cd9710f7ec376","modified":1629201661149},{"_id":"source/_posts/2021-08-09-小学期建造游戏Demo开发笔记（三）.md","hash":"d598617058726bb6e873e71e105a2a86e36532e3","modified":1630226521722},{"_id":"source/_posts/2021-08-15-庄懂的技术美术入门课学习笔记（一）.md","hash":"a28beb19d88b83a79c52cf0b5c38b96f6bff2743","modified":1629201793763},{"_id":"source/_posts/2021-08-16-庄懂的技术美术入门课学习笔记（二）.md","hash":"401f293aa0cf513cff9bbdc3edd1112c2fb51279","modified":1629618273634},{"_id":"source/_posts/2021-08-17-庄懂的技术美术入门课学习笔记（三）.md","hash":"08d5feffa3af3196afda4ccd44e904f8e4662efc","modified":1629290616361},{"_id":"source/_posts/2021-08-18-庄懂的技术美术入门课学习笔记（四）.md","hash":"1322ec7cdcb0fa0117814f4b40a52788553bb77d","modified":1630227520484},{"_id":"source/_posts/2021-08-19-庄懂的技术美术入门课学习笔记（五）.md","hash":"dde7ce5050391b6321d78379303c03afbea59f33","modified":1630227502710},{"_id":"source/_posts/2021-08-20-庄懂的技术美术入门课学习笔记（六）.md","hash":"c8be84c95338c6fd7a2d92d77e60db6e3b4a7a6e","modified":1630227525089},{"_id":"source/categories/index.md","hash":"4a6bb7458e4f72ffbe36da784a88e49c497ec645","modified":1627310718141},{"_id":"source/about/index.md","hash":"8ab1ee8a048fdd2ff9129317f740beedef0ea0c2","modified":1630227307368},{"_id":"source/albums/concert.md","hash":"f419c64fb9ac198b054c21a275d6b306ee6cbb75","modified":1630230073344},{"_id":"source/albums/index.md","hash":"48d99db8730a279de3d2a2a9bf35cf21adc2d116","modified":1630229936889},{"_id":"source/albums/yms.md","hash":"73a8700414a817c50261b8e1fb59d451454a323d","modified":1630228810496},{"_id":"source/_posts/2021-07-30-3d辅助作画尝试.md","hash":"83800272624a224849b6218b497b13d5b80b25f1","modified":1628416885561},{"_id":"source/_data/style/sidebar.styl","hash":"427465be82df63ccb88a25938213f3ea11531c95","modified":1627250518137},{"_id":"source/tags/index.md","hash":"d53e834941150d77670355ba4e08a88a2eaf9beb","modified":1627317559667},{"_id":"themes/yun/.eslintrc.js","hash":"ba8a899820888efce3741d4daf21f99291998ec1","modified":1627242978429},{"_id":"themes/yun/.gitignore","hash":"eff49494f374c44c21ce6012dd9bc73f9c1fb591","modified":1627242978457},{"_id":"themes/yun/_config.yml","hash":"2fc58050261bd030aad14b2cd63d636722ebf0ad","modified":1627281540058},{"_id":"themes/yun/_vendors.yml","hash":"87fe6521ec79c6970f52709fb01cc5a443bd149f","modified":1627242978470},{"_id":"source/_posts/2021-08-06-快捷键等小tips.md","hash":"3cba0675d2797ce3d4080798ad076f448df29b42","modified":1628689937775},{"_id":"themes/yun/package.json","hash":"365530fc2d10ab49d8366ede812b4ac971eff77d","modified":1627242978576},{"_id":"themes/yun/tsconfig.json","hash":"e075aed161843d2cdf3b58fc84940bfb5b1b0286","modified":1627242978634},{"_id":"themes/yun/.github/FUNDING.yml","hash":"2c7dd51870c178dd679cb5221b57b853167b55a9","modified":1627242978430},{"_id":"themes/yun/LICENSE","hash":"fa221ceba871b104543fa698b80750fc19552fd2","modified":1627242978458},{"_id":"themes/yun/data/_comments.yml","hash":"21116cde2a4024e41f1f53ba32077759069f41ca","modified":1627242978471},{"_id":"themes/yun/languages/default.yml","hash":"3866a13fe896b4c5d46541c5cab1f7e61453df19","modified":1627242978526},{"_id":"themes/yun/languages/en.yml","hash":"11c482bee3bda200125392c607a0bddc0f74f552","modified":1627242978526},{"_id":"themes/yun/languages/zh-CN.yml","hash":"ef5675e4e6f4a42251ac1a08c4fd5f46d5e27a1f","modified":1627242978529},{"_id":"themes/yun/languages/ja.yml","hash":"18ab694a0c64f4c0e53b570495625901e883df24","modified":1627242978528},{"_id":"themes/yun/layout/404.pug","hash":"9a158dd3f74a32008a7450522a7da39c4ae6abb7","modified":1627242978530},{"_id":"themes/yun/layout/archive.pug","hash":"fcbd3bee3e2dc053170888d77de007ec330443be","modified":1627242978571},{"_id":"themes/yun/layout/category.pug","hash":"fc234721ac03d519dbdf39675af5a86e0b6db2e8","modified":1627242978572},{"_id":"themes/yun/layout/gallery.pug","hash":"80bc2502412d7e28405b9d79d93c8d619c31ae4f","modified":1627242978573},{"_id":"themes/yun/layout/girls.pug","hash":"1ffe8e69a5c20cf0c34c8001f291f014beb5762c","modified":1627242978573},{"_id":"themes/yun/layout/index.pug","hash":"72ce130efc06d107d5244e54d62bd533abe88bff","modified":1627242978574},{"_id":"themes/yun/layout/links.pug","hash":"b752504e651dcf35003edbe22700098b25d5c160","modified":1627242978574},{"_id":"themes/yun/layout/page.pug","hash":"0b7e8fd201b88056f66a3f6a06884cb8eba71b16","modified":1627242978574},{"_id":"themes/yun/layout/post.pug","hash":"d5ffdbd47d39eb302872c2e17d7bc46194160e44","modified":1627242978575},{"_id":"themes/yun/layout/slide.pug","hash":"5374bcfaddfdfa0feb05b3829c0cfa0d7939cf7f","modified":1627242978575},{"_id":"themes/yun/layout/tag.pug","hash":"f1c2ae57b62f6a0c6fcc91a1270b5bf328ca2421","modified":1627242978576},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"themes/yun/source/yun.ico","hash":"5d63418cd650d1881d4b6507f35b9f9df766020e","modified":1627242978633},{"_id":"themes/yun/source/yun.svg","hash":"78218ba93f0150e3613c7d0b60575ebe6131255f","modified":1627242978634},{"_id":"themes/yun/.github/ISSUE_TEMPLATE/feature_request.md","hash":"57972849d8dc6fa63a6a0b4a2c7bbe4649c0843a","modified":1627242978447},{"_id":"themes/yun/docs/README.md","hash":"428e385ec211f79a95c5dd2d51fe2e23a849a253","modified":1627242978504},{"_id":"themes/yun/.github/ISSUE_TEMPLATE/bug_report.md","hash":"9a960b4706d17aed9ec9be4f71716130469d55b4","modified":1627242978446},{"_id":"themes/yun/README.md","hash":"297a89f392af0ddcd3a958c329b699013eed7e4f","modified":1627242978458},{"_id":"themes/yun/.github/ISSUE_TEMPLATE/usage_problem.md","hash":"b41af96573f4b7b1c4492e8fc014685537ccbce8","modified":1627242978447},{"_id":"themes/yun/docs/.vuepress/config.ts","hash":"abc3a1178c07ced1878202c4f890b4a19f03b2be","modified":1627242978480},{"_id":"themes/yun/.github/workflows/docs.yml","hash":"d0762ef6861ce5a576251003494a0944931b1cfa","modified":1627242978457},{"_id":"themes/yun/docs/demo/README.md","hash":"40afcba7990cef22a5cfedf1f558b350414d90f9","modified":1627242978506},{"_id":"themes/yun/docs/about/icon.md","hash":"118b2a8ba9453b6639917e9e96e9ae54eaa8cee2","modified":1627242978506},{"_id":"themes/yun/docs/en/README.md","hash":"c69223c1a8fa97e73344f3947a9871bd9c6cdc29","modified":1627242978508},{"_id":"themes/yun/source/Yun.png","hash":"b8ae426fa5dd7579d23d189c222641d812c51c0a","modified":1627242978589},{"_id":"themes/yun/docs/guide/additional-package-support.md","hash":"20c7fcedb4ce2705c86f6e86b4b418e407475a93","modified":1627242978521},{"_id":"themes/yun/docs/guide/README.md","hash":"6ec149ec07c3b8fd9cd1d65d451338afe883681d","modified":1627242978521},{"_id":"themes/yun/docs/guide/migrate.md","hash":"5fe91b4c8c3c87eb72f6555dba5aa96faf17e87b","modified":1627242978523},{"_id":"themes/yun/docs/about/README.md","hash":"b069cc513b830fd6c17fb4ebde63601ca27539eb","modified":1627242978505},{"_id":"themes/yun/docs/guide/third-party-support.md","hash":"1f72314664185c08a98907528fa55a8a5a736750","modified":1627242978525},{"_id":"themes/yun/layout/_mixin/icon.pug","hash":"18ee2c33b4e6ef71c31d7955f9a20789fe6aa9e4","modified":1627242978532},{"_id":"themes/yun/layout/_mixin/index.pug","hash":"3c6964b4594e842e2aefcd316bdd0184750b40f1","modified":1627242978532},{"_id":"themes/yun/layout/_mixin/page-header.pug","hash":"56771304fc062882fcb83b3a57036cb12a6d2dab","modified":1627242978532},{"_id":"themes/yun/layout/_mixin/post-categories.pug","hash":"ee645a5c54c279e2346b7ba9f629efab61314026","modified":1627242978533},{"_id":"themes/yun/layout/_mixin/post-collapse.pug","hash":"741195a5a29ecb5863b1fd0c3b203d960aae05c1","modified":1627242978534},{"_id":"themes/yun/layout/_mixin/post-tags.pug","hash":"10eec5c3dad74e73a2ee9c05434e4757c080fcb5","modified":1627242978534},{"_id":"themes/yun/docs/guide/page.md","hash":"9354301591f3994649b15594846be9635f37e599","modified":1627242978524},{"_id":"themes/yun/layout/_partial/background.pug","hash":"d0995a2e840ac2698df3e45f9c6ee7eccdf94f9a","modified":1627242978536},{"_id":"themes/yun/layout/_partial/banner.pug","hash":"4aadc9256c07914cb16dd98ab63a56a2e33aabb8","modified":1627242978536},{"_id":"themes/yun/layout/_partial/head.pug","hash":"ff6c41e56519c84d044a3339f2deb43dc26aa4e1","modified":1627242978537},{"_id":"themes/yun/layout/_partial/layout.pug","hash":"3ec3dcca9697edbe868c791d4f28957012755d06","modified":1627242978538},{"_id":"themes/yun/layout/_partial/footer.pug","hash":"d75a31959f81b3d4b80c85e946a8f3085cb7a3c8","modified":1627242978536},{"_id":"themes/yun/layout/_partial/pagination.pug","hash":"b55b6a99b105447b4a6c982fa258680a2a9a34a9","modified":1627242978538},{"_id":"themes/yun/layout/_partial/recent-posts.pug","hash":"8e9438e8cf95cf544a674e6b6bdf5cdd76e63b61","modified":1627242978542},{"_id":"themes/yun/layout/_partial/sidebar.pug","hash":"c4ef88a4bce0d7c2ac315c03eb5a64a70ebb644d","modified":1627242978543},{"_id":"themes/yun/layout/_third-party/aplayer.pug","hash":"93d2be35ae9731056563d3cbdbf7b13b1933c80c","modified":1627242978550},{"_id":"themes/yun/layout/_third-party/cdn.pug","hash":"53982879ad13077c198857034e21201517923a98","modified":1627242978550},{"_id":"themes/yun/layout/_third-party/index.pug","hash":"f6275c094349839c5af019e8a7f3f394ba0339bd","modified":1627242978558},{"_id":"themes/yun/layout/_third-party/lightgallery.pug","hash":"63d2d1c4f55ea15fe8399bfe5da953581dd7a4b6","modified":1627242978559},{"_id":"themes/yun/layout/_third-party/google-tagmanager.pug","hash":"4760e37fb37a41ef1417a427c0168c5fc5dd2ee6","modified":1627242978557},{"_id":"themes/yun/layout/_third-party/pjax.pug","hash":"f72620c6b56183d1061295b881b4738eeb49ab7f","modified":1627242978562},{"_id":"themes/yun/layout/_widget/aplayer.pug","hash":"0a5ff8bc629ccd7c0e04664647bfff7fec152229","modified":1627242978565},{"_id":"themes/yun/layout/_widget/back-to-top.pug","hash":"4c880afb3213395fb64e8a6a4fc3b653bb82b938","modified":1627242978565},{"_id":"themes/yun/layout/_widget/cloud.pug","hash":"eb3185db30fef0303b667e50b96a7d85edda8006","modified":1627242978565},{"_id":"themes/yun/layout/_widget/mourn.pug","hash":"49eb1ebdb67c0529f00474bba2f99e87b8407266","modified":1627242978567},{"_id":"themes/yun/layout/_widget/index.pug","hash":"96d4a92e258688b17328d4470bacaabaccace67c","modified":1627242978566},{"_id":"themes/yun/layout/_widget/notice.pug","hash":"346ada39ba6586cb631ac5b1f129683f3ee015f4","modified":1627242978567},{"_id":"themes/yun/layout/_widget/say.pug","hash":"2f32b3933b62d285eabb08af6ceaf02ba29a5eae","modified":1627242978568},{"_id":"themes/yun/scripts/events/config.js","hash":"82b7eab0787aff932f5e97047fd6c9b9692956de","modified":1627242978579},{"_id":"themes/yun/scripts/events/data.js","hash":"c041d3bdf16318a377b3224cb9aea655380efecc","modified":1627242978580},{"_id":"themes/yun/scripts/events/index.js","hash":"45abc9b50cc4c10b2bbda1788233bdb3017a0715","modified":1627242978580},{"_id":"themes/yun/scripts/helpers/encrypt.js","hash":"e3e0cd73a5bf0413a9e8fe96b1622f40c2c1db50","modified":1627242978583},{"_id":"themes/yun/scripts/events/utils.js","hash":"0a3af6b400ed7e86b3b83d49dd1fdb868563c2a1","modified":1627242978581},{"_id":"themes/yun/scripts/tags/prompt.js","hash":"621d0fa41d15e5617b8a25dd7625c8e5691b35b6","modified":1627242978589},{"_id":"themes/yun/scripts/helpers/engine.js","hash":"9b41629b73dc5bbc18772b292a029531bfd2beca","modified":1627242978584},{"_id":"themes/yun/scripts/filters/index.js","hash":"ca5ef23cec64ac3fc53aae702a8684a53d98f71c","modified":1627242978582},{"_id":"themes/yun/scripts/helpers/yun-config.js","hash":"5018b34f22241cf01a0639dd212058f04994d6dd","modified":1627242978588},{"_id":"themes/yun/scripts/helpers/index.js","hash":"1b0d52542255837702cdc41d3885c349c5be5873","modified":1627242978587},{"_id":"themes/yun/source/js/hexo-theme-yun.js","hash":"53b38073a4069c2baf6fd2ba5e3a435fadb2bc4f","modified":1627242978626},{"_id":"themes/yun/source/js/pjax.js","hash":"dbdf52e28d17374bc5bd2cf7cc57ae625a65a70d","modified":1627242978627},{"_id":"themes/yun/docs/guide/config.md","hash":"0fd2414e8aebacb90ec77c6fe6c527508a3d4739","modified":1627242978522},{"_id":"themes/yun/source/js/utils.js","hash":"61de0f1ff9fcf1bf64cec20d9e9c05b1d111bc92","modified":1627242978633},{"_id":"themes/yun/source/js/sidebar.js","hash":"454f38ec93a7629837e21ae8fb09f8f09fed8a90","modified":1627242978631},{"_id":"themes/yun/source/css/hexo-theme-yun.styl","hash":"8dc5e0e8a566debaf3b7299907924fc3cc79a6e4","modified":1627242978623},{"_id":"themes/yun/docs/.vuepress/assets/README.md","hash":"aa4ab3ddd73a3cf356bcb79a77c57c0dcfe2fada","modified":1627242978474},{"_id":"themes/yun/source/js/gallery-decrypt.js","hash":"0fdfe233d36b93ea4309040f4a254c3a48e4f3e6","modified":1627242978626},{"_id":"themes/yun/docs/.vuepress/assets/icons.json","hash":"63b421ead217b5eb14cdcaaa1aa2263fb4c8e9d2","modified":1627242978475},{"_id":"themes/yun/docs/guide/faq.md","hash":"caf23698ff982fedbb00f59e0f6580b8067d1806","modified":1627242978522},{"_id":"themes/yun/docs/.vuepress/components/DemoSites.vue","hash":"2b9d705750ee663210168347c32c55eb1e019062","modified":1627242978477},{"_id":"themes/yun/docs/.vuepress/components/DemoSite.vue","hash":"705e7ad2047e24ecb3221a0f9389eed966239aba","modified":1627242978476},{"_id":"themes/yun/docs/.vuepress/public/CNAME","hash":"c7ffe7d5488a88dfa38ef3780292c22088d5e8ce","modified":1627242978486},{"_id":"themes/yun/docs/.vuepress/assets/sites.json","hash":"56976a33ec89a7b5841e0cb6dc596c1ff83f48d2","modified":1627242978476},{"_id":"themes/yun/docs/.vuepress/components/DisplayIcon.vue","hash":"c2177efd18926a526071afd4af06b0cf1d7b7cbf","modified":1627242978479},{"_id":"themes/yun/docs/.vuepress/public/manifest.json","hash":"9eee8d68bc3b6afa3e22ef4fd02d3bd09c707e1f","modified":1627242978498},{"_id":"themes/yun/docs/.vuepress/scripts/index.js","hash":"c61b839368e3fa7bb7292b21446e145b2b8ecd23","modified":1627242978500},{"_id":"themes/yun/source/js/say.js","hash":"b44b3730d7167bbc2c33e5b154a7bb5d936b7710","modified":1627278295900},{"_id":"themes/yun/docs/.vuepress/scripts/markdown.js","hash":"740f5a1cca2843d9d0ae3c2ff91cbeab04500730","modified":1627242978501},{"_id":"themes/yun/docs/.vuepress/styles/palette.styl","hash":"25a57ac820b471bc91c151347a1c1d0cc62767d6","modified":1627242978503},{"_id":"themes/yun/docs/.vuepress/scripts/generate-demo.js","hash":"d0b1d113e7cda000c805efe2824a0146bf368c5e","modified":1627242978500},{"_id":"themes/yun/docs/.vuepress/types/index.ts","hash":"7539a35c7deab9c0207569c1cd90b5bb0e381851","modified":1627242978504},{"_id":"themes/yun/docs/.vuepress/public/yun.svg","hash":"78218ba93f0150e3613c7d0b60575ebe6131255f","modified":1627242978498},{"_id":"themes/yun/docs/.vuepress/public/logo.gif","hash":"a2e7143f1f890f58a3c06b8c0acd7a7a3225022f","modified":1627242978497},{"_id":"themes/yun/docs/en/demo/README.md","hash":"a4f3c6174142bb986953dca953402f294f005890","modified":1627242978511},{"_id":"themes/yun/docs/en/guide/README.md","hash":"6e3365ecfe54d513bf9dbdd2da2702c831d7d4b6","modified":1627242978513},{"_id":"themes/yun/docs/en/about/README.md","hash":"45acb0c1830d34c8c23e790670c31f00eef52de9","modified":1627242978509},{"_id":"themes/yun/docs/.vuepress/styles/index.scss","hash":"ab7b5bb51a39abfa2a23c875af9d1beb4059b7fb","modified":1627242978502},{"_id":"themes/yun/docs/en/about/icon.md","hash":"eca142f28f2bd9f7019c39c6cfcc92650c21ed70","modified":1627242978509},{"_id":"themes/yun/docs/en/guide/additional-package-support.md","hash":"b0b9ca67462eb8b3e580c0dfbdc63f725dca590b","modified":1627242978514},{"_id":"themes/yun/docs/en/guide/third-party-support.md","hash":"c129956235e081689947ed33a56103fe42efd4d8","modified":1627242978520},{"_id":"themes/yun/layout/_partial/post/post-edit.pug","hash":"2b7d4c210815ddc63c5b6fc5b5fd6a348e75093f","modified":1627242978540},{"_id":"themes/yun/layout/_partial/post/post-copyright.pug","hash":"a2415fb36a0dffbe57bf32cd2cfeace11cbaed6b","modified":1627242978539},{"_id":"themes/yun/layout/_partial/post/post-meta.pug","hash":"9aebdcdea704842b010a0e34073c6bb864cf9515","modified":1627242978540},{"_id":"themes/yun/layout/_partial/post/post-nav.pug","hash":"ea351236ab82ff43b66272de1baade70d868131f","modified":1627242978540},{"_id":"themes/yun/layout/_partial/post/post-schema.pug","hash":"ec85079174da20c9f608b142e7fda2c28a9b1dac","modified":1627242978541},{"_id":"themes/yun/layout/_partial/post/reward.pug","hash":"f19b6562f1df71c23dafed15f2f3c9415414e281","modified":1627242978542},{"_id":"themes/yun/layout/_partial/sidebar/info.pug","hash":"db26c881a5d8c8e2d96c2e5598e9c3c40d135cdf","modified":1627242978544},{"_id":"themes/yun/layout/_third-party/adsense/google-adsense.pug","hash":"ae63305d776ebec0d88f91197b5c78cdaa401585","modified":1627242978547},{"_id":"themes/yun/layout/_third-party/analytics/busuanzi.pug","hash":"d606071c4c4f1e0df9f55fa6c8e248eb2591c484","modified":1627242978548},{"_id":"themes/yun/layout/_third-party/analytics/google-analytics.pug","hash":"3533cdc143c0b9b4304e375e0a1d2527050d989a","modified":1627242978549},{"_id":"themes/yun/layout/_third-party/analytics/leancloud-visitors.pug","hash":"b837ea28a4b0e81a3f584eee2e7b7ce69c8befc6","modified":1627242978549},{"_id":"themes/yun/layout/_third-party/comments/disqus.pug","hash":"5bfe34b45242487d9ab8e5bc97d8b0371658df8a","modified":1627242978551},{"_id":"themes/yun/layout/_third-party/comments/disqusjs.pug","hash":"54613c0acf1b57da6591c505944a0848f7696032","modified":1627242978552},{"_id":"themes/yun/layout/_third-party/comments/github-discussions.pug","hash":"1b559cbb7bcd1d423eab9d9a2ffdb8b7ebbbcea4","modified":1627242978552},{"_id":"themes/yun/layout/_third-party/comments/github-issues.pug","hash":"11801bd330160555dbaf3ef13955ebd61010c7d6","modified":1627242978553},{"_id":"themes/yun/layout/_third-party/comments/index.pug","hash":"536ce0c65ccc1753858427f25a767f812ef75972","modified":1627242978553},{"_id":"themes/yun/layout/_third-party/comments/livere.pug","hash":"f565efde0ee74d69555e8b5c959c96e0f1ae61fb","modified":1627242978554},{"_id":"themes/yun/layout/_third-party/comments/utterances.pug","hash":"44adb592fa4995ff586b6b4ff16232323473992a","modified":1627242978556},{"_id":"themes/yun/layout/_third-party/comments/minivaline.pug","hash":"0548263c9f0460916aaeaf77928d27612c1a2897","modified":1627242978555},{"_id":"themes/yun/layout/_third-party/comments/twikoo.pug","hash":"719ecaa5b6d166ae0ef0adafc37136e1346379d6","modified":1627242978555},{"_id":"themes/yun/layout/_third-party/comments/valine.pug","hash":"98901bdb9de7318a06a7b293a8dcc4e5b22d0992","modified":1627242978556},{"_id":"themes/yun/layout/_third-party/comments/waline.pug","hash":"f6a735878ad7e971f9105c8eb654b862af87dbbf","modified":1627242978557},{"_id":"themes/yun/layout/_third-party/seo/baidu-push.pug","hash":"5b08e856a6c75a9b4a5aafccf52b1b418dac0e38","modified":1627242978563},{"_id":"themes/yun/layout/_widget/search/algolia-search.pug","hash":"e15f78a38d386d57c1a19b4a760115bd14edbb0d","modified":1627242978570},{"_id":"themes/yun/layout/_third-party/math/index.pug","hash":"0365a84a14325a52ee574df3f633f96c7a47d78f","modified":1627242978560},{"_id":"themes/yun/layout/_third-party/math/katex.pug","hash":"94ca4fffb5ca7fda7c3e243ff8597a19d0583372","modified":1627242978561},{"_id":"themes/yun/layout/_widget/search/index.pug","hash":"a1dd964e05b5412c3fc446d80576e51b37926b87","modified":1627242978570},{"_id":"themes/yun/layout/_widget/search/local-search.pug","hash":"d2ba600623043b2410f379fd7ba3cc75329ff408","modified":1627242978571},{"_id":"themes/yun/docs/en/guide/faq.md","hash":"b4630278cb17266b1727354ae7b5786c963345cb","modified":1627242978516},{"_id":"themes/yun/source/js/search/algolia-search.js","hash":"babe61a9a2b2dc921dce6737863b7f0b53eaa750","modified":1627242978629},{"_id":"themes/yun/docs/en/guide/page.md","hash":"02718f061b22f7a1506623c426eb2553860cfede","modified":1627242978517},{"_id":"themes/yun/source/js/comments/disqus.js","hash":"d7e532c58a26ffbf5578fc42f370d73a6289205e","modified":1627242978625},{"_id":"themes/yun/source/css/_components/button.styl","hash":"3315fc12b1b7659a06120b042a1a2e87a839ebe1","modified":1627242978591},{"_id":"themes/yun/source/css/_components/card.styl","hash":"6d16aae8534f32a8ce439e648e347c98c1e58af3","modified":1627242978591},{"_id":"themes/yun/source/css/_components/scrollbar.styl","hash":"3e332ae27d3aeab1496079cd509649ceccc0f4b5","modified":1627242978598},{"_id":"themes/yun/source/css/_components/ui.styl","hash":"8ef28ee3363f3676c9327a6d163032a003520f40","modified":1627242978603},{"_id":"themes/yun/source/js/ui/banner.js","hash":"67f4d40d0e5518d58bd66b3c544d8908358ffc5e","modified":1627250087368},{"_id":"themes/yun/source/css/_extend/albums.styl","hash":"b0f703fc6e279844b75797edf714cce2135704ed","modified":1627242978604},{"_id":"themes/yun/source/js/analytics/leancloud-visitors.js","hash":"39da9b031923d56cd941265818943aa8b5677049","modified":1627242978624},{"_id":"themes/yun/source/js/ui/fireworks.js","hash":"c98826194c90d35f64591c87f9bc64f5891af900","modified":1627242978632},{"_id":"themes/yun/source/js/search/local-search.js","hash":"8a22e764624baf973f08b1195105630ed1f1b3e7","modified":1627242978630},{"_id":"themes/yun/source/css/_global/index.styl","hash":"01cc3bea8ddbcff5353f98edc6a5073ba89cc53c","modified":1627242978607},{"_id":"themes/yun/source/css/_global/reset.styl","hash":"d1640eb4f76a3cf792c5149e93c42c85da5a29b2","modified":1627242978607},{"_id":"themes/yun/docs/en/guide/config.md","hash":"525fe73429074defc00cef163a6d66fb102720dd","modified":1627242978515},{"_id":"themes/yun/source/css/_layout/banner.styl","hash":"da9f871576a69439a6984af495d4f13b3613aa00","modified":1627248543899},{"_id":"themes/yun/source/css/_helper/index.styl","hash":"a1d8c100c8eaba73bf0b5ff412e8fa7b025e621b","modified":1627242978608},{"_id":"themes/yun/source/css/_layout/footer.styl","hash":"ed3afcddad7358ebd89f01846157e26a586e7adf","modified":1627242978610},{"_id":"themes/yun/source/css/_layout/grid.styl","hash":"afada46bff9956d51a539ed4732e320b55032b5a","modified":1627242978610},{"_id":"themes/yun/source/css/_layout/main.styl","hash":"03669973c1cbb5c93fdba4c011666b921f0587e3","modified":1627242978612},{"_id":"themes/yun/source/css/_layout/links.styl","hash":"9c060919f57a9928331aec8c7bfaae56a6fa8401","modified":1627242978610},{"_id":"themes/yun/source/css/_layout/page.styl","hash":"52ff29d8bdc61dedb0a6515dd84cf015db67a499","modified":1627242978613},{"_id":"themes/yun/source/css/_layout/post.styl","hash":"29e0fe7a0f7948d551d37d1054d88524052baa3d","modified":1627242978614},{"_id":"themes/yun/source/css/_layout/pagination.styl","hash":"00f95595a8937c7ce4c6069c78e8574600b67d73","modified":1627242978614},{"_id":"themes/yun/source/css/_mixins/helper.styl","hash":"09e560ae6db2bccaf39dff8882977cab2e9dec3b","modified":1627242978616},{"_id":"themes/yun/source/css/_mixins/base.styl","hash":"0430e840b280cd6258c4cdf9397c49e89bff2682","modified":1627242978615},{"_id":"themes/yun/source/css/_variables/_base.styl","hash":"d94e4e978e4d9cdb361a906f2f417787ed86f86a","modified":1627242978617},{"_id":"themes/yun/source/css/_widget/back-to-top.styl","hash":"d86e0c0c6af9fcb293c1fcef20f4ed68272ccc71","modified":1627242978618},{"_id":"themes/yun/source/css/_variables/_colors.styl","hash":"f7f492e8bd96c7054909fc360e392bc3984dae8d","modified":1627242978617},{"_id":"themes/yun/source/css/_widget/index.styl","hash":"640fea56a013989f5878334d09f3f9b716865c8c","modified":1627242978618},{"_id":"themes/yun/source/css/_widget/notice.styl","hash":"8b1ca54535311f38b91433e5beadbeed02ecd28b","modified":1627242978619},{"_id":"themes/yun/source/css/_widget/comment.styl","hash":"fe9e597e3470027f6d81acf557a36d1fba4c86a5","modified":1627242978618},{"_id":"themes/yun/source/css/_widget/say.styl","hash":"5649187827d9f2a1eec8e18626a405d7c5ceb7ab","modified":1627277688601},{"_id":"themes/yun/docs/.vuepress/public/images/mickey-mouse.jpg","hash":"96a9449730d5149b8d114c2a7d8caaa364257dd0","modified":1627242978489},{"_id":"themes/yun/docs/.vuepress/configs/sidebar/en.ts","hash":"c6ddf398205381e97a159d24258b32d7474df56a","modified":1627242978484},{"_id":"themes/yun/docs/.vuepress/configs/sidebar/zh.ts","hash":"1353e31c9c0fb127abc3306a4ee7ffaf46fa0e86","modified":1627242978485},{"_id":"themes/yun/docs/.vuepress/configs/sidebar/index.ts","hash":"cb1ae897a9c7a33807e97f8c8d066af871f20c67","modified":1627242978484},{"_id":"themes/yun/docs/.vuepress/configs/navbar/zh.ts","hash":"115c8c42482a5c1b561c6976f9c07b8fd05d34b5","modified":1627242978482},{"_id":"themes/yun/docs/.vuepress/configs/navbar/en.ts","hash":"a14ee57fbff98f729ba3a22e3b5dc6e21b1d4804","modified":1627242978482},{"_id":"themes/yun/docs/.vuepress/configs/navbar/index.ts","hash":"c0156915b804350cce4d02fb15f39338cb78c32d","modified":1627242978482},{"_id":"themes/yun/source/css/_components/post/post-card.styl","hash":"dedc42a3e2ea3c98dcedacebf8c190d0938bd88c","modified":1627242978592},{"_id":"themes/yun/source/css/_components/post/post-codebloack.styl","hash":"ca312b2acfee5f8019e39937500a7ed17762f72a","modified":1627242978593},{"_id":"themes/yun/source/css/_components/post/post-collapse.styl","hash":"6741c225a37e7e121d4159f129b7024402a8eeec","modified":1627242978594},{"_id":"themes/yun/source/css/_components/post/post-header.styl","hash":"3be5d23cda0020365dbfb39ca35eb00aef65e7cd","modified":1627242978595},{"_id":"themes/yun/source/css/_components/post/post-nav.styl","hash":"cec22a5a36eda86b1ee8038e1fa24d9a6c9a0f7f","modified":1627242978597},{"_id":"themes/yun/source/css/_components/post/post-markdown.styl","hash":"b536c98fff32c6370022f4a3c63f3617b890ef82","modified":1627242978596},{"_id":"themes/yun/source/css/_components/post/post-reward.styl","hash":"454aa79758c9be46c8d8fa226b38e7ac1834ce3b","modified":1627242978598},{"_id":"themes/yun/source/css/_components/sidebar/hamburger.styl","hash":"0fa240e8a71fdad14d3fd6b3fd49cf697d4c8153","modified":1627242978599},{"_id":"themes/yun/source/css/_components/sidebar/sidebar-nav.styl","hash":"a8c2eb2d01a02855ff074e2765c5275f839c7315","modified":1627242978600},{"_id":"themes/yun/source/css/_components/sidebar/sidebar-toc.styl","hash":"fe429fb5aa85739c23a052737aba12418149b182","modified":1627242978600},{"_id":"themes/yun/source/css/_components/sidebar/sidebar.styl","hash":"21b2532c943e06bae70ed2a6b341b4816ce55898","modified":1627242978602},{"_id":"themes/yun/source/css/_components/sidebar/site-overview.styl","hash":"1a34782575569c8fec4489716a3dae13a88c8170","modified":1627242978602},{"_id":"themes/yun/source/css/_extend/tags/index.styl","hash":"84112e467510c4d78dc8d9e6cbe1a5012e4d20d8","modified":1627242978605},{"_id":"themes/yun/source/css/_extend/tags/prompt.styl","hash":"4294c5e7f3aef84d369a8ac71f8340e39a681c59","modified":1627242978606},{"_id":"themes/yun/source/css/_widget/search/algolia-search.styl","hash":"d008422dfd104304f50e472a431afa16cad0e15a","modified":1627242978621},{"_id":"themes/yun/source/css/_widget/search/index.styl","hash":"271036cc7fad9414a8e2dd55292a1a3773b8bae0","modified":1627242978622},{"_id":"themes/yun/source/css/_widget/search/local-search.styl","hash":"06468fd1f85390134d4cf034dc5abcc114018257","modified":1627242978622},{"_id":"themes/yun/docs/.vuepress/public/images/index-preview.jpg","hash":"31aaa79aff97bdb98945c541d6bc698d450e078e","modified":1627242978487},{"_id":"themes/yun/source/css/_global/dark.styl","hash":"5c0609091e9afd11a7a6b13bc4be986918ee35ca","modified":1627242978606},{"_id":"themes/yun/source/js/ui/mode.js","hash":"f17fa75c84d03cdb6d8ecafcea05d3fd7cbc3ee7","modified":1627242978632},{"_id":"themes/yun/source/css/_extend/girls.styl","hash":"393166ea98ef4bee611dcf00f5e8e22df60b2af0","modified":1627242978604},{"_id":"public/categories/index.html","hash":"ae4bcd92fef88322e5aefa9b8a5716ca8407d5d8","modified":1630230248664},{"_id":"public/albums/concert.html","hash":"ade46d73a8614bb7c5c377ef953943c7e9ae1d5a","modified":1630230248664},{"_id":"public/albums/yms.html","hash":"0ee8c16f96bfd1fec85ee87b9165a5d00fb0c903","modified":1630230248664},{"_id":"public/about/index.html","hash":"ee3078cee27d8a378c19f2b1a433c221443fec56","modified":1630230248664},{"_id":"public/albums/index.html","hash":"14bd663c0993fb16b2d2fbe17fea4eafe9df35d3","modified":1630230248664},{"_id":"public/tags/index.html","hash":"d2a05d396f910f9ec290db685258ff3b65eecbdd","modified":1630230248664},{"_id":"public/2021/07/27/2021-07-26-日记/index.html","hash":"6778a5113dfa228ff370deccb0be8158021dc2aa","modified":1630230248664},{"_id":"public/2021/07/30/2021-07-30-3d辅助作画尝试/index.html","hash":"9c1dba2f22b119fbe4ce729c18e525f819513827","modified":1630230248664},{"_id":"public/archives/index.html","hash":"8894a61e92f0dbe22037a34dcaf6d3886e982e62","modified":1630230248664},{"_id":"public/2021/07/26/hello-world/index.html","hash":"56adcff2e3aa1aa38a00370c2020e1fb5c926102","modified":1630230248664},{"_id":"public/archives/2021/index.html","hash":"404ef9338df7c907b74f46c32e9a9ddd9ca75bd9","modified":1630230248664},{"_id":"public/archives/page/2/index.html","hash":"321efad6552c652166b1f8f167e9d0d1a6ed3df1","modified":1630230248664},{"_id":"public/archives/2021/page/2/index.html","hash":"8c8dbe54899e7b3a336d6b05b3398a8569562200","modified":1630230248664},{"_id":"public/archives/2021/07/index.html","hash":"118ec59ba4e9ffeac6e6dc497e81f62c649b1f71","modified":1630230248664},{"_id":"public/archives/2021/08/index.html","hash":"e1aba1c20b6564e8727ea444771dc84a81e6b323","modified":1630230248664},{"_id":"public/categories/小学期建造游戏Demo开发笔记/index.html","hash":"01b9247876679f5538c15583f3161352b40bef60","modified":1630230248664},{"_id":"public/categories/日记/index.html","hash":"66fa6df5d5c8590e4fe24c51ed83f5e67a6fc2da","modified":1630230248664},{"_id":"public/categories/比较杂的知识点/index.html","hash":"481440e2b1e1dea7d642226b1609831ff84ab2f1","modified":1630230248664},{"_id":"public/categories/画画笔记/index.html","hash":"3165b974ca83b51e1a242df2907801612fc4a0a6","modified":1630230248664},{"_id":"public/categories/庄懂的技术美术入门课学习笔记/index.html","hash":"64d3569947e63f331864ef5f4a3bfeccc6c8a353","modified":1630230248664},{"_id":"public/tags/Action/index.html","hash":"7329e703e816602fcb0f2160b5be9f82edc651b0","modified":1630230248664},{"_id":"public/tags/数值管理/index.html","hash":"21168a50726552e6f140d42b4fe5710032199e31","modified":1630230248664},{"_id":"public/tags/ScriptObject/index.html","hash":"4a3c67d0554de6220810537d5a7d0c6856b3e46d","modified":1630230248664},{"_id":"public/tags/UI跟随物体/index.html","hash":"4a3ecb05b49590757546863247a5d0fdddd4eb36","modified":1630230248664},{"_id":"public/tags/Unity/index.html","hash":"01887361ca2e18c527b2f98088c906faa892649b","modified":1630230248664},{"_id":"public/tags/hexo/index.html","hash":"a36486ec000bb12eb660a5108b0c861c3cd73912","modified":1630230248664},{"_id":"public/tags/场景切换/index.html","hash":"ba488b662547cebaddd75042b11a1c99a37849ad","modified":1630230248664},{"_id":"public/tags/GameManager/index.html","hash":"2b26de9373bc1e3b6f3f10d6b7e66bb70dbe6561","modified":1630230248664},{"_id":"public/tags/单例模式/index.html","hash":"0b8b382343bf28d1d51a606269cd20dbcf14197d","modified":1630230248664},{"_id":"public/tags/UI隐藏/index.html","hash":"add90b2383f9c410363d05b7f6f68add4a328c51","modified":1630230248664},{"_id":"public/tags/状态切换/index.html","hash":"d8638bfeede2bb8254579e75a9f2253c21385d8d","modified":1630230248664},{"_id":"public/tags/3d辅助/index.html","hash":"107a57a16536cfcf16c392fe2986f3a9c815afd3","modified":1630230248664},{"_id":"public/tags/Daz/index.html","hash":"486abe17375176ca3ce0a26ddc51023046e695a9","modified":1630230248664},{"_id":"public/tags/渐变映射/index.html","hash":"de0de29af51b06acabb93c4a07f9a320a50072da","modified":1630230248664},{"_id":"public/tags/Blender贴图绘制/index.html","hash":"e95978c79dd9cd4c2a105c3e436ded6a44397471","modified":1630230248664},{"_id":"public/tags/光照模型/index.html","hash":"fe1ceb8c7b83852af8bdac6ae61539f54f937270","modified":1630230248664},{"_id":"public/tags/Lambert/index.html","hash":"32ea0c46e51fe8560e97fc6cc6aac8488adad0c4","modified":1630230248664},{"_id":"public/tags/卡通渲染/index.html","hash":"c2d01d9c8b8e49af7600af2f6f098a9eb5c76665","modified":1630230248664},{"_id":"public/tags/半色调Halftone/index.html","hash":"034167811ddb42c5c624c27ca8b16ca0c8fed61f","modified":1630230248664},{"_id":"public/tags/3S效果/index.html","hash":"d90e59cdbaeb5e93854ea5bd7e254c1cd874ae14","modified":1630230248664},{"_id":"public/tags/菲涅尔/index.html","hash":"612e0a927385cee8f31e4b334f918ea970189e1f","modified":1630230248664},{"_id":"public/tags/反射/index.html","hash":"e10e5db92f160ded42f90d0ba7614464f051ca78","modified":1630230248664},{"_id":"public/tags/Phong/index.html","hash":"f4011eb26a52b330888f3dda095905236a8940ce","modified":1630230248664},{"_id":"public/tags/Blinn-Phong/index.html","hash":"ee56d945bdfc0c4955cedf5d8cac84d367af6b72","modified":1630230248664},{"_id":"public/tags/BRDF/index.html","hash":"ca8856417d5701df99e0b04fdb59cfc3eed17973","modified":1630230248664},{"_id":"public/tags/环境光/index.html","hash":"57a9e683f2cb854771516913c4c1b104116cc0f0","modified":1630230248664},{"_id":"public/tags/AO/index.html","hash":"fc9724a04846d859377e9e77cf73ece873035568","modified":1630230248664},{"_id":"public/tags/投影/index.html","hash":"bbbee00c00872c90f66be7e600589734539538f8","modified":1630230248664},{"_id":"public/tags/参数/index.html","hash":"3f06529427c6fff853a66a3fb4987ebc60d9fe62","modified":1630230248664},{"_id":"public/tags/输入类型/index.html","hash":"0b8019d326eb7e02f705282211f73a9abed41221","modified":1630230248664},{"_id":"public/tags/输出类型/index.html","hash":"cc3911aa572e6a660b08f5b2ffaf0aa64b2109ff","modified":1630230248664},{"_id":"public/tags/顶点操作/index.html","hash":"3ba6c21222928cfe43e4ea7910b6b19d55e0d93a","modified":1630230248664},{"_id":"public/tags/Hero-Shader-In-Dota2/index.html","hash":"8de0c95faa1840eacc81c53600aebe6b9b2b4775","modified":1630230248664},{"_id":"public/tags/贴图使用/index.html","hash":"86bb11704dd92adf15cc1071803f5667108b9a42","modified":1630230248664},{"_id":"public/tags/透明剪切/index.html","hash":"a1a526f292bd29889f0df77047f30bb0d22c3924","modified":1630230248664},{"_id":"public/tags/轮廓光/index.html","hash":"40aabb3ba472e2ced845958b66a334a6851600d4","modified":1630230248664},{"_id":"public/tags/自发光/index.html","hash":"746cd127a32b96bdd66cfe7f92e2537117bb405f","modified":1630230248664},{"_id":"public/tags/双面显示/index.html","hash":"271463ed8add00e2d6ba813bedb984162313c142","modified":1630230248664},{"_id":"public/tags/贴图资源优化/index.html","hash":"9dd113ac853576eb66ba9b8a9cf45c824210abe1","modified":1630230248664},{"_id":"public/tags/法线/index.html","hash":"42577bf1d7cf5612787b960634afbf32ae3c4be2","modified":1630230248664},{"_id":"public/tags/Matcap贴图/index.html","hash":"05b41e1bff92f9f3344024cfa9c9a0cb5a8db926","modified":1630230248664},{"_id":"public/tags/Cubemap贴图/index.html","hash":"cb266d0b2677ccaa65a372b24cd66d1645dff6cd","modified":1630230248664},{"_id":"public/2021/08/20/2021-08-20-庄懂的技术美术入门课学习笔记（六）/index.html","hash":"bddca23b710dc308b6f5bf8ff8395b6a87adf6a6","modified":1630230248664},{"_id":"public/2021/08/18/2021-08-18-庄懂的技术美术入门课学习笔记（四）/index.html","hash":"20fe29464d2184d8dfd838f2f85c22ce77eea459","modified":1630230248664},{"_id":"public/2021/08/17/2021-08-17-庄懂的技术美术入门课学习笔记（三）/index.html","hash":"d6aa208c2259ba7d37620d7409bde0f90260e3f5","modified":1630230248664},{"_id":"public/2021/08/19/2021-08-19-庄懂的技术美术入门课学习笔记（五）/index.html","hash":"3c5a029b3352354dd8562a78aa64d6da8e5cc2b9","modified":1630230248664},{"_id":"public/2021/08/16/2021-08-16-庄懂的技术美术入门课学习笔记（二）/index.html","hash":"63913aac0b812851e270205248e2632a03a582ac","modified":1630230248664},{"_id":"public/2021/08/15/2021-08-15-庄懂的技术美术入门课学习笔记（一）/index.html","hash":"2e5b18032ec280f69dcecd72e6efee10cefcf169","modified":1630230248664},{"_id":"public/2021/08/14/2021-08-14-天使坠落绘画过程记录/index.html","hash":"33b7e20a304246b9fdeea289a5960e664e459fda","modified":1630230248664},{"_id":"public/2021/08/09/2021-08-09-小学期建造游戏Demo开发笔记（三）/index.html","hash":"845c5969aaaa2e3b15af8459e7d063521757fc42","modified":1630230248664},{"_id":"public/2021/08/06/2021-08-06-小学期建造游戏Demo开发笔记（二）/index.html","hash":"53ffffe1094ab026f637f393b85babfef8a533d1","modified":1630230248664},{"_id":"public/2021/08/06/2021-08-06-快捷键等小tips/index.html","hash":"51ab70d3d2272aba20f4f21c1e8b9645985c3f9a","modified":1630230248664},{"_id":"public/2021/07/26/2021-07-26-第一篇博客/index.html","hash":"de6d88cb9fee1df58705c9ccab625ec34ce79be5","modified":1630230248664},{"_id":"public/2021/07/26/2021-07-26-小学期建造游戏Demo开发笔记（一）/index.html","hash":"261e6220a0ba7335ebdcc8ca13fb6716986fecf8","modified":1630230248664},{"_id":"public/page/2/index.html","hash":"1e1ebf534354d04c118ac6866aed6ad3dcb4c2bf","modified":1630230248664},{"_id":"public/index.html","hash":"17e07d10577eae9aa09360348f7950a62afacbfe","modified":1630230248664},{"_id":"public/Yun.png","hash":"b8ae426fa5dd7579d23d189c222641d812c51c0a","modified":1630230248664},{"_id":"public/yun.svg","hash":"78218ba93f0150e3613c7d0b60575ebe6131255f","modified":1630230248664},{"_id":"public/yun.ico","hash":"5d63418cd650d1881d4b6507f35b9f9df766020e","modified":1630230248664},{"_id":"public/css/hbe.style.css","hash":"b0a0077cb588c0941823905fcc383aa7509ade73","modified":1630230248664},{"_id":"public/lib/hbe.js","hash":"136dba00826bdd086153bf0acb5473aea7183ad1","modified":1630230248664},{"_id":"public/js/gallery-decrypt.js","hash":"9fdbb18bc6f2df816497288d2d0d7d5171046ab1","modified":1630230248664},{"_id":"public/js/pjax.js","hash":"4fd54bd75d9eb751770543ad3dcf2ee03c8485c5","modified":1630230248664},{"_id":"public/js/hexo-theme-yun.js","hash":"ea104f1b49f4418c4168d29f8a12086bd91274df","modified":1630230248664},{"_id":"public/js/say.js","hash":"e0908e35d0fb9d825596a476b27e265175ebf053","modified":1630230248664},{"_id":"public/js/sidebar.js","hash":"ad553417673b72cdc465cdab7205a43c68b07eae","modified":1630230248664},{"_id":"public/js/search/algolia-search.js","hash":"5133e150f4b0168bfe64ad5cbcb5625de08dd6b9","modified":1630230248664},{"_id":"public/js/utils.js","hash":"0a9f4898904737c37b36d53be9697b8f991ca1e3","modified":1630230248664},{"_id":"public/js/search/local-search.js","hash":"7cfeb3474cb13664bdfc2c518371d409df406c6a","modified":1630230248664},{"_id":"public/js/analytics/leancloud-visitors.js","hash":"7719a85b7da5ae52659451729fab52e065462f30","modified":1630230248664},{"_id":"public/js/ui/banner.js","hash":"49f7be469e61fb7f82477cb83ce7bc67cf83499a","modified":1630230248664},{"_id":"public/js/comments/disqus.js","hash":"0fac74f042c0e8818a1d01580204d70d0ab13f52","modified":1630230248664},{"_id":"public/js/ui/fireworks.js","hash":"5fea87a42f3f4b0cbb13fe8b46195e9bb41e64a5","modified":1630230248664},{"_id":"public/js/ui/mode.js","hash":"42b868d77fcc5eac53f5520dd89db385595555d0","modified":1630230248664},{"_id":"public/css/hexo-theme-yun.css","hash":"9b50c026272482cdaa335b9c4cc628ce98b546e3","modified":1630230248664}],"Category":[{"name":"小学期建造游戏Demo开发笔记","_id":"cksx100kx00043svoe0jihimq"},{"name":"日记","_id":"cksx100l4000c3svo5r2t7sxj"},{"name":"比较杂的知识点","_id":"cksx100l7000i3svo848428jf"},{"name":"画画笔记","_id":"cksx100ld000s3svo7k18f4i5"},{"name":"庄懂的技术美术入门课学习笔记","_id":"cksx100lf000z3svobrf6fhd3"}],"Data":[{"_id":"style/banner","data":""},{"_id":"yun","data":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}}},{"_id":"style/sidebar","data":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}],"Page":[{"title":"categories","date":"2021-07-26T14:40:41.000Z","comments":0,"type":"categories","_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-07-26 22:40:41\ncomments: false\ntype: categories\n---\n\n\n","updated":"2021-07-26T14:45:18.141Z","path":"categories/index.html","layout":"page","_id":"cksx100jn00003svo9409fgui","content":"","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":""},{"title":"个人作品","date":"2021-07-26T07:59:23.000Z","updated":"2021-07-26T07:59:23.000Z","layout":"gallery","photos":[{"caption":"天使","src":"https://z3.ax1x.com/2021/08/15/fgj740.png","desc":"2021-8"},{"caption":"迷","src":"https://z3.ax1x.com/2021/08/29/hG1zef.png","desc":"2021-8"},{"caption":"TITLE","src":"https://z3.ax1x.com/2021/08/29/hG1vOP.png","desc":"2021-1"},{"caption":"狗","src":"https://z3.ax1x.com/2021/08/29/hG3Sw8.png","desc":"2021-2"},{"caption":"照片临摹","src":"https://z3.ax1x.com/2021/08/29/hG8tvn.png","desc":"2020-7"},{"caption":"作品集封面","src":"https://z3.ax1x.com/2021/08/29/hGGfQs.png","desc":"2019-8"},{"caption":"网络","src":"https://z3.ax1x.com/2021/08/29/hGGhyn.png","desc":"2019-5"},{"caption":"手绘","src":"https://z3.ax1x.com/2021/08/29/hGYVCF.jpg","desc":"2018-11"}],"_content":"","source":"albums/concert.md","raw":"---\ntitle: 个人作品\ndate: 2021-07-26 15:59:23\nupdated: 2021-07-26 15:59:23\nlayout: gallery\nphotos:\n  - caption: 天使\n    src: https://z3.ax1x.com/2021/08/15/fgj740.png\n    desc: 2021-8\n  - caption: 迷\n    src: https://z3.ax1x.com/2021/08/29/hG1zef.png\n    desc: 2021-8\n  - caption: TITLE\n    src: https://z3.ax1x.com/2021/08/29/hG1vOP.png\n    desc: 2021-1\n  - caption: 狗\n    src: https://z3.ax1x.com/2021/08/29/hG3Sw8.png\n    desc: 2021-2\n  - caption: 照片临摹\n    src: https://z3.ax1x.com/2021/08/29/hG8tvn.png\n    desc: 2020-7\n  - caption: 作品集封面\n    src: https://z3.ax1x.com/2021/08/29/hGGfQs.png\n    desc: 2019-8\n  - caption: 网络\n    src: https://z3.ax1x.com/2021/08/29/hGGhyn.png\n    desc: 2019-5\n  - caption: 手绘\n    src: https://z3.ax1x.com/2021/08/29/hGYVCF.jpg\n    desc: 2018-11\n\n---","path":"albums/concert.html","comments":1,"_id":"cksx100kv00023svo84ch25yo","content":"","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":""},{"title":"about","date":"2021-07-26T07:32:17.000Z","_content":"\n## 你好，我是HQZ！\n\n> 觉得自己不能一直废物下去，需要坚持写点东西，所以做了这个主页。\n\n<div class=\"danger\">\n\n> 如果图片加载不出来可能需要挂梯子，图片全部在github上。\n\n</div>\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-07-26 15:32:17\n---\n\n## 你好，我是HQZ！\n\n> 觉得自己不能一直废物下去，需要坚持写点东西，所以做了这个主页。\n\n<div class=\"danger\">\n\n> 如果图片加载不出来可能需要挂梯子，图片全部在github上。\n\n</div>\n\n\n","updated":"2021-08-29T08:55:07.368Z","path":"about/index.html","comments":1,"layout":"page","_id":"cksx100ky00063svob3a0hwgs","content":"<h2 id=\"你好，我是HQZ！\"><a href=\"#你好，我是HQZ！\" class=\"headerlink\" title=\"你好，我是HQZ！\"></a>你好，我是HQZ！</h2><blockquote>\n<p>觉得自己不能一直废物下去，需要坚持写点东西，所以做了这个主页。</p>\n</blockquote>\n<div class=\"danger\">\n\n<blockquote>\n<p>如果图片加载不出来可能需要挂梯子，图片全部在github上。</p>\n</blockquote>\n</div>\n\n\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<h2 id=\"你好，我是HQZ！\"><a href=\"#你好，我是HQZ！\" class=\"headerlink\" title=\"你好，我是HQZ！\"></a>你好，我是HQZ！</h2><blockquote>\n<p>觉得自己不能一直废物下去，需要坚持写点东西，所以做了这个主页。</p>\n</blockquote>\n<div class=\"danger\">\n\n<blockquote>\n<p>如果图片加载不出来可能需要挂梯子，图片全部在github上。</p>\n</blockquote>\n</div>\n\n\n"},{"title":"青梅青柚","date":"2021-07-26T07:59:23.000Z","updated":"2021-07-26T07:59:23.000Z","layout":"gallery","photos":[{"caption":"人设","src":"https://z3.ax1x.com/2021/08/29/hGGpGQ.jpg","desc":"2018-10"},{"caption":"横版","src":"https://z3.ax1x.com/2021/08/29/hGG92j.jpg","desc":"2018-11"}],"_content":"","source":"albums/yms.md","raw":"---\ntitle: 青梅青柚\ndate: 2021-07-26 15:59:23\nupdated: 2021-07-26 15:59:23\nlayout: gallery\nphotos:\n  - caption: 人设\n    src: https://z3.ax1x.com/2021/08/29/hGGpGQ.jpg\n    desc: 2018-10\n  - caption: 横版\n    src: https://z3.ax1x.com/2021/08/29/hGG92j.jpg\n    desc: 2018-11\n\n---","path":"albums/yms.html","comments":1,"_id":"cksx100l000083svoad164s5m","content":"","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":""},{"title":"albums","date":"2021-07-26T07:59:23.000Z","type":"albums","albums":[{"caption":"个人作品","url":"/albums/concert.html","cover":"https://z3.ax1x.com/2021/08/29/hG1zef.png","desc":"年更选手"},{"caption":"青媒角色设计","url":"/albums/yms.html","cover":"https://z3.ax1x.com/2021/08/29/hGG92j.jpg","desc":"年更选手"}],"_content":"","source":"albums/index.md","raw":"---\ntitle: albums\ndate: 2021-07-26 15:59:23\ntype: albums\nalbums:\n  - caption: 个人作品\n    url: /albums/concert.html\n    cover: https://z3.ax1x.com/2021/08/29/hG1zef.png\n    desc: 年更选手\n  - caption: 青媒角色设计\n    url: /albums/yms.html\n    cover: https://z3.ax1x.com/2021/08/29/hGG92j.jpg\n    desc: 年更选手\n---\n","updated":"2021-08-29T09:38:56.889Z","path":"albums/index.html","comments":1,"layout":"page","_id":"cksx100l2000a3svo7e1nh4li","content":"","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":""},{"title":"tags","date":"2021-07-26T16:38:55.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-07-27 00:38:55\ntype: tags\ncomments: false\n---\n","updated":"2021-07-26T16:39:19.667Z","path":"tags/index.html","layout":"page","_id":"cksx100l5000e3svo6sgd48co","content":"","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":""}],"Post":[{"title":"2021-07-26-小学期建造游戏Demo开发笔记（一）","date":"2021-07-26T14:47:18.000Z","_content":"\n# 学习资料\n\n* [Micael 的3DRPS游戏开发教程系列](https://space.bilibili.com/370283072/channel/seriesdetail?sid=211995)\n\n<!-- more -->\n\n# 开始学习\n\n## 代码结构设计\n\n## 在Grid上建造\n\n获取世界坐标，转化为网格的坐标，然后在对应的位置新建物体。\n\n\n\n## 游戏数值管理\n### 保存数值：ScriptableObject\n\n新建脚本，继承`ScriptableObject`类。\n另外需要在菜单中添加项，方便对每个数值新建一个SO。\n下面以不同建筑的数值管理为例，新建脚本`BuildingData_SO.cs`，用来保存数值。\n\n```c#\n[CreateAssetMenu(fileName=\"BuildingData\",menuName= \"ScriptableObjects/Building Status\")]\npublic class BuildingData_SO : ScriptableObject\n{\n    [Header(\"Building Info\")]\n    public int green;\n    public int coin;\n    public int costCoin;\n    public int updateTime;\n\n    [Header(\"Other Info\")]\n    public string intro;\n\n}\n```\n然后右键`ScriptableObjects/Building Status`，新建一个`ScriptableObjects`，然后修改名称和默认数值。如下图所示。\n\n![image-20210728005217041](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728005217041-16274047480671.png)_一个数值模板_\n\n### 读取和修改数值\n\n​\t上面的类只能保存数值而不能挂在物体上，需要新建一个类，继承`MonoBehavior`类，然后读取上面的Data，对于每个数值新建类，添加get和set函数。\n\n```c#\npublic class BuildingStatus : MonoBehaviour\n{\n    public BuildingData_SO buildingData;\n\n    #region Read from BuildingData_SO\n    public int BDGreen {\n        get\n        {\n            if (buildingData != null)\n            {\n                return buildingData.green;\n            }\n            else return 0;\n        }\n        set\n        {\n            buildingData.green = value;\n        }\n    }\n    #endregion\n}\n```\n\n### UI跟随物体定位\n\n> [教程](https://www.bilibili.com/video/BV1ew41197m1)\n\n#### Canvas设置\n\n新建Canvas，首先要设置Canvas的渲染模式。默认渲染模式是Overlay，需要改成WorldSpace。记得把主摄像机拖进来。\n\n然后重置canvas的位置。\n\n![image-20210728183939840](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728183939840-16274687829251.png)\n\n然后在Canvas中新建UI，调整坐标和缩放，放置于需要放置的物体上。然后把该UI拖到资源文件夹中变成Prefab，删去检视视图中的UI。\n\n对于每个建筑的Prefab，在里面新增一个空的子物体，标记每种建筑的UI 需要显示的位置。如下图所示。\n\n![image-20210728185002113](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728185002113-16274694030602.png)\n\n\n\n#### 设置UI位置和朝向相机\n\n<div class=\"warning\">\n\n> 注意下述语句需要在`LateUpdate()`中执行\n\n</div>\n\nUI位置使用`coinUI.position = coinPoint.position;`\n\n获取主摄像机的transform，朝向相机直接用语句`coinUI.forward = -cam.forward;`\n\n------\n\n\n\n#### 添加事件Action\n\n在`GameEvent.cs`中统一管理游戏事件。GameEvent是一个单例，也就是说只有一个GameEvent对象，所以用来管理UI的出现等等事件。\n\n对于每个对象本身的事件，则写在对象的脚本中。\n\n> Action 是对委托的一种封装，可以直接对Action进行+=和-=操作\n\n以一部分代码为例：使用`public event Action<String> onGameMessage`定义Action。\n\n```c#\npublic class GameEvents : MonoBehaviour\n{   \n    // 单例\n    public static GameEvents current;\n    \n    private void Awake()\n    {\n        current = this;\n    }\n    \n    // 广播游戏消息（UI显示）\n    public event Action<String> onGameMessage;\n    public void GameMessage(String message)\n    {\n        if (onGameMessage != null)\n        {\n            onGameMessage(message);\n        }    \n    }\n}\n```\n\n然后在其他脚本中可以进行**事件注册**：\n\n```c#\nprivate void Awake()\n    {\n        GameEvents.current.onCoinShow += ShowCoin;    // 事件注册\n     }\n//定义函数\nprivate void ShowCoin(int coin)\n    {\n        if (coin != null && coin>0)\n        {\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.SetText(\"+\"+coin);\n            timeLeft = visibleTime;\n        }\n        else\n        {\n            Destroy(coinUI.gameObject);\n        }\n    }\n```\n\n**调用事件**：\n\n`GameEvents.current.GameMessage()`\n\n\n\n#### 固定时间后消失\n\n当显示UI时初始化：`timeLeft = visibleTime;`\n\n在`LateUpdate()`中：\n\n```c#\nif (timeLeft <= 0)\n{\n    coinUI.gameObject.SetActive(false);\n}\nelse\n{\n    timeLeft -= Time.deltaTime;\n}\n```\n\n------\n\n\n\n#### 完整代码\n\n<details>\n  <summary>CoinUI.cs</summary>\n\n  ```c#\n   public class CoinUI : MonoBehaviour\n{\n    public GameObject coinPrefab;\n    public Transform coinPoint;\n    public float visibleTime;\n    public bool isVisible=true;\n\n    private TextMeshProUGUI _textMeshProUGUI;\n    private float timeLeft;\n\n    Transform coinUI;\n    Transform cam;\n    BuildingController currentController;\n\n    private void Start()\n    {\n        currentController = GetComponent<BuildingController>();\n        currentController.onCoinShow += ShowCoin;    // 事件注册\n        currentController.onCoinHide += HideCoin;    // 事件注册\n        coinPoint = transform.Find(\"CoinPoint\");\n    }\n\n    void OnEnable()\n    {\n        cam = Camera.main.transform;\n        foreach(Canvas canvas in FindObjectsOfType<Canvas>())\n        {\n            if(canvas.renderMode == RenderMode.WorldSpace)\n            {\n                coinUI = Instantiate(coinPrefab, canvas.transform).transform;\n                coinUI.gameObject.SetActive(false);\n                _textMeshProUGUI = coinUI.transform.Find(\"Text\").GetComponent<TextMeshProUGUI>();\n\n            }\n        }\n    }\n    private void ShowCoin(int coin)\n    {\n        Debug.Log(\"收入：\" + coin);\n        if (coin != null && coin>0)\n        {\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.text=\"+\"+coin;\n            timeLeft = visibleTime;\n        }\n        else\n        {\n            Destroy(coinUI.gameObject);\n        }\n    }\n    private void HideCoin()\n    {\n        coinUI.gameObject.SetActive(false);\n    }\n\n    void LateUpdate()\n    {\n        if (coinUI != null)\n        {\n            coinUI.position = coinPoint.position;\n            coinUI.forward = cam.forward;\n\n            if (!isVisible)\n            {\n                if (timeLeft <= 0)\n                {\n                    HideCoin();\n                }\n                else\n                {\n                    timeLeft -= Time.deltaTime;\n                }\n            }\n            \n        }\n    }\n\n}\n  ```\n\n</details>\n\n\n\n\n<details>\n  <summary>CoinCount.cs</summary>\n\n~~~c#\n```c#\n    public class CoinCount : MonoBehaviour\n{\n    private TextMeshProUGUI _textMeshProUGUI;\n\n    // Start is called before the first frame update\n    void Awake()\n    {\n        _textMeshProUGUI = transform.GetComponentsInChildren<TextMeshProUGUI>()[0];\n\n        // 添加事件响应\n        GameEvents.current.onCoinCountChange += ChangeCoinCount;\n    }\n\n    private void ChangeCoinCount(int coin)\n    {\n        \n        int allCoin = GameManager.getGM.Coin;\n        String str = String.Format(\"经济值：\"+allCoin);\n        _textMeshProUGUI.SetText(str);\n        Debug.Log(\"剩余：\" + allCoin);\n    }\n}\n```\n~~~\n\n</details>\n\n\n\n   \n\n\n\n\n\n","source":"_posts/2021-07-26-小学期建造游戏Demo开发笔记（一）.md","raw":"---\ntitle: 2021-07-26-小学期建造游戏Demo开发笔记（一）\ndate: 2021-07-26 22:47:18\ntags:\n  - Action\n  - 数值管理\n  - ScriptObject\n  - UI跟随物体\n  - Unity\ncategories:\n  - 小学期建造游戏Demo开发笔记\n\n---\n\n# 学习资料\n\n* [Micael 的3DRPS游戏开发教程系列](https://space.bilibili.com/370283072/channel/seriesdetail?sid=211995)\n\n<!-- more -->\n\n# 开始学习\n\n## 代码结构设计\n\n## 在Grid上建造\n\n获取世界坐标，转化为网格的坐标，然后在对应的位置新建物体。\n\n\n\n## 游戏数值管理\n### 保存数值：ScriptableObject\n\n新建脚本，继承`ScriptableObject`类。\n另外需要在菜单中添加项，方便对每个数值新建一个SO。\n下面以不同建筑的数值管理为例，新建脚本`BuildingData_SO.cs`，用来保存数值。\n\n```c#\n[CreateAssetMenu(fileName=\"BuildingData\",menuName= \"ScriptableObjects/Building Status\")]\npublic class BuildingData_SO : ScriptableObject\n{\n    [Header(\"Building Info\")]\n    public int green;\n    public int coin;\n    public int costCoin;\n    public int updateTime;\n\n    [Header(\"Other Info\")]\n    public string intro;\n\n}\n```\n然后右键`ScriptableObjects/Building Status`，新建一个`ScriptableObjects`，然后修改名称和默认数值。如下图所示。\n\n![image-20210728005217041](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728005217041-16274047480671.png)_一个数值模板_\n\n### 读取和修改数值\n\n​\t上面的类只能保存数值而不能挂在物体上，需要新建一个类，继承`MonoBehavior`类，然后读取上面的Data，对于每个数值新建类，添加get和set函数。\n\n```c#\npublic class BuildingStatus : MonoBehaviour\n{\n    public BuildingData_SO buildingData;\n\n    #region Read from BuildingData_SO\n    public int BDGreen {\n        get\n        {\n            if (buildingData != null)\n            {\n                return buildingData.green;\n            }\n            else return 0;\n        }\n        set\n        {\n            buildingData.green = value;\n        }\n    }\n    #endregion\n}\n```\n\n### UI跟随物体定位\n\n> [教程](https://www.bilibili.com/video/BV1ew41197m1)\n\n#### Canvas设置\n\n新建Canvas，首先要设置Canvas的渲染模式。默认渲染模式是Overlay，需要改成WorldSpace。记得把主摄像机拖进来。\n\n然后重置canvas的位置。\n\n![image-20210728183939840](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728183939840-16274687829251.png)\n\n然后在Canvas中新建UI，调整坐标和缩放，放置于需要放置的物体上。然后把该UI拖到资源文件夹中变成Prefab，删去检视视图中的UI。\n\n对于每个建筑的Prefab，在里面新增一个空的子物体，标记每种建筑的UI 需要显示的位置。如下图所示。\n\n![image-20210728185002113](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS建造系统开发学习笔记（一）/image-20210728185002113-16274694030602.png)\n\n\n\n#### 设置UI位置和朝向相机\n\n<div class=\"warning\">\n\n> 注意下述语句需要在`LateUpdate()`中执行\n\n</div>\n\nUI位置使用`coinUI.position = coinPoint.position;`\n\n获取主摄像机的transform，朝向相机直接用语句`coinUI.forward = -cam.forward;`\n\n------\n\n\n\n#### 添加事件Action\n\n在`GameEvent.cs`中统一管理游戏事件。GameEvent是一个单例，也就是说只有一个GameEvent对象，所以用来管理UI的出现等等事件。\n\n对于每个对象本身的事件，则写在对象的脚本中。\n\n> Action 是对委托的一种封装，可以直接对Action进行+=和-=操作\n\n以一部分代码为例：使用`public event Action<String> onGameMessage`定义Action。\n\n```c#\npublic class GameEvents : MonoBehaviour\n{   \n    // 单例\n    public static GameEvents current;\n    \n    private void Awake()\n    {\n        current = this;\n    }\n    \n    // 广播游戏消息（UI显示）\n    public event Action<String> onGameMessage;\n    public void GameMessage(String message)\n    {\n        if (onGameMessage != null)\n        {\n            onGameMessage(message);\n        }    \n    }\n}\n```\n\n然后在其他脚本中可以进行**事件注册**：\n\n```c#\nprivate void Awake()\n    {\n        GameEvents.current.onCoinShow += ShowCoin;    // 事件注册\n     }\n//定义函数\nprivate void ShowCoin(int coin)\n    {\n        if (coin != null && coin>0)\n        {\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.SetText(\"+\"+coin);\n            timeLeft = visibleTime;\n        }\n        else\n        {\n            Destroy(coinUI.gameObject);\n        }\n    }\n```\n\n**调用事件**：\n\n`GameEvents.current.GameMessage()`\n\n\n\n#### 固定时间后消失\n\n当显示UI时初始化：`timeLeft = visibleTime;`\n\n在`LateUpdate()`中：\n\n```c#\nif (timeLeft <= 0)\n{\n    coinUI.gameObject.SetActive(false);\n}\nelse\n{\n    timeLeft -= Time.deltaTime;\n}\n```\n\n------\n\n\n\n#### 完整代码\n\n<details>\n  <summary>CoinUI.cs</summary>\n\n  ```c#\n   public class CoinUI : MonoBehaviour\n{\n    public GameObject coinPrefab;\n    public Transform coinPoint;\n    public float visibleTime;\n    public bool isVisible=true;\n\n    private TextMeshProUGUI _textMeshProUGUI;\n    private float timeLeft;\n\n    Transform coinUI;\n    Transform cam;\n    BuildingController currentController;\n\n    private void Start()\n    {\n        currentController = GetComponent<BuildingController>();\n        currentController.onCoinShow += ShowCoin;    // 事件注册\n        currentController.onCoinHide += HideCoin;    // 事件注册\n        coinPoint = transform.Find(\"CoinPoint\");\n    }\n\n    void OnEnable()\n    {\n        cam = Camera.main.transform;\n        foreach(Canvas canvas in FindObjectsOfType<Canvas>())\n        {\n            if(canvas.renderMode == RenderMode.WorldSpace)\n            {\n                coinUI = Instantiate(coinPrefab, canvas.transform).transform;\n                coinUI.gameObject.SetActive(false);\n                _textMeshProUGUI = coinUI.transform.Find(\"Text\").GetComponent<TextMeshProUGUI>();\n\n            }\n        }\n    }\n    private void ShowCoin(int coin)\n    {\n        Debug.Log(\"收入：\" + coin);\n        if (coin != null && coin>0)\n        {\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.text=\"+\"+coin;\n            timeLeft = visibleTime;\n        }\n        else\n        {\n            Destroy(coinUI.gameObject);\n        }\n    }\n    private void HideCoin()\n    {\n        coinUI.gameObject.SetActive(false);\n    }\n\n    void LateUpdate()\n    {\n        if (coinUI != null)\n        {\n            coinUI.position = coinPoint.position;\n            coinUI.forward = cam.forward;\n\n            if (!isVisible)\n            {\n                if (timeLeft <= 0)\n                {\n                    HideCoin();\n                }\n                else\n                {\n                    timeLeft -= Time.deltaTime;\n                }\n            }\n            \n        }\n    }\n\n}\n  ```\n\n</details>\n\n\n\n\n<details>\n  <summary>CoinCount.cs</summary>\n\n~~~c#\n```c#\n    public class CoinCount : MonoBehaviour\n{\n    private TextMeshProUGUI _textMeshProUGUI;\n\n    // Start is called before the first frame update\n    void Awake()\n    {\n        _textMeshProUGUI = transform.GetComponentsInChildren<TextMeshProUGUI>()[0];\n\n        // 添加事件响应\n        GameEvents.current.onCoinCountChange += ChangeCoinCount;\n    }\n\n    private void ChangeCoinCount(int coin)\n    {\n        \n        int allCoin = GameManager.getGM.Coin;\n        String str = String.Format(\"经济值：\"+allCoin);\n        _textMeshProUGUI.SetText(str);\n        Debug.Log(\"剩余：\" + allCoin);\n    }\n}\n```\n~~~\n\n</details>\n\n\n\n   \n\n\n\n\n\n","slug":"2021-07-26-小学期建造游戏Demo开发笔记（一）","published":1,"updated":"2021-08-29T09:24:22.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100ks00013svo3u9i8tmt","content":"<h1 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h1><ul>\n<li><a href=\"https://space.bilibili.com/370283072/channel/seriesdetail?sid=211995\">Micael 的3DRPS游戏开发教程系列</a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><h2 id=\"代码结构设计\"><a href=\"#代码结构设计\" class=\"headerlink\" title=\"代码结构设计\"></a>代码结构设计</h2><h2 id=\"在Grid上建造\"><a href=\"#在Grid上建造\" class=\"headerlink\" title=\"在Grid上建造\"></a>在Grid上建造</h2><p>获取世界坐标，转化为网格的坐标，然后在对应的位置新建物体。</p>\n<h2 id=\"游戏数值管理\"><a href=\"#游戏数值管理\" class=\"headerlink\" title=\"游戏数值管理\"></a>游戏数值管理</h2><h3 id=\"保存数值：ScriptableObject\"><a href=\"#保存数值：ScriptableObject\" class=\"headerlink\" title=\"保存数值：ScriptableObject\"></a>保存数值：ScriptableObject</h3><p>新建脚本，继承<code>ScriptableObject</code>类。<br>另外需要在菜单中添加项，方便对每个数值新建一个SO。<br>下面以不同建筑的数值管理为例，新建脚本<code>BuildingData_SO.cs</code>，用来保存数值。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[CreateAssetMenu(fileName&#x3D;&quot;BuildingData&quot;,menuName&#x3D; &quot;ScriptableObjects&#x2F;Building Status&quot;)]\npublic class BuildingData_SO : ScriptableObject\n&#123;\n    [Header(&quot;Building Info&quot;)]\n    public int green;\n    public int coin;\n    public int costCoin;\n    public int updateTime;\n\n    [Header(&quot;Other Info&quot;)]\n    public string intro;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后右键<code>ScriptableObjects/Building Status</code>，新建一个<code>ScriptableObjects</code>，然后修改名称和默认数值。如下图所示。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728005217041-16274047480671.png\" alt=\"image-20210728005217041\" loading=\"lazy\"><em>一个数值模板</em></p>\n<h3 id=\"读取和修改数值\"><a href=\"#读取和修改数值\" class=\"headerlink\" title=\"读取和修改数值\"></a>读取和修改数值</h3><p>​    上面的类只能保存数值而不能挂在物体上，需要新建一个类，继承<code>MonoBehavior</code>类，然后读取上面的Data，对于每个数值新建类，添加get和set函数。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class BuildingStatus : MonoBehaviour\n&#123;\n    public BuildingData_SO buildingData;\n\n    #region Read from BuildingData_SO\n    public int BDGreen &#123;\n        get\n        &#123;\n            if (buildingData !&#x3D; null)\n            &#123;\n                return buildingData.green;\n            &#125;\n            else return 0;\n        &#125;\n        set\n        &#123;\n            buildingData.green &#x3D; value;\n        &#125;\n    &#125;\n    #endregion\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"UI跟随物体定位\"><a href=\"#UI跟随物体定位\" class=\"headerlink\" title=\"UI跟随物体定位\"></a>UI跟随物体定位</h3><blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1ew41197m1\">教程</a></p>\n</blockquote>\n<h4 id=\"Canvas设置\"><a href=\"#Canvas设置\" class=\"headerlink\" title=\"Canvas设置\"></a>Canvas设置</h4><p>新建Canvas，首先要设置Canvas的渲染模式。默认渲染模式是Overlay，需要改成WorldSpace。记得把主摄像机拖进来。</p>\n<p>然后重置canvas的位置。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728183939840-16274687829251.png\" alt=\"image-20210728183939840\" loading=\"lazy\"></p>\n<p>然后在Canvas中新建UI，调整坐标和缩放，放置于需要放置的物体上。然后把该UI拖到资源文件夹中变成Prefab，删去检视视图中的UI。</p>\n<p>对于每个建筑的Prefab，在里面新增一个空的子物体，标记每种建筑的UI 需要显示的位置。如下图所示。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728185002113-16274694030602.png\" alt=\"image-20210728185002113\" loading=\"lazy\"></p>\n<h4 id=\"设置UI位置和朝向相机\"><a href=\"#设置UI位置和朝向相机\" class=\"headerlink\" title=\"设置UI位置和朝向相机\"></a>设置UI位置和朝向相机</h4><div class=\"warning\">\n\n<blockquote>\n<p>注意下述语句需要在<code>LateUpdate()</code>中执行</p>\n</blockquote>\n</div>\n\n<p>UI位置使用<code>coinUI.position = coinPoint.position;</code></p>\n<p>获取主摄像机的transform，朝向相机直接用语句<code>coinUI.forward = -cam.forward;</code></p>\n<hr>\n<h4 id=\"添加事件Action\"><a href=\"#添加事件Action\" class=\"headerlink\" title=\"添加事件Action\"></a>添加事件Action</h4><p>在<code>GameEvent.cs</code>中统一管理游戏事件。GameEvent是一个单例，也就是说只有一个GameEvent对象，所以用来管理UI的出现等等事件。</p>\n<p>对于每个对象本身的事件，则写在对象的脚本中。</p>\n<blockquote>\n<p>Action 是对委托的一种封装，可以直接对Action进行+=和-=操作</p>\n</blockquote>\n<p>以一部分代码为例：使用<code>public event Action&lt;String&gt; onGameMessage</code>定义Action。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class GameEvents : MonoBehaviour\n&#123;   \n    &#x2F;&#x2F; 单例\n    public static GameEvents current;\n    \n    private void Awake()\n    &#123;\n        current &#x3D; this;\n    &#125;\n    \n    &#x2F;&#x2F; 广播游戏消息（UI显示）\n    public event Action&lt;String&gt; onGameMessage;\n    public void GameMessage(String message)\n    &#123;\n        if (onGameMessage !&#x3D; null)\n        &#123;\n            onGameMessage(message);\n        &#125;    \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后在其他脚本中可以进行<strong>事件注册</strong>：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private void Awake()\n    &#123;\n        GameEvents.current.onCoinShow +&#x3D; ShowCoin;    &#x2F;&#x2F; 事件注册\n     &#125;\n&#x2F;&#x2F;定义函数\nprivate void ShowCoin(int coin)\n    &#123;\n        if (coin !&#x3D; null &amp;&amp; coin&gt;0)\n        &#123;\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.SetText(&quot;+&quot;+coin);\n            timeLeft &#x3D; visibleTime;\n        &#125;\n        else\n        &#123;\n            Destroy(coinUI.gameObject);\n        &#125;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>调用事件</strong>：</p>\n<p><code>GameEvents.current.GameMessage()</code></p>\n<h4 id=\"固定时间后消失\"><a href=\"#固定时间后消失\" class=\"headerlink\" title=\"固定时间后消失\"></a>固定时间后消失</h4><p>当显示UI时初始化：<code>timeLeft = visibleTime;</code></p>\n<p>在<code>LateUpdate()</code>中：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">if (timeLeft &lt;&#x3D; 0)\n&#123;\n    coinUI.gameObject.SetActive(false);\n&#125;\nelse\n&#123;\n    timeLeft -&#x3D; Time.deltaTime;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><details>\n  <summary>CoinUI.cs</summary>\n\n  <pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">   public class CoinUI : MonoBehaviour\n&#123;\n    public GameObject coinPrefab;\n    public Transform coinPoint;\n    public float visibleTime;\n    public bool isVisible&#x3D;true;\n\n    private TextMeshProUGUI _textMeshProUGUI;\n    private float timeLeft;\n\n    Transform coinUI;\n    Transform cam;\n    BuildingController currentController;\n\n    private void Start()\n    &#123;\n        currentController &#x3D; GetComponent&lt;BuildingController&gt;();\n        currentController.onCoinShow +&#x3D; ShowCoin;    &#x2F;&#x2F; 事件注册\n        currentController.onCoinHide +&#x3D; HideCoin;    &#x2F;&#x2F; 事件注册\n        coinPoint &#x3D; transform.Find(&quot;CoinPoint&quot;);\n    &#125;\n\n    void OnEnable()\n    &#123;\n        cam &#x3D; Camera.main.transform;\n        foreach(Canvas canvas in FindObjectsOfType&lt;Canvas&gt;())\n        &#123;\n            if(canvas.renderMode &#x3D;&#x3D; RenderMode.WorldSpace)\n            &#123;\n                coinUI &#x3D; Instantiate(coinPrefab, canvas.transform).transform;\n                coinUI.gameObject.SetActive(false);\n                _textMeshProUGUI &#x3D; coinUI.transform.Find(&quot;Text&quot;).GetComponent&lt;TextMeshProUGUI&gt;();\n\n            &#125;\n        &#125;\n    &#125;\n    private void ShowCoin(int coin)\n    &#123;\n        Debug.Log(&quot;收入：&quot; + coin);\n        if (coin !&#x3D; null &amp;&amp; coin&gt;0)\n        &#123;\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.text&#x3D;&quot;+&quot;+coin;\n            timeLeft &#x3D; visibleTime;\n        &#125;\n        else\n        &#123;\n            Destroy(coinUI.gameObject);\n        &#125;\n    &#125;\n    private void HideCoin()\n    &#123;\n        coinUI.gameObject.SetActive(false);\n    &#125;\n\n    void LateUpdate()\n    &#123;\n        if (coinUI !&#x3D; null)\n        &#123;\n            coinUI.position &#x3D; coinPoint.position;\n            coinUI.forward &#x3D; cam.forward;\n\n            if (!isVisible)\n            &#123;\n                if (timeLeft &lt;&#x3D; 0)\n                &#123;\n                    HideCoin();\n                &#125;\n                else\n                &#123;\n                    timeLeft -&#x3D; Time.deltaTime;\n                &#125;\n            &#125;\n            \n        &#125;\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n\n\n<details>\n  <summary>CoinCount.cs</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#96;&#96;&#96;c#\n    public class CoinCount : MonoBehaviour\n&#123;\n    private TextMeshProUGUI _textMeshProUGUI;\n\n    &#x2F;&#x2F; Start is called before the first frame update\n    void Awake()\n    &#123;\n        _textMeshProUGUI &#x3D; transform.GetComponentsInChildren&lt;TextMeshProUGUI&gt;()[0];\n\n        &#x2F;&#x2F; 添加事件响应\n        GameEvents.current.onCoinCountChange +&#x3D; ChangeCoinCount;\n    &#125;\n\n    private void ChangeCoinCount(int coin)\n    &#123;\n        \n        int allCoin &#x3D; GameManager.getGM.Coin;\n        String str &#x3D; String.Format(&quot;经济值：&quot;+allCoin);\n        _textMeshProUGUI.SetText(str);\n        Debug.Log(&quot;剩余：&quot; + allCoin);\n    &#125;\n&#125;\n&#96;&#96;&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n\n   \n\n\n\n\n\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h1><ul>\n<li><a href=\"https://space.bilibili.com/370283072/channel/seriesdetail?sid=211995\">Micael 的3DRPS游戏开发教程系列</a></li>\n</ul>","more":"<h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><h2 id=\"代码结构设计\"><a href=\"#代码结构设计\" class=\"headerlink\" title=\"代码结构设计\"></a>代码结构设计</h2><h2 id=\"在Grid上建造\"><a href=\"#在Grid上建造\" class=\"headerlink\" title=\"在Grid上建造\"></a>在Grid上建造</h2><p>获取世界坐标，转化为网格的坐标，然后在对应的位置新建物体。</p>\n<h2 id=\"游戏数值管理\"><a href=\"#游戏数值管理\" class=\"headerlink\" title=\"游戏数值管理\"></a>游戏数值管理</h2><h3 id=\"保存数值：ScriptableObject\"><a href=\"#保存数值：ScriptableObject\" class=\"headerlink\" title=\"保存数值：ScriptableObject\"></a>保存数值：ScriptableObject</h3><p>新建脚本，继承<code>ScriptableObject</code>类。<br>另外需要在菜单中添加项，方便对每个数值新建一个SO。<br>下面以不同建筑的数值管理为例，新建脚本<code>BuildingData_SO.cs</code>，用来保存数值。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[CreateAssetMenu(fileName&#x3D;&quot;BuildingData&quot;,menuName&#x3D; &quot;ScriptableObjects&#x2F;Building Status&quot;)]\npublic class BuildingData_SO : ScriptableObject\n&#123;\n    [Header(&quot;Building Info&quot;)]\n    public int green;\n    public int coin;\n    public int costCoin;\n    public int updateTime;\n\n    [Header(&quot;Other Info&quot;)]\n    public string intro;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后右键<code>ScriptableObjects/Building Status</code>，新建一个<code>ScriptableObjects</code>，然后修改名称和默认数值。如下图所示。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728005217041-16274047480671.png\" alt=\"image-20210728005217041\"><em>一个数值模板</em></p>\n<h3 id=\"读取和修改数值\"><a href=\"#读取和修改数值\" class=\"headerlink\" title=\"读取和修改数值\"></a>读取和修改数值</h3><p>​    上面的类只能保存数值而不能挂在物体上，需要新建一个类，继承<code>MonoBehavior</code>类，然后读取上面的Data，对于每个数值新建类，添加get和set函数。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class BuildingStatus : MonoBehaviour\n&#123;\n    public BuildingData_SO buildingData;\n\n    #region Read from BuildingData_SO\n    public int BDGreen &#123;\n        get\n        &#123;\n            if (buildingData !&#x3D; null)\n            &#123;\n                return buildingData.green;\n            &#125;\n            else return 0;\n        &#125;\n        set\n        &#123;\n            buildingData.green &#x3D; value;\n        &#125;\n    &#125;\n    #endregion\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"UI跟随物体定位\"><a href=\"#UI跟随物体定位\" class=\"headerlink\" title=\"UI跟随物体定位\"></a>UI跟随物体定位</h3><blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1ew41197m1\">教程</a></p>\n</blockquote>\n<h4 id=\"Canvas设置\"><a href=\"#Canvas设置\" class=\"headerlink\" title=\"Canvas设置\"></a>Canvas设置</h4><p>新建Canvas，首先要设置Canvas的渲染模式。默认渲染模式是Overlay，需要改成WorldSpace。记得把主摄像机拖进来。</p>\n<p>然后重置canvas的位置。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728183939840-16274687829251.png\" alt=\"image-20210728183939840\"></p>\n<p>然后在Canvas中新建UI，调整坐标和缩放，放置于需要放置的物体上。然后把该UI拖到资源文件夹中变成Prefab，删去检视视图中的UI。</p>\n<p>对于每个建筑的Prefab，在里面新增一个空的子物体，标记每种建筑的UI 需要显示的位置。如下图所示。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-07-26-RTS%E5%BB%BA%E9%80%A0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728185002113-16274694030602.png\" alt=\"image-20210728185002113\"></p>\n<h4 id=\"设置UI位置和朝向相机\"><a href=\"#设置UI位置和朝向相机\" class=\"headerlink\" title=\"设置UI位置和朝向相机\"></a>设置UI位置和朝向相机</h4><div class=\"warning\">\n\n<blockquote>\n<p>注意下述语句需要在<code>LateUpdate()</code>中执行</p>\n</blockquote>\n</div>\n\n<p>UI位置使用<code>coinUI.position = coinPoint.position;</code></p>\n<p>获取主摄像机的transform，朝向相机直接用语句<code>coinUI.forward = -cam.forward;</code></p>\n<hr>\n<h4 id=\"添加事件Action\"><a href=\"#添加事件Action\" class=\"headerlink\" title=\"添加事件Action\"></a>添加事件Action</h4><p>在<code>GameEvent.cs</code>中统一管理游戏事件。GameEvent是一个单例，也就是说只有一个GameEvent对象，所以用来管理UI的出现等等事件。</p>\n<p>对于每个对象本身的事件，则写在对象的脚本中。</p>\n<blockquote>\n<p>Action 是对委托的一种封装，可以直接对Action进行+=和-=操作</p>\n</blockquote>\n<p>以一部分代码为例：使用<code>public event Action&lt;String&gt; onGameMessage</code>定义Action。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class GameEvents : MonoBehaviour\n&#123;   \n    &#x2F;&#x2F; 单例\n    public static GameEvents current;\n    \n    private void Awake()\n    &#123;\n        current &#x3D; this;\n    &#125;\n    \n    &#x2F;&#x2F; 广播游戏消息（UI显示）\n    public event Action&lt;String&gt; onGameMessage;\n    public void GameMessage(String message)\n    &#123;\n        if (onGameMessage !&#x3D; null)\n        &#123;\n            onGameMessage(message);\n        &#125;    \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后在其他脚本中可以进行<strong>事件注册</strong>：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private void Awake()\n    &#123;\n        GameEvents.current.onCoinShow +&#x3D; ShowCoin;    &#x2F;&#x2F; 事件注册\n     &#125;\n&#x2F;&#x2F;定义函数\nprivate void ShowCoin(int coin)\n    &#123;\n        if (coin !&#x3D; null &amp;&amp; coin&gt;0)\n        &#123;\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.SetText(&quot;+&quot;+coin);\n            timeLeft &#x3D; visibleTime;\n        &#125;\n        else\n        &#123;\n            Destroy(coinUI.gameObject);\n        &#125;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>调用事件</strong>：</p>\n<p><code>GameEvents.current.GameMessage()</code></p>\n<h4 id=\"固定时间后消失\"><a href=\"#固定时间后消失\" class=\"headerlink\" title=\"固定时间后消失\"></a>固定时间后消失</h4><p>当显示UI时初始化：<code>timeLeft = visibleTime;</code></p>\n<p>在<code>LateUpdate()</code>中：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">if (timeLeft &lt;&#x3D; 0)\n&#123;\n    coinUI.gameObject.SetActive(false);\n&#125;\nelse\n&#123;\n    timeLeft -&#x3D; Time.deltaTime;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><details>\n  <summary>CoinUI.cs</summary>\n\n  <pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">   public class CoinUI : MonoBehaviour\n&#123;\n    public GameObject coinPrefab;\n    public Transform coinPoint;\n    public float visibleTime;\n    public bool isVisible&#x3D;true;\n\n    private TextMeshProUGUI _textMeshProUGUI;\n    private float timeLeft;\n\n    Transform coinUI;\n    Transform cam;\n    BuildingController currentController;\n\n    private void Start()\n    &#123;\n        currentController &#x3D; GetComponent&lt;BuildingController&gt;();\n        currentController.onCoinShow +&#x3D; ShowCoin;    &#x2F;&#x2F; 事件注册\n        currentController.onCoinHide +&#x3D; HideCoin;    &#x2F;&#x2F; 事件注册\n        coinPoint &#x3D; transform.Find(&quot;CoinPoint&quot;);\n    &#125;\n\n    void OnEnable()\n    &#123;\n        cam &#x3D; Camera.main.transform;\n        foreach(Canvas canvas in FindObjectsOfType&lt;Canvas&gt;())\n        &#123;\n            if(canvas.renderMode &#x3D;&#x3D; RenderMode.WorldSpace)\n            &#123;\n                coinUI &#x3D; Instantiate(coinPrefab, canvas.transform).transform;\n                coinUI.gameObject.SetActive(false);\n                _textMeshProUGUI &#x3D; coinUI.transform.Find(&quot;Text&quot;).GetComponent&lt;TextMeshProUGUI&gt;();\n\n            &#125;\n        &#125;\n    &#125;\n    private void ShowCoin(int coin)\n    &#123;\n        Debug.Log(&quot;收入：&quot; + coin);\n        if (coin !&#x3D; null &amp;&amp; coin&gt;0)\n        &#123;\n            coinUI.gameObject.SetActive(true);\n            _textMeshProUGUI.text&#x3D;&quot;+&quot;+coin;\n            timeLeft &#x3D; visibleTime;\n        &#125;\n        else\n        &#123;\n            Destroy(coinUI.gameObject);\n        &#125;\n    &#125;\n    private void HideCoin()\n    &#123;\n        coinUI.gameObject.SetActive(false);\n    &#125;\n\n    void LateUpdate()\n    &#123;\n        if (coinUI !&#x3D; null)\n        &#123;\n            coinUI.position &#x3D; coinPoint.position;\n            coinUI.forward &#x3D; cam.forward;\n\n            if (!isVisible)\n            &#123;\n                if (timeLeft &lt;&#x3D; 0)\n                &#123;\n                    HideCoin();\n                &#125;\n                else\n                &#123;\n                    timeLeft -&#x3D; Time.deltaTime;\n                &#125;\n            &#125;\n            \n        &#125;\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n\n\n<details>\n  <summary>CoinCount.cs</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#96;&#96;&#96;c#\n    public class CoinCount : MonoBehaviour\n&#123;\n    private TextMeshProUGUI _textMeshProUGUI;\n\n    &#x2F;&#x2F; Start is called before the first frame update\n    void Awake()\n    &#123;\n        _textMeshProUGUI &#x3D; transform.GetComponentsInChildren&lt;TextMeshProUGUI&gt;()[0];\n\n        &#x2F;&#x2F; 添加事件响应\n        GameEvents.current.onCoinCountChange +&#x3D; ChangeCoinCount;\n    &#125;\n\n    private void ChangeCoinCount(int coin)\n    &#123;\n        \n        int allCoin &#x3D; GameManager.getGM.Coin;\n        String str &#x3D; String.Format(&quot;经济值：&quot;+allCoin);\n        _textMeshProUGUI.SetText(str);\n        Debug.Log(&quot;剩余：&quot; + allCoin);\n    &#125;\n&#125;\n&#96;&#96;&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>"},{"title":"2021-07-26-总结","date":"2021-07-26T16:41:47.000Z","password":130024,"_content":"\n### 总结\n\n  今天算是这周以来最有进度的一天，没怎么睡觉把网站搭了出来，也算是一个比较艰难的开头。这两天生活可以说是一团糟，创建这个博客某种意义上说也是希望自己的生活能重新走上正轨。关于感情问题，自己也要想想清楚。\n\n  另外虽然游戏开发这边没什么进展，但是大致看了一下原本的逻辑结构。明天需要确定整体代码框架，然后把碳指标和经济消耗的部分加入进去。另外游戏时间管理不知道要不要另外写，还是要再看看教程。\n\n### 展望\n\n- [ ] 生贺图线稿\n- [ ] 做完数值消耗这些东西\n\n  还剩七天，生日贺图最好能在3天内画完一张，想画大天使和phenomenon。明天画一半线稿。预计时长8h。\n\n明天试着把碳消耗那些功能实现一下。预计时长8h。\n\n***\n","source":"_posts/2021-07-26-日记.md","raw":"---\ntitle: 2021-07-26-总结\ndate: 2021-07-27 00:41:47\npassword: 130024\ntags:\ncategories:\n  - 日记\n---\n\n### 总结\n\n  今天算是这周以来最有进度的一天，没怎么睡觉把网站搭了出来，也算是一个比较艰难的开头。这两天生活可以说是一团糟，创建这个博客某种意义上说也是希望自己的生活能重新走上正轨。关于感情问题，自己也要想想清楚。\n\n  另外虽然游戏开发这边没什么进展，但是大致看了一下原本的逻辑结构。明天需要确定整体代码框架，然后把碳指标和经济消耗的部分加入进去。另外游戏时间管理不知道要不要另外写，还是要再看看教程。\n\n### 展望\n\n- [ ] 生贺图线稿\n- [ ] 做完数值消耗这些东西\n\n  还剩七天，生日贺图最好能在3天内画完一张，想画大天使和phenomenon。明天画一半线稿。预计时长8h。\n\n明天试着把碳消耗那些功能实现一下。预计时长8h。\n\n***\n","slug":"2021-07-26-日记","published":1,"updated":"2021-08-29T08:54:16.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100kv00033svo6bp36w0q","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"e0ebbeabd3f586f93ff025b33998258fcfbb580ba310cfb43e6bd876c13f3dad\">3e465fd97ca21e2c34553ed0afce514f2838e22180dcd32b584036fa5c2fd7c66b2693a1f9e0b05766f1eac2e28d61e4b30889ab3f85f015a91f55342c6007b94e695a948a20142df35762c549ca337290a9b202e8e1b72b511d8f455ae4d7033c05eb313ee19fded266e4d812e30a7899cc8a6b3abf49ab194d30e186face81b90445144b45b7f41b0012f90a29b8f375531232852ea6511aef2a71b6b4a2b90ee91c9ad7afe422f8744706c25e93beefff33aaf4d54e46e98f16a85d8c666dbf29abab38c6f78076a8c3f53b34d50a52dd8b2e4bd4ce949267252b243154990840c634410586099ae7d360581acbd4036a6fd7a9c6a858f965992f15c9077415c79f587f390e0ce078c7f916af64414612384a765abd3a283fd26769f6ae720778e04644670ed29e4d111a2a3aa1e0c02c02130e502e18a5a69a383cdfde0e02db3245ffbcf97062d70f6c5e6ce2fe473341e6d433067ff054ced0be5d099759b5699503ff817839b358449fdd3e8cca5cf3ab8da5d87103e9dcecc34ba72d6e6621a32d9bb5899774927d300beee8ac2767c3afcd3a493f8dec4c681a4cd871de07fbe422e0f6381e0ee5b2f3a7b24a588047132bb4cf8d6f25162d87f38a97d1393d24800e6f4c73e5116084f1e4dcf4b5cd958cf0d6db5dc87820bc4281dba606d1b5c58335f40b3c0a3da980249ff916650853c13bec8afeb651bdc679d58f9278ea54484a4d0c54b2d022ac3e4002e88c86b8df427995f54110374337287d2d1577e9d12a5a238da63eef8e1689e019a31de6ae1dac70174ac2dc0e636ae1425fdb6ba3ae42cc088688d119b0e73af1e0092a934d5fcbb56c59baac3967d6c82e867e89714b7fc4b55786cb094a0c55911f0518bb456a9ae4ff27fade6b60ba301e4039bb8cc152c4c99167bd8c4df0a4468a15c75e3b723574b13e0e46d433f4c5e56929d95ee3003599e2ea54a6e361495a859922703bd2be3420c3945f0ad6263a618f9f2149eafcd5a7060e3f201eddc4df34f91453be68c05bedb8bf47b2885e37c8cbc25df79f86a08326608b5eeccaaad751b5d6cd4d9a4c3ff59404a96a5dab1712912ce13326bfc03606da124e83f8ba86a350a11fb22a44a4054a1d46e4036e7478ca75701e22a0269eeb9674b50a577f2bf6bf76792475fc9f6165b481c07c8a596465c5ba31b390ba17a73ac58c8beffabde29a6d807c8506553a9be9c8a4e7bf523e20bd0dd3da20f51060c97d7efb91974a617f66544b1ea004016d07a267fe385b6ed08f73755f8643b78e55f741ed47bb20fa91af2900173508e8a1509eecb6ed15cd04d506178d1bfd9d3dc87c831602b0b8d68b69acaca957e9eeedad350d2c98ca16daa9f72207e0de42efeef423399a1a9bd2737fc3d4973bec703f5f5f299a0ba828b10f3fb99781b33dbb4a26d0b56f50a7afd0fb1976d1f8462b99abb1852d1474802e651ac7888b0b544306cfd16af1423564dbe18e230d8258169a871e3699dcefd0dd51260da14d6899cc43b2a79c6b61383a68ff3bad2dd869458471fcc572f76c1de9f508cebcce744d8b9bb32848506caae0a90cc957e4ce1cc4e08052a4d82ae4d750b19a1b99e8ce1bad8cf6b0cc50861492b607087f42b80f9ce82519be9360f188c2d2952a8f6454f9813d3c</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Hey, password is required here.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>  今天算是这周以来最有进度的一天，没怎么睡觉把网站搭了出来，也算是一个比较艰难的开头。这两天生活可以说是一团糟，创建这个博客某种意义上说也是希望自己的生活能重新走上正轨。关于感情问题，自己也要想想清楚。</p>\n<p>  另外虽然游戏开发这边没什么进展，但是大致看了一下原本的逻辑结构。明天需要确定整体代码框架，然后把碳指标和经济消耗的部分加入进去。另外游戏时间管理不知道要不要另外写，还是要再看看教程。</p>\n<h3 id=\"展望\"><a href=\"#展望\" class=\"headerlink\" title=\"展望\"></a>展望</h3><ul>\n<li><p><input disabled=\"\" type=\"checkbox\">  生贺图线稿</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  做完数值消耗这些东西</p>\n<p>还剩七天，生日贺图最好能在3天内画完一张，想画大天使和phenomenon。明天画一半线稿。预计时长8h。</p>\n</li>\n</ul>\n<p>明天试着把碳消耗那些功能实现一下。预计时长8h。</p>\n<hr>\n","encrypt":true},{"title":"2021-07-26-第一篇博客","date":"2021-07-25T23:09:04.000Z","password":130024,"created_at":true,"aplayer":true,"_content":"\n> 今天试着用hexo建立了自己的第一个静态博客，想试着写一写技术文档。\n\n{% meting \"16435050\" \"netease\" \"song\" \"theme:#C20C0C\" %}\n\n<!-- more -->\n\n## 博客创建\n\n[Hexo文档](https://hexo.io/zh-cn/docs)\n\n[模板使用](https://yun.yunyoujun.cn/guide/#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B)\n\n[新手操作 含命令](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n\n[代码高亮](https://www.awesomes.cn/repo/PrismJS/prism)\n\n[对博客加密](https://zhuanlan.zhihu.com/p/113235573)\n\n## MarkDown语法\n\n[MarkDown库](https://github.com/younghz/Markdown)\n\n[MarkDown菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n\n[样式扩展](https://www.yunyoujun.cn/yun/markdown.html)\n\n\n## 部分命令\n<div class=\"success\">\n\n> 运行\n\n</div>\n\n\n``` bash\n$ npx hexo server\n```\n\n生成静态文件\n``` bash\n$ npx hexo g\n$ npx hexo clean\n```\n部署\n``` bash\n$ npx hexo deploy\n```\n{% img https://z3.ax1x.com/2021/07/26/Wf9fjH.jpg %}\n\n\n\n每次更新：\n\n```bash\n$ sh update.sh\n```\n\n\n\n图片链接前缀：\n\nhttps://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images\n","source":"_posts/2021-07-26-第一篇博客.md","raw":"---\ntitle: 2021-07-26-第一篇博客\ndate: 2021-07-26 07:09:04\npassword: 130024\ncreated_at: true\naplayer: true\ntags:\n  - hexo\ncategories:\n  - 比较杂的知识点\n---\n\n> 今天试着用hexo建立了自己的第一个静态博客，想试着写一写技术文档。\n\n{% meting \"16435050\" \"netease\" \"song\" \"theme:#C20C0C\" %}\n\n<!-- more -->\n\n## 博客创建\n\n[Hexo文档](https://hexo.io/zh-cn/docs)\n\n[模板使用](https://yun.yunyoujun.cn/guide/#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B)\n\n[新手操作 含命令](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n\n[代码高亮](https://www.awesomes.cn/repo/PrismJS/prism)\n\n[对博客加密](https://zhuanlan.zhihu.com/p/113235573)\n\n## MarkDown语法\n\n[MarkDown库](https://github.com/younghz/Markdown)\n\n[MarkDown菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n\n[样式扩展](https://www.yunyoujun.cn/yun/markdown.html)\n\n\n## 部分命令\n<div class=\"success\">\n\n> 运行\n\n</div>\n\n\n``` bash\n$ npx hexo server\n```\n\n生成静态文件\n``` bash\n$ npx hexo g\n$ npx hexo clean\n```\n部署\n``` bash\n$ npx hexo deploy\n```\n{% img https://z3.ax1x.com/2021/07/26/Wf9fjH.jpg %}\n\n\n\n每次更新：\n\n```bash\n$ sh update.sh\n```\n\n\n\n图片链接前缀：\n\nhttps://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images\n","slug":"2021-07-26-第一篇博客","published":1,"updated":"2021-08-29T08:54:25.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100kz00073svo5jba9ljr","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"0674dd71e5e310f40cee05d819a76c96c80e0a30d1537745640b10eba44bfaa5\">3e465fd97ca21e2c34553ed0afce514f612679d2632e7a872d2f2ceefb90cd2f1e0d0a865af1c96ce79a7b1aa2653f8522f3c1bc23082ff4e7a2e2f128daae75be30d5db5052dd809aecf166154a8956331821439b40efcfd3e56e404288825101380467bb52e25952f674d082733d0947b7c7e8aa62e948256a35dae29ee80ac9fd5daa446a5b32b3d8413231e8575e6dcf4e1218f17a1cd29179666584cbfc831185b260c48c690539a32c2f30a8e565b35dff6ebc9e3b3c8f32c87a4b19b53b988ef1ab4af5990f8fcb9ed116d6adf7d3e84c7a604a7e57a11422918597c9e00158d9fd3b807c6f41eb9638091cf0d16892fa37a3346fbb0f38cfc46bf4d6b0b867ba669481c33308c9a5d51fd22b0d425cc9db9b35f9f3fcfead98ab1efbac7ab056ac99ff3d1c3d1bea4b006fe0bfef7c25f64544af3aa6182dc82977027ecfa24a03191ed8d4ac2525095998dc779156361e3ca5fd7c1b81261edeec039b20dc3c3349d758ed60ef8f19b89151cf04873e6f918288919875ad60a7f5f8df9c6437fbc99ef9b8393c5705f0a839c14c007244cd2af05a61bdcf98bfaaf8164c1d24a2bf0800730abe6ec2ea5af976c6bf3cd8947ad57f3a74de546a168cdc26966a988e0323ce8f5940e3c4492e171001452a65e08c9a7fd949d3e7e697293fcc9d3c60e8107d2f10d4dee30e2b123f869da8a794282d0a2af4d1bb8a734494ca7922c0fe330895fe93c6e681e92fcb57dc60873c5bfd4c2a286034b5b83dfc1396fdc0579889d80cf079172d108c9fbb33b82effe5b00c815f54888756f636bb0b92cf7f0ea0656be9d7ffb7e3c30b9f9a86e1b55dab8ef529ce447695fd5863c7c54abcf1e770028cfbbad24407b24db467c4c635ad48212e5bcef4e766a7253adae96241b3330d56d2aac462e4915ab21bed6d4f8e3fd5b2214f9dc3e9237c954724138c193e638ace417d0f5d60d1e8f1c9c6aad7c7deb334c578d43095b34094a35292882ea1dd5042888acc2d149a27d86e0e85422fb36cff404a09173dac682c3075f19f0b858e68eb7ea830491a9aefa3d2471886520794c1100f87ec5dae8b1271c3c42c50f792d3189571f7c2c41d4aafe1823c7b8f9fd514dfeafa739b2e9ad61d074b95a3857a18f82830d8c96f7ae193a45bdc24cc74bdfb40cd24502bb6bd931b90567618d0e81b6fb550139bf80164f71d263e22d0d2b7252fe569e855f53384389121094106aac5b101e1def20469a740fc650cee85ca4a81c6bc2d6361d174f50a320dbcf3d30d491897ebeedadc4e37874425bca69521922a50871167bec503204089a8aa12d5584d62484db2c1b6c25dfb017b8ccba032823e61fb67697890ea795c02edfa746039fc499208243e22c025a8222dfaedbf45c67a5a53eeaa649fdad12ea9772836f4de538ba8352e0f367e6bff4d4149b56f3271691ea2ab612b0cea1fdba5f07f4527d690fc88dc3c5def87c37c9359cc791c4c47198ab8600327ce314c5f29cafc90e878d32307b65fb4d08c54b0fc5f056693f2725d1f40c5ae2a100b26950b5e5fd2df6f32555bceffdee7452b23914f596a5473eecca3144b8cd94ee9e971dc8553e1ce8fc41645f47d175746e9ed5c6d1344e991aec62eb0f41794994a0eb1ba86691549813e6d14fd33ef97b034789792d72165cc959fc658c949be1d34bd8fee94f6dd1f00e9cad070ef1b5f223462fb188ec05029e352fed30e4730e3d7fae91bfc7cf729d98666b10efc0d6efebc99939368551aaf8c3c51dc5971ce03f6043411e2c3e3d5d936b9705dc90720904fd2edc49d0f9c82c33928efbdada804e4a5ab31209230ce308c331603fc28b7f8a9c4ad86da97945dabefbab0b3c04080313023742efbea22915f44d774555a1189a0ce051650821a6257378ac039572d3ae63dcc873ee4425c39ef2dd4ba3df720202edb626f1997308d45aee8834c8500b4c7a8c1ccca0df2a49975ef01ad571be80fa957878ac7af763e0d1b9c834f04a48605ef1b0087745523a37403bb990c3d2defdc581341863645ba6a8c3ac3bd8a9b96d99bb8f96a6d36c86980e60f8501e3bb662207ef2a7fa5f37ee6561b1abc9edbce24be699c8207ecd63198453f1156591d7d90a6c0c2b75631d2e28f1c644e30498692fdc1c1b2e7623d0b5d1157c27aeed1451991ebf1e9863f7b178b3fb8f6e9359e883b8a589d1c86242c45f4ebfc7631aa050b0662d2c2ff5fb99510621ba20de08c9e46c4d4d5250558e3d86cd9d18b9344e48e279e276ed7e336cdd46364b6ca7a3ee886c82dee5e5e93707b40597e5b9efa49a2b51a57ad239388b1f8dc44b46b3ac19a2e662fba21b16d2f4f9331676fa784826fae2df66abde79e2f675bd42bc480c408309a7f457a77da1917c4c01be1274816296dd334c48a00e7f334f47b9204cad679b7ac4c85195b17650c5eae6171c489232eb37870611aedb5deccc5ac966bc05dd4596edc0c1ea6956d17cddf39da01253efb4d4ce05fbf8cd75250275b0d90c87c5b314842f9d2a87d5578e9f3fa08eeae574b75d229ee0a712b8ab04b1a75fcdb99d2f3721e3069d3849339e68886df1fd11de91cbbc8de637e7f1b2b07f7edccc3ca5ebfb01ba0f3445852a84f483c51248c9cf010cf6f24b79eb21df39362e0c08ddf628a07be7e64e1b05f790522ae446cd79d339c001c12c5a8696f67bcd41ff88d04fcc5d91981d0ebf3536fabd735d2740823f797437a385902eaf3902b291f3618a5755c3e2b42a67b2e5bf1c8157eaa119a80b9aa3894cb71c89207d60db38888b1cd14dfa6c49e1db577762d24307aed0a8c74660d688c1c05daeff1b71ffcd303588aca7df63c93ff7a0a189659ab3cb024a0a6c49d3c8b3ed6c80cb95e937d6d004bdcf9874d0f5d39458113c823a3199768646c596b58327070e83c9c3bff09d56ebee754b536cb5da9823f003fe82edc21d0f3d84bb3e1caa0e9bed30881b8264b819e86ff72e49330a9f5f7c9773912c676b9923f0e648760c3533e014718ae2e2d6bfe11255596f8ea60b394798f0aa112f0c3e9e1ea63d6be7151e3be0d1157e6fde042e5d527f518fe35b08ad1067795d0865bd6511b024751f944b4bf5648392eddc632dfc5f3821c3f511dd132dbd5c7ab2e0eea32a90d9921d38a524b89bb94fa6f3116a43c6ecc6ca826513ee8580ab4fee7d3a3ee052e423b1c8965f0cbd1b4caeb083705d8cc09ef769d2e83e25c170a63886b32a121b68f99a9bfeeb00b4f3228fa5b7d7b0d69a292ec58b4cc45ddcb1e50c5164244f0768e3c3c958926b17587a3fa8c73a53ba9a99af0d87fd5780469bc401848da7713b9e96f96a374fe7af3591de3e434d7707888ac2fe6d880dce6b51d7b574acb12ae970a9eb5e64750c456358d2e09b78ba601da33de15e81b1beb609cbbe49f73ef7075c980d76a55c80b724c828add6bf5cdf7980a6a3fab342f5e58ba6a10cc6b105bb7d4e0cc0a2f82ed6119043301d875430a1fe199b34c11c52867ebe1537a2368aaec1aa3a8b0b7c12eee9018f47980020c061ee98e1a37205fefe1eb7e970ad3a084118ecbf7a70aafc38ef3f4e0b8a43e3e2c730f17ea5b0fad0e5a71c8df5120e3efc6fa2c80883c83dad7ff1451478d73ca47c4f69297566962eede0d69d293e76c34f93186417cde2695acfbdd5925efec37654d8aefdd50dac26206ee8567feebebe2f3473ee0d872e86fd18030ed8ba4ac5fffc7342f64d71cc894b337e444ef04ed7a</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Hey, password is required here.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<blockquote>\n<p>今天试着用hexo建立了自己的第一个静态博客，想试着写一写技术文档。</p>\n</blockquote>\n\n    <div id=\"aplayer-lXcBNOtc\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"16435050\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#C20C0C\"\n    ></div>\n\n<span id=\"more\"></span>\n\n<h2 id=\"博客创建\"><a href=\"#博客创建\" class=\"headerlink\" title=\"博客创建\"></a>博客创建</h2><p><a href=\"https://hexo.io/zh-cn/docs\">Hexo文档</a></p>\n<p><a href=\"https://yun.yunyoujun.cn/guide/#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\">模板使用</a></p>\n<p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">新手操作 含命令</a></p>\n<p><a href=\"https://www.awesomes.cn/repo/PrismJS/prism\">代码高亮</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/113235573\">对博客加密</a></p>\n<h2 id=\"MarkDown语法\"><a href=\"#MarkDown语法\" class=\"headerlink\" title=\"MarkDown语法\"></a>MarkDown语法</h2><p><a href=\"https://github.com/younghz/Markdown\">MarkDown库</a></p>\n<p><a href=\"https://www.runoob.com/markdown/md-tutorial.html\">MarkDown菜鸟教程</a></p>\n<p><a href=\"https://www.yunyoujun.cn/yun/markdown.html\">样式扩展</a></p>\n<h2 id=\"部分命令\"><a href=\"#部分命令\" class=\"headerlink\" title=\"部分命令\"></a>部分命令</h2><div class=\"success\">\n\n<blockquote>\n<p>运行</p>\n</blockquote>\n</div>\n\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ npx hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>生成静态文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ npx hexo g\n$ npx hexo clean<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>部署</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ npx hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<img src=\"https://z3.ax1x.com/2021/07/26/Wf9fjH.jpg\" class=\"\" loading=\"lazy\">\n\n\n\n<p>每次更新：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sh</span> update.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p>图片链接前缀：</p>\n<p><a href=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images\">https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images</a></p>\n","encrypt":true},{"title":"2021-08-06-小学期建造游戏Demo开发笔记（二）","date":"2021-08-06T12:51:37.000Z","_content":"\n# 重载当前的Scene\n\n```c#\nusing UnityEngine.SceneManagement;\n\npublic void restart()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    }\n```\n\n退出游戏：\n\n```c#\npublic void EndGame()\n    {\n        Application.Quit();\n    }\n```\n\n \n\n<!-- more -->\n\n# Game Manager\n\n>  由于“游戏管理器”控制的都是整个游戏中一些共有的信息，所以我们不会同时需要两个游戏管理器，因此游戏管理器将是一个单例对象。\n\n单例模式：\n\n创建一个静态对象`static GameManager current`\n\n直接在Awake里定义gm为this：\n\n```c#\nprivate void Awake()\n    {\n        current = this;\n    }\n```\n\n然后直接用`GameManager.current`即可调用里面的变量和函数。\n\n\n\n# UI\n\n#### 新建UI\n\n<div class=\"warning\">\n\n> 注意需要修改Canvas的设置，否则调整比例后位置可能会错乱。默认是constant with pixel size\n\n</div>\n\n![image-20210808163903666](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808163903666-16284119455091.png)\n\n\n\n![image-20210808174522165](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808174522165-16284159238313.png)_设置界面UI_\n\n<div class=\"warning\">\n\n> 注意当给GUI控件挂事件回调函数时，要选择上面Dynamic String的，不能选择下面静态变量。\n\n</div>\n\n#### 想要让Panel暂时隐藏或显示？\n\n注意不能漏任何组件，否则可能无法交互。\n\n![image-20210808164106909](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808164106909-16284120682902.png)\n\n以TipUI为例：\n\n获取`CanvasGroup`组件，设置它的透明度、可交互、可被射线撞击等等属性。\n\n```c#\npublic class TipUI : MonoBehaviour\n{\n    private CanvasGroup _canvasGroup;\n    private Node _currentNode;\n    public Text tipText;\n    // Start is called before the first frame update\n    void Start()\n    {\n        _canvasGroup = gameObject.GetComponent<CanvasGroup>();//获得组件\n        GameEvents.current.onOpenTipGUI += OpenTip;\n    }\n    //显示\n    private void OpenTip(int cost,Node node)\n    {\n        _canvasGroup.alpha = 1;\n        _canvasGroup.interactable = true;\n        _canvasGroup.blocksRaycasts = true;\n\n        tipText.text = \"开发该地块需要\"+cost+\"经济值，是否开发？\";\n        _currentNode = node;\n    }\n\n    public void UnlockNode()\n    {\n        Debug.Log(\"是\");\n        _currentNode.Unlock();\n        HideTip();\n    }\n    //隐藏\n    public void HideTip()\n    {\n        _canvasGroup.alpha = 0;\n        _canvasGroup.interactable = false;\n        _canvasGroup.blocksRaycasts = false;\n    }\n}\n```\n\n然后只要调用函数`GameEvents.current.OpenTipGUI()`即可控制显示。\n\n\n\n\n\n# 状态切换\n\n使用`BuildingController.cs`来管理建筑的状态。\n\n先定义枚举状态：`public enum BuildingStates { WORKING,WAITING,DEAD }`\n\n然后在Start时初始化一个`BuildingStates`: `buildingStates = BuildingStates.WORKING;`\n\n在Update()函数中调用`SwitchStates()`:\n\n```c#\npublic void SwitchStates()\n    {\n        switch (buildingStates)\n        {\n            case BuildingStates.WORKING:\n                //时间到了\n                if (timeLeft <= 0)\n                {\n                    CoinShow(bs.BDCoin);\n                    buildingStates = BuildingStates.WAITING;\n                }\n                else\n                {\n                    timeLeft -= Time.deltaTime;\n                }\n                break;\n            case BuildingStates.WAITING:\n                \n                break;\n            case BuildingStates.DEAD:\n                //特殊土地，已经不能再使用，需要手动拆除。\n                Renderer renderer = GetComponent<Renderer>();\n                renderer.material.SetColor(\"_Color\", Color.red);\n                currentNode.canSpecial = false;\n                break;\n            default:\n                break;\n        }\n\n\n        if (greenTimeLeft <= 0)\n        {\n            //GreenAdd(bs.BDGreen);\n            GameManager.getGM.Green += bs.BDGreen;\n            greenTimeLeft = updateTime;\n        }\n        else\n        {\n            greenTimeLeft -= Time.deltaTime;\n        }\n    }\n```\n\n## 特殊建筑\n\n对于有使用轮次限制的特殊建筑，定义子类`SpecialLandController` 继承`BuildingController`，对ToWorking函数重写。使用变量count来记录工作的轮次。\n\n> 注意只有被public和protected修饰的父类变量能被子类使用，所以要记得修改父类变量或函数的作用范围。\n\n```c#\npublic class SpecialLandController : BuildingController\n{\n    [SerializeField]\n    private int count = 0;\n\n    public int times = 10;\n\n    protected new void Start()\n    {\n        this.onToWorking += ToWorking;    // 事件注册\n        init();\n    }\n\n    public new void ToWorking()\n    {\n        Debug.Log(\"子\");\n        timeLeft = updateTime;\n        bs.GetCoin();\n        count++;\n\n        if (count >= times)\n        {\n            buildingStates = BuildingStates.DEAD;\n        }\n        else\n        {\n            buildingStates = BuildingStates.WORKING;\n        }\n        \n        \n    }\n}\n```\n\n\n\n# 鼠标滚轮缩放Camera视图\n\n## 小窗口显示整体地图\n\n复制一个Camera，然后修改TargetTexture 为一个新建的RenderTexture，然后在GUI中新建RawImage，把Texture设置为摄像机输出的RenderTexture即可。\n\n## 滚轮缩放\n\n在Update函数中：  `Mathf.Clamp()`函数用于固定在最大和最小值范围内。\n\n-=是鼠标滚轮上划视图放大，下滑缩小；+=反之。\n\n```c#\n//获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\ncurrentScale -= Input.GetAxis(\"Mouse ScrollWheel\") * scaleSpeed;\ncurrentScale = Mathf.Clamp(currentScale, minScale, maxScale);\n```\n\n\n\n<details>\n  <summary>FollowMouseScale.cs</summary>\n\n\n```c#\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class FollowMouseScale : MonoBehaviour\n{\n    public GameObject mapPanel;\n    public float scaleSpeed = 5.0f;\n    private float minScale = 1.0f;\n    private float maxScale = 150.0f;\n    private float currentScale;\n    private float defaultScale;\n\n    // Use this for initialization\n\n    void Start()\n    {\n        //根据当前摄像机是正交还是透视进行对应赋值\n\n        if (Camera.main.orthographic == true)\n        {\n            currentScale = Camera.main.orthographicSize;\n        }\n        else\n        {\n            currentScale = Camera.main.fieldOfView;\n        }\n        defaultScale = currentScale;\n    }\n\n    // Update is called once per frame\n\n    void Update()\n    {\n\n        //获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\n        currentScale -= Input.GetAxis(\"Mouse ScrollWheel\") * scaleSpeed;\n        currentScale = Mathf.Clamp(currentScale, minScale, maxScale);\n        //根据当前摄像机是正交还是透视进行对应赋值，放大缩小\n\n        if (Camera.main.orthographic == true)\n        {\n            Camera.main.orthographicSize = currentScale;\n        }\n\n        else\n        {\n            Camera.main.fieldOfView = currentScale;\n        }\n        //显示小窗口\n        if (currentScale < defaultScale)\n        {\n            mapPanel.SetActive(true);\n        }\n        else\n        {\n            mapPanel.SetActive(false);\n        }\n    }\n\n}\n```\n</details>\n\n\n\n\n\n------\n<div class=\"success\">\n\n> 至此Demo的基本功能已经实现了，现完成下述功能：\n>\n> 1. 初始化游戏的基本数值\n> 2. 可动态增加不同地块种类和对应的建筑种类，方便快速管理属性值\n> 3. 实现基本的经济系统\n> 4. 让建筑根据固定时间间隔切换状态，并且在点击收取金币后才进入下一个工作状态。\n> 5. 实现特殊的建筑行为\n> 6. 鼠标滚轮缩放视图\n\n</div>\n\n<div class=\"info\">\n\n> 下一步要做的主要是美术部分：\n>\n> 2. 添加三种地块的建筑和材质模型\n> 3. 添加鼠标悬停和点击的shader\n> 4. 添加动画\n> 5. 更改UI\n\n\n</div>\n\n","source":"_posts/2021-08-06-小学期建造游戏Demo开发笔记（二）.md","raw":"---\ntitle: 2021-08-06-小学期建造游戏Demo开发笔记（二）\ndate: 2021-08-06 20:51:37\ntags:\n  - Unity\n  - 场景切换\n  - GameManager\n  - 单例模式\n  - UI隐藏\n  - 状态切换\n  \ncategories:\n  - 小学期建造游戏Demo开发笔记\n---\n\n# 重载当前的Scene\n\n```c#\nusing UnityEngine.SceneManagement;\n\npublic void restart()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    }\n```\n\n退出游戏：\n\n```c#\npublic void EndGame()\n    {\n        Application.Quit();\n    }\n```\n\n \n\n<!-- more -->\n\n# Game Manager\n\n>  由于“游戏管理器”控制的都是整个游戏中一些共有的信息，所以我们不会同时需要两个游戏管理器，因此游戏管理器将是一个单例对象。\n\n单例模式：\n\n创建一个静态对象`static GameManager current`\n\n直接在Awake里定义gm为this：\n\n```c#\nprivate void Awake()\n    {\n        current = this;\n    }\n```\n\n然后直接用`GameManager.current`即可调用里面的变量和函数。\n\n\n\n# UI\n\n#### 新建UI\n\n<div class=\"warning\">\n\n> 注意需要修改Canvas的设置，否则调整比例后位置可能会错乱。默认是constant with pixel size\n\n</div>\n\n![image-20210808163903666](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808163903666-16284119455091.png)\n\n\n\n![image-20210808174522165](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808174522165-16284159238313.png)_设置界面UI_\n\n<div class=\"warning\">\n\n> 注意当给GUI控件挂事件回调函数时，要选择上面Dynamic String的，不能选择下面静态变量。\n\n</div>\n\n#### 想要让Panel暂时隐藏或显示？\n\n注意不能漏任何组件，否则可能无法交互。\n\n![image-20210808164106909](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-小学期建造游戏Demo开发笔记（二）/image-20210808164106909-16284120682902.png)\n\n以TipUI为例：\n\n获取`CanvasGroup`组件，设置它的透明度、可交互、可被射线撞击等等属性。\n\n```c#\npublic class TipUI : MonoBehaviour\n{\n    private CanvasGroup _canvasGroup;\n    private Node _currentNode;\n    public Text tipText;\n    // Start is called before the first frame update\n    void Start()\n    {\n        _canvasGroup = gameObject.GetComponent<CanvasGroup>();//获得组件\n        GameEvents.current.onOpenTipGUI += OpenTip;\n    }\n    //显示\n    private void OpenTip(int cost,Node node)\n    {\n        _canvasGroup.alpha = 1;\n        _canvasGroup.interactable = true;\n        _canvasGroup.blocksRaycasts = true;\n\n        tipText.text = \"开发该地块需要\"+cost+\"经济值，是否开发？\";\n        _currentNode = node;\n    }\n\n    public void UnlockNode()\n    {\n        Debug.Log(\"是\");\n        _currentNode.Unlock();\n        HideTip();\n    }\n    //隐藏\n    public void HideTip()\n    {\n        _canvasGroup.alpha = 0;\n        _canvasGroup.interactable = false;\n        _canvasGroup.blocksRaycasts = false;\n    }\n}\n```\n\n然后只要调用函数`GameEvents.current.OpenTipGUI()`即可控制显示。\n\n\n\n\n\n# 状态切换\n\n使用`BuildingController.cs`来管理建筑的状态。\n\n先定义枚举状态：`public enum BuildingStates { WORKING,WAITING,DEAD }`\n\n然后在Start时初始化一个`BuildingStates`: `buildingStates = BuildingStates.WORKING;`\n\n在Update()函数中调用`SwitchStates()`:\n\n```c#\npublic void SwitchStates()\n    {\n        switch (buildingStates)\n        {\n            case BuildingStates.WORKING:\n                //时间到了\n                if (timeLeft <= 0)\n                {\n                    CoinShow(bs.BDCoin);\n                    buildingStates = BuildingStates.WAITING;\n                }\n                else\n                {\n                    timeLeft -= Time.deltaTime;\n                }\n                break;\n            case BuildingStates.WAITING:\n                \n                break;\n            case BuildingStates.DEAD:\n                //特殊土地，已经不能再使用，需要手动拆除。\n                Renderer renderer = GetComponent<Renderer>();\n                renderer.material.SetColor(\"_Color\", Color.red);\n                currentNode.canSpecial = false;\n                break;\n            default:\n                break;\n        }\n\n\n        if (greenTimeLeft <= 0)\n        {\n            //GreenAdd(bs.BDGreen);\n            GameManager.getGM.Green += bs.BDGreen;\n            greenTimeLeft = updateTime;\n        }\n        else\n        {\n            greenTimeLeft -= Time.deltaTime;\n        }\n    }\n```\n\n## 特殊建筑\n\n对于有使用轮次限制的特殊建筑，定义子类`SpecialLandController` 继承`BuildingController`，对ToWorking函数重写。使用变量count来记录工作的轮次。\n\n> 注意只有被public和protected修饰的父类变量能被子类使用，所以要记得修改父类变量或函数的作用范围。\n\n```c#\npublic class SpecialLandController : BuildingController\n{\n    [SerializeField]\n    private int count = 0;\n\n    public int times = 10;\n\n    protected new void Start()\n    {\n        this.onToWorking += ToWorking;    // 事件注册\n        init();\n    }\n\n    public new void ToWorking()\n    {\n        Debug.Log(\"子\");\n        timeLeft = updateTime;\n        bs.GetCoin();\n        count++;\n\n        if (count >= times)\n        {\n            buildingStates = BuildingStates.DEAD;\n        }\n        else\n        {\n            buildingStates = BuildingStates.WORKING;\n        }\n        \n        \n    }\n}\n```\n\n\n\n# 鼠标滚轮缩放Camera视图\n\n## 小窗口显示整体地图\n\n复制一个Camera，然后修改TargetTexture 为一个新建的RenderTexture，然后在GUI中新建RawImage，把Texture设置为摄像机输出的RenderTexture即可。\n\n## 滚轮缩放\n\n在Update函数中：  `Mathf.Clamp()`函数用于固定在最大和最小值范围内。\n\n-=是鼠标滚轮上划视图放大，下滑缩小；+=反之。\n\n```c#\n//获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\ncurrentScale -= Input.GetAxis(\"Mouse ScrollWheel\") * scaleSpeed;\ncurrentScale = Mathf.Clamp(currentScale, minScale, maxScale);\n```\n\n\n\n<details>\n  <summary>FollowMouseScale.cs</summary>\n\n\n```c#\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class FollowMouseScale : MonoBehaviour\n{\n    public GameObject mapPanel;\n    public float scaleSpeed = 5.0f;\n    private float minScale = 1.0f;\n    private float maxScale = 150.0f;\n    private float currentScale;\n    private float defaultScale;\n\n    // Use this for initialization\n\n    void Start()\n    {\n        //根据当前摄像机是正交还是透视进行对应赋值\n\n        if (Camera.main.orthographic == true)\n        {\n            currentScale = Camera.main.orthographicSize;\n        }\n        else\n        {\n            currentScale = Camera.main.fieldOfView;\n        }\n        defaultScale = currentScale;\n    }\n\n    // Update is called once per frame\n\n    void Update()\n    {\n\n        //获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\n        currentScale -= Input.GetAxis(\"Mouse ScrollWheel\") * scaleSpeed;\n        currentScale = Mathf.Clamp(currentScale, minScale, maxScale);\n        //根据当前摄像机是正交还是透视进行对应赋值，放大缩小\n\n        if (Camera.main.orthographic == true)\n        {\n            Camera.main.orthographicSize = currentScale;\n        }\n\n        else\n        {\n            Camera.main.fieldOfView = currentScale;\n        }\n        //显示小窗口\n        if (currentScale < defaultScale)\n        {\n            mapPanel.SetActive(true);\n        }\n        else\n        {\n            mapPanel.SetActive(false);\n        }\n    }\n\n}\n```\n</details>\n\n\n\n\n\n------\n<div class=\"success\">\n\n> 至此Demo的基本功能已经实现了，现完成下述功能：\n>\n> 1. 初始化游戏的基本数值\n> 2. 可动态增加不同地块种类和对应的建筑种类，方便快速管理属性值\n> 3. 实现基本的经济系统\n> 4. 让建筑根据固定时间间隔切换状态，并且在点击收取金币后才进入下一个工作状态。\n> 5. 实现特殊的建筑行为\n> 6. 鼠标滚轮缩放视图\n\n</div>\n\n<div class=\"info\">\n\n> 下一步要做的主要是美术部分：\n>\n> 2. 添加三种地块的建筑和材质模型\n> 3. 添加鼠标悬停和点击的shader\n> 4. 添加动画\n> 5. 更改UI\n\n\n</div>\n\n","slug":"2021-08-06-小学期建造游戏Demo开发笔记（二）","published":1,"updated":"2021-08-29T08:41:07.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l100093svo09ac7io5","content":"<h1 id=\"重载当前的Scene\"><a href=\"#重载当前的Scene\" class=\"headerlink\" title=\"重载当前的Scene\"></a>重载当前的Scene</h1><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine.SceneManagement;\n\npublic void restart()\n    &#123;\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>退出游戏：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public void EndGame()\n    &#123;\n        Application.Quit();\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<span id=\"more\"></span>\n\n<h1 id=\"Game-Manager\"><a href=\"#Game-Manager\" class=\"headerlink\" title=\"Game Manager\"></a>Game Manager</h1><blockquote>\n<p> 由于“游戏管理器”控制的都是整个游戏中一些共有的信息，所以我们不会同时需要两个游戏管理器，因此游戏管理器将是一个单例对象。</p>\n</blockquote>\n<p>单例模式：</p>\n<p>创建一个静态对象<code>static GameManager current</code></p>\n<p>直接在Awake里定义gm为this：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private void Awake()\n    &#123;\n        current &#x3D; this;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后直接用<code>GameManager.current</code>即可调用里面的变量和函数。</p>\n<h1 id=\"UI\"><a href=\"#UI\" class=\"headerlink\" title=\"UI\"></a>UI</h1><h4 id=\"新建UI\"><a href=\"#新建UI\" class=\"headerlink\" title=\"新建UI\"></a>新建UI</h4><div class=\"warning\">\n\n<blockquote>\n<p>注意需要修改Canvas的设置，否则调整比例后位置可能会错乱。默认是constant with pixel size</p>\n</blockquote>\n</div>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808163903666-16284119455091.png\" alt=\"image-20210808163903666\" loading=\"lazy\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808174522165-16284159238313.png\" alt=\"image-20210808174522165\" loading=\"lazy\"><em>设置界面UI</em></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>注意当给GUI控件挂事件回调函数时，要选择上面Dynamic String的，不能选择下面静态变量。</p>\n</blockquote>\n</div>\n\n<h4 id=\"想要让Panel暂时隐藏或显示？\"><a href=\"#想要让Panel暂时隐藏或显示？\" class=\"headerlink\" title=\"想要让Panel暂时隐藏或显示？\"></a>想要让Panel暂时隐藏或显示？</h4><p>注意不能漏任何组件，否则可能无法交互。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808164106909-16284120682902.png\" alt=\"image-20210808164106909\" loading=\"lazy\"></p>\n<p>以TipUI为例：</p>\n<p>获取<code>CanvasGroup</code>组件，设置它的透明度、可交互、可被射线撞击等等属性。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class TipUI : MonoBehaviour\n&#123;\n    private CanvasGroup _canvasGroup;\n    private Node _currentNode;\n    public Text tipText;\n    &#x2F;&#x2F; Start is called before the first frame update\n    void Start()\n    &#123;\n        _canvasGroup &#x3D; gameObject.GetComponent&lt;CanvasGroup&gt;();&#x2F;&#x2F;获得组件\n        GameEvents.current.onOpenTipGUI +&#x3D; OpenTip;\n    &#125;\n    &#x2F;&#x2F;显示\n    private void OpenTip(int cost,Node node)\n    &#123;\n        _canvasGroup.alpha &#x3D; 1;\n        _canvasGroup.interactable &#x3D; true;\n        _canvasGroup.blocksRaycasts &#x3D; true;\n\n        tipText.text &#x3D; &quot;开发该地块需要&quot;+cost+&quot;经济值，是否开发？&quot;;\n        _currentNode &#x3D; node;\n    &#125;\n\n    public void UnlockNode()\n    &#123;\n        Debug.Log(&quot;是&quot;);\n        _currentNode.Unlock();\n        HideTip();\n    &#125;\n    &#x2F;&#x2F;隐藏\n    public void HideTip()\n    &#123;\n        _canvasGroup.alpha &#x3D; 0;\n        _canvasGroup.interactable &#x3D; false;\n        _canvasGroup.blocksRaycasts &#x3D; false;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后只要调用函数<code>GameEvents.current.OpenTipGUI()</code>即可控制显示。</p>\n<h1 id=\"状态切换\"><a href=\"#状态切换\" class=\"headerlink\" title=\"状态切换\"></a>状态切换</h1><p>使用<code>BuildingController.cs</code>来管理建筑的状态。</p>\n<p>先定义枚举状态：<code>public enum BuildingStates &#123; WORKING,WAITING,DEAD &#125;</code></p>\n<p>然后在Start时初始化一个<code>BuildingStates</code>: <code>buildingStates = BuildingStates.WORKING;</code></p>\n<p>在Update()函数中调用<code>SwitchStates()</code>:</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public void SwitchStates()\n    &#123;\n        switch (buildingStates)\n        &#123;\n            case BuildingStates.WORKING:\n                &#x2F;&#x2F;时间到了\n                if (timeLeft &lt;&#x3D; 0)\n                &#123;\n                    CoinShow(bs.BDCoin);\n                    buildingStates &#x3D; BuildingStates.WAITING;\n                &#125;\n                else\n                &#123;\n                    timeLeft -&#x3D; Time.deltaTime;\n                &#125;\n                break;\n            case BuildingStates.WAITING:\n                \n                break;\n            case BuildingStates.DEAD:\n                &#x2F;&#x2F;特殊土地，已经不能再使用，需要手动拆除。\n                Renderer renderer &#x3D; GetComponent&lt;Renderer&gt;();\n                renderer.material.SetColor(&quot;_Color&quot;, Color.red);\n                currentNode.canSpecial &#x3D; false;\n                break;\n            default:\n                break;\n        &#125;\n\n\n        if (greenTimeLeft &lt;&#x3D; 0)\n        &#123;\n            &#x2F;&#x2F;GreenAdd(bs.BDGreen);\n            GameManager.getGM.Green +&#x3D; bs.BDGreen;\n            greenTimeLeft &#x3D; updateTime;\n        &#125;\n        else\n        &#123;\n            greenTimeLeft -&#x3D; Time.deltaTime;\n        &#125;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"特殊建筑\"><a href=\"#特殊建筑\" class=\"headerlink\" title=\"特殊建筑\"></a>特殊建筑</h2><p>对于有使用轮次限制的特殊建筑，定义子类<code>SpecialLandController</code> 继承<code>BuildingController</code>，对ToWorking函数重写。使用变量count来记录工作的轮次。</p>\n<blockquote>\n<p>注意只有被public和protected修饰的父类变量能被子类使用，所以要记得修改父类变量或函数的作用范围。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class SpecialLandController : BuildingController\n&#123;\n    [SerializeField]\n    private int count &#x3D; 0;\n\n    public int times &#x3D; 10;\n\n    protected new void Start()\n    &#123;\n        this.onToWorking +&#x3D; ToWorking;    &#x2F;&#x2F; 事件注册\n        init();\n    &#125;\n\n    public new void ToWorking()\n    &#123;\n        Debug.Log(&quot;子&quot;);\n        timeLeft &#x3D; updateTime;\n        bs.GetCoin();\n        count++;\n\n        if (count &gt;&#x3D; times)\n        &#123;\n            buildingStates &#x3D; BuildingStates.DEAD;\n        &#125;\n        else\n        &#123;\n            buildingStates &#x3D; BuildingStates.WORKING;\n        &#125;\n        \n        \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"鼠标滚轮缩放Camera视图\"><a href=\"#鼠标滚轮缩放Camera视图\" class=\"headerlink\" title=\"鼠标滚轮缩放Camera视图\"></a>鼠标滚轮缩放Camera视图</h1><h2 id=\"小窗口显示整体地图\"><a href=\"#小窗口显示整体地图\" class=\"headerlink\" title=\"小窗口显示整体地图\"></a>小窗口显示整体地图</h2><p>复制一个Camera，然后修改TargetTexture 为一个新建的RenderTexture，然后在GUI中新建RawImage，把Texture设置为摄像机输出的RenderTexture即可。</p>\n<h2 id=\"滚轮缩放\"><a href=\"#滚轮缩放\" class=\"headerlink\" title=\"滚轮缩放\"></a>滚轮缩放</h2><p>在Update函数中：  <code>Mathf.Clamp()</code>函数用于固定在最大和最小值范围内。</p>\n<p>-=是鼠标滚轮上划视图放大，下滑缩小；+=反之。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\ncurrentScale -&#x3D; Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scaleSpeed;\ncurrentScale &#x3D; Mathf.Clamp(currentScale, minScale, maxScale);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<details>\n  <summary>FollowMouseScale.cs</summary>\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine;\nusing UnityEngine.UI;\n\npublic class FollowMouseScale : MonoBehaviour\n&#123;\n    public GameObject mapPanel;\n    public float scaleSpeed &#x3D; 5.0f;\n    private float minScale &#x3D; 1.0f;\n    private float maxScale &#x3D; 150.0f;\n    private float currentScale;\n    private float defaultScale;\n\n    &#x2F;&#x2F; Use this for initialization\n\n    void Start()\n    &#123;\n        &#x2F;&#x2F;根据当前摄像机是正交还是透视进行对应赋值\n\n        if (Camera.main.orthographic &#x3D;&#x3D; true)\n        &#123;\n            currentScale &#x3D; Camera.main.orthographicSize;\n        &#125;\n        else\n        &#123;\n            currentScale &#x3D; Camera.main.fieldOfView;\n        &#125;\n        defaultScale &#x3D; currentScale;\n    &#125;\n\n    &#x2F;&#x2F; Update is called once per frame\n\n    void Update()\n    &#123;\n\n        &#x2F;&#x2F;获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\n        currentScale -&#x3D; Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scaleSpeed;\n        currentScale &#x3D; Mathf.Clamp(currentScale, minScale, maxScale);\n        &#x2F;&#x2F;根据当前摄像机是正交还是透视进行对应赋值，放大缩小\n\n        if (Camera.main.orthographic &#x3D;&#x3D; true)\n        &#123;\n            Camera.main.orthographicSize &#x3D; currentScale;\n        &#125;\n\n        else\n        &#123;\n            Camera.main.fieldOfView &#x3D; currentScale;\n        &#125;\n        &#x2F;&#x2F;显示小窗口\n        if (currentScale &lt; defaultScale)\n        &#123;\n            mapPanel.SetActive(true);\n        &#125;\n        else\n        &#123;\n            mapPanel.SetActive(false);\n        &#125;\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</details>\n\n\n\n\n\n<hr>\n<div class=\"success\">\n\n<blockquote>\n<p>至此Demo的基本功能已经实现了，现完成下述功能：</p>\n<ol>\n<li>初始化游戏的基本数值</li>\n<li>可动态增加不同地块种类和对应的建筑种类，方便快速管理属性值</li>\n<li>实现基本的经济系统</li>\n<li>让建筑根据固定时间间隔切换状态，并且在点击收取金币后才进入下一个工作状态。</li>\n<li>实现特殊的建筑行为</li>\n<li>鼠标滚轮缩放视图</li>\n</ol>\n</blockquote>\n</div>\n\n<div class=\"info\">\n\n<blockquote>\n<p>下一步要做的主要是美术部分：</p>\n<ol start=\"2\">\n<li>添加三种地块的建筑和材质模型</li>\n<li>添加鼠标悬停和点击的shader</li>\n<li>添加动画</li>\n<li>更改UI</li>\n</ol>\n</blockquote>\n</div>\n\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"重载当前的Scene\"><a href=\"#重载当前的Scene\" class=\"headerlink\" title=\"重载当前的Scene\"></a>重载当前的Scene</h1><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine.SceneManagement;\n\npublic void restart()\n    &#123;\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>退出游戏：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public void EndGame()\n    &#123;\n        Application.Quit();\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>","more":"<h1 id=\"Game-Manager\"><a href=\"#Game-Manager\" class=\"headerlink\" title=\"Game Manager\"></a>Game Manager</h1><blockquote>\n<p> 由于“游戏管理器”控制的都是整个游戏中一些共有的信息，所以我们不会同时需要两个游戏管理器，因此游戏管理器将是一个单例对象。</p>\n</blockquote>\n<p>单例模式：</p>\n<p>创建一个静态对象<code>static GameManager current</code></p>\n<p>直接在Awake里定义gm为this：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private void Awake()\n    &#123;\n        current &#x3D; this;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后直接用<code>GameManager.current</code>即可调用里面的变量和函数。</p>\n<h1 id=\"UI\"><a href=\"#UI\" class=\"headerlink\" title=\"UI\"></a>UI</h1><h4 id=\"新建UI\"><a href=\"#新建UI\" class=\"headerlink\" title=\"新建UI\"></a>新建UI</h4><div class=\"warning\">\n\n<blockquote>\n<p>注意需要修改Canvas的设置，否则调整比例后位置可能会错乱。默认是constant with pixel size</p>\n</blockquote>\n</div>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808163903666-16284119455091.png\" alt=\"image-20210808163903666\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808174522165-16284159238313.png\" alt=\"image-20210808174522165\"><em>设置界面UI</em></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>注意当给GUI控件挂事件回调函数时，要选择上面Dynamic String的，不能选择下面静态变量。</p>\n</blockquote>\n</div>\n\n<h4 id=\"想要让Panel暂时隐藏或显示？\"><a href=\"#想要让Panel暂时隐藏或显示？\" class=\"headerlink\" title=\"想要让Panel暂时隐藏或显示？\"></a>想要让Panel暂时隐藏或显示？</h4><p>注意不能漏任何组件，否则可能无法交互。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-06-%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%BB%BA%E9%80%A0%E6%B8%B8%E6%88%8FDemo%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210808164106909-16284120682902.png\" alt=\"image-20210808164106909\"></p>\n<p>以TipUI为例：</p>\n<p>获取<code>CanvasGroup</code>组件，设置它的透明度、可交互、可被射线撞击等等属性。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class TipUI : MonoBehaviour\n&#123;\n    private CanvasGroup _canvasGroup;\n    private Node _currentNode;\n    public Text tipText;\n    &#x2F;&#x2F; Start is called before the first frame update\n    void Start()\n    &#123;\n        _canvasGroup &#x3D; gameObject.GetComponent&lt;CanvasGroup&gt;();&#x2F;&#x2F;获得组件\n        GameEvents.current.onOpenTipGUI +&#x3D; OpenTip;\n    &#125;\n    &#x2F;&#x2F;显示\n    private void OpenTip(int cost,Node node)\n    &#123;\n        _canvasGroup.alpha &#x3D; 1;\n        _canvasGroup.interactable &#x3D; true;\n        _canvasGroup.blocksRaycasts &#x3D; true;\n\n        tipText.text &#x3D; &quot;开发该地块需要&quot;+cost+&quot;经济值，是否开发？&quot;;\n        _currentNode &#x3D; node;\n    &#125;\n\n    public void UnlockNode()\n    &#123;\n        Debug.Log(&quot;是&quot;);\n        _currentNode.Unlock();\n        HideTip();\n    &#125;\n    &#x2F;&#x2F;隐藏\n    public void HideTip()\n    &#123;\n        _canvasGroup.alpha &#x3D; 0;\n        _canvasGroup.interactable &#x3D; false;\n        _canvasGroup.blocksRaycasts &#x3D; false;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后只要调用函数<code>GameEvents.current.OpenTipGUI()</code>即可控制显示。</p>\n<h1 id=\"状态切换\"><a href=\"#状态切换\" class=\"headerlink\" title=\"状态切换\"></a>状态切换</h1><p>使用<code>BuildingController.cs</code>来管理建筑的状态。</p>\n<p>先定义枚举状态：<code>public enum BuildingStates &#123; WORKING,WAITING,DEAD &#125;</code></p>\n<p>然后在Start时初始化一个<code>BuildingStates</code>: <code>buildingStates = BuildingStates.WORKING;</code></p>\n<p>在Update()函数中调用<code>SwitchStates()</code>:</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public void SwitchStates()\n    &#123;\n        switch (buildingStates)\n        &#123;\n            case BuildingStates.WORKING:\n                &#x2F;&#x2F;时间到了\n                if (timeLeft &lt;&#x3D; 0)\n                &#123;\n                    CoinShow(bs.BDCoin);\n                    buildingStates &#x3D; BuildingStates.WAITING;\n                &#125;\n                else\n                &#123;\n                    timeLeft -&#x3D; Time.deltaTime;\n                &#125;\n                break;\n            case BuildingStates.WAITING:\n                \n                break;\n            case BuildingStates.DEAD:\n                &#x2F;&#x2F;特殊土地，已经不能再使用，需要手动拆除。\n                Renderer renderer &#x3D; GetComponent&lt;Renderer&gt;();\n                renderer.material.SetColor(&quot;_Color&quot;, Color.red);\n                currentNode.canSpecial &#x3D; false;\n                break;\n            default:\n                break;\n        &#125;\n\n\n        if (greenTimeLeft &lt;&#x3D; 0)\n        &#123;\n            &#x2F;&#x2F;GreenAdd(bs.BDGreen);\n            GameManager.getGM.Green +&#x3D; bs.BDGreen;\n            greenTimeLeft &#x3D; updateTime;\n        &#125;\n        else\n        &#123;\n            greenTimeLeft -&#x3D; Time.deltaTime;\n        &#125;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"特殊建筑\"><a href=\"#特殊建筑\" class=\"headerlink\" title=\"特殊建筑\"></a>特殊建筑</h2><p>对于有使用轮次限制的特殊建筑，定义子类<code>SpecialLandController</code> 继承<code>BuildingController</code>，对ToWorking函数重写。使用变量count来记录工作的轮次。</p>\n<blockquote>\n<p>注意只有被public和protected修饰的父类变量能被子类使用，所以要记得修改父类变量或函数的作用范围。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class SpecialLandController : BuildingController\n&#123;\n    [SerializeField]\n    private int count &#x3D; 0;\n\n    public int times &#x3D; 10;\n\n    protected new void Start()\n    &#123;\n        this.onToWorking +&#x3D; ToWorking;    &#x2F;&#x2F; 事件注册\n        init();\n    &#125;\n\n    public new void ToWorking()\n    &#123;\n        Debug.Log(&quot;子&quot;);\n        timeLeft &#x3D; updateTime;\n        bs.GetCoin();\n        count++;\n\n        if (count &gt;&#x3D; times)\n        &#123;\n            buildingStates &#x3D; BuildingStates.DEAD;\n        &#125;\n        else\n        &#123;\n            buildingStates &#x3D; BuildingStates.WORKING;\n        &#125;\n        \n        \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"鼠标滚轮缩放Camera视图\"><a href=\"#鼠标滚轮缩放Camera视图\" class=\"headerlink\" title=\"鼠标滚轮缩放Camera视图\"></a>鼠标滚轮缩放Camera视图</h1><h2 id=\"小窗口显示整体地图\"><a href=\"#小窗口显示整体地图\" class=\"headerlink\" title=\"小窗口显示整体地图\"></a>小窗口显示整体地图</h2><p>复制一个Camera，然后修改TargetTexture 为一个新建的RenderTexture，然后在GUI中新建RawImage，把Texture设置为摄像机输出的RenderTexture即可。</p>\n<h2 id=\"滚轮缩放\"><a href=\"#滚轮缩放\" class=\"headerlink\" title=\"滚轮缩放\"></a>滚轮缩放</h2><p>在Update函数中：  <code>Mathf.Clamp()</code>函数用于固定在最大和最小值范围内。</p>\n<p>-=是鼠标滚轮上划视图放大，下滑缩小；+=反之。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\ncurrentScale -&#x3D; Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scaleSpeed;\ncurrentScale &#x3D; Mathf.Clamp(currentScale, minScale, maxScale);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<details>\n  <summary>FollowMouseScale.cs</summary>\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine;\nusing UnityEngine.UI;\n\npublic class FollowMouseScale : MonoBehaviour\n&#123;\n    public GameObject mapPanel;\n    public float scaleSpeed &#x3D; 5.0f;\n    private float minScale &#x3D; 1.0f;\n    private float maxScale &#x3D; 150.0f;\n    private float currentScale;\n    private float defaultScale;\n\n    &#x2F;&#x2F; Use this for initialization\n\n    void Start()\n    &#123;\n        &#x2F;&#x2F;根据当前摄像机是正交还是透视进行对应赋值\n\n        if (Camera.main.orthographic &#x3D;&#x3D; true)\n        &#123;\n            currentScale &#x3D; Camera.main.orthographicSize;\n        &#125;\n        else\n        &#123;\n            currentScale &#x3D; Camera.main.fieldOfView;\n        &#125;\n        defaultScale &#x3D; currentScale;\n    &#125;\n\n    &#x2F;&#x2F; Update is called once per frame\n\n    void Update()\n    &#123;\n\n        &#x2F;&#x2F;获取鼠标滚轮的值，向前大于0，向后小于0，并设置放大缩小范围值\n        currentScale -&#x3D; Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scaleSpeed;\n        currentScale &#x3D; Mathf.Clamp(currentScale, minScale, maxScale);\n        &#x2F;&#x2F;根据当前摄像机是正交还是透视进行对应赋值，放大缩小\n\n        if (Camera.main.orthographic &#x3D;&#x3D; true)\n        &#123;\n            Camera.main.orthographicSize &#x3D; currentScale;\n        &#125;\n\n        else\n        &#123;\n            Camera.main.fieldOfView &#x3D; currentScale;\n        &#125;\n        &#x2F;&#x2F;显示小窗口\n        if (currentScale &lt; defaultScale)\n        &#123;\n            mapPanel.SetActive(true);\n        &#125;\n        else\n        &#123;\n            mapPanel.SetActive(false);\n        &#125;\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</details>\n\n\n\n\n\n<hr>\n<div class=\"success\">\n\n<blockquote>\n<p>至此Demo的基本功能已经实现了，现完成下述功能：</p>\n<ol>\n<li>初始化游戏的基本数值</li>\n<li>可动态增加不同地块种类和对应的建筑种类，方便快速管理属性值</li>\n<li>实现基本的经济系统</li>\n<li>让建筑根据固定时间间隔切换状态，并且在点击收取金币后才进入下一个工作状态。</li>\n<li>实现特殊的建筑行为</li>\n<li>鼠标滚轮缩放视图</li>\n</ol>\n</blockquote>\n</div>\n\n<div class=\"info\">\n\n<blockquote>\n<p>下一步要做的主要是美术部分：</p>\n<ol start=\"2\">\n<li>添加三种地块的建筑和材质模型</li>\n<li>添加鼠标悬停和点击的shader</li>\n<li>添加动画</li>\n<li>更改UI</li>\n</ol>\n</blockquote>\n</div>"},{"title":"2021-08-06-快捷键等小tips","date":"2021-08-06T02:41:16.000Z","_content":"\n# Unity\n## 快捷键\n\n##### getter 和 setter\n\n> 选中需要创建Getter 和 Setter的变量，快捷键Ctrl + R,E\n\n<!-- more -->\n\n\n\n# maya\n\n## 快捷键\nF 选中某边、面、对象按F键可以使其处于视图中央\n\n##### alt\nalt+B  切换背景颜色\n\n##### ctrl\nctrl+A 切换属性编辑器和层编辑器\nctrl+delete 可以删除组件及其相关联的顶点\nctrl+右键  边操作菜单\nctrl+中键  微调数值\nctrl+D  复制\nctrl+shift+D 特殊复制\n\nctrl+G 打组\n\n按住ctrl是减选择\n\nctrl+shift是添加选择\n\n##### shift\nshift 复选\nshift+<    shift+>快速选择工具\nshift+ 右键   顶点操作菜单，可以合并顶点\n\n##### backspace\n去掉两条线之间的点，不能去掉连接三条边的点\n\n***\n#### 循环边\n首尾相接的边\n\n根据四边面插入\n如果碰到三角面或五边面时可以去掉或加入一条边，然后插入。\n\n#### 环形边\n互相平行不相交的线\n循环边是在环形边上插入的，相当于在环形边上架“桥梁”\n\n#### 删除\n* 删除历史：编辑-按类型删除-历史\n### 材质\n添加材质：右键选择添加新材质/在Hypershade里添加\n对象模式下选中模型，然后右键选择材质球将XXX指定给当前选择\n或按住鼠标右键然后将材质球拖给模型。\nhypershade在窗口-渲染编辑器\n\n\n#### 对称选择\n双击选择工具可以进行对称设置\n\n#### 桥接\n两个开口多边形对应在一起，且拓扑结构一样时，可以用边选择选中，然后再编辑网格-桥接，可以生成新的面和先将其连起来\n\n#### 打组\n\n打组有两种方法，一种是选择需要的物体，直接ctrl+g就可以打组，另外一种是依次点击edit-Group来打组。\n\n#### 归零数值\n* 在平移/缩放处右键-冻结\n* 修改-冻结变换\n\n#### 导出\n文件-导出当前选择-在框后面选择obj类型\n\n\n\n# blender\n\n> [文档](https://docs.blender.org/manual/zh-hans/dev/getting_started/index.html)\n>\n> [视图快捷键](https://www.bilibili.com/read/cv10547329)\n>\n> [快捷键](https://blog.csdn.net/u012204304/article/details/89030370)\n\ns 缩放\n\nr 旋转\n\n#### ctrl\n\nctrl+Tab  切换编辑模式\n\n![image-20210811105948421](D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210811105948421-16286507912294.png)\n\n\n\n#### shift\n\nshift+s 吸附游标位置\n\n游标→中心点 可以让视图以该物体为中心\n\n**取色** 绘制模式下按S  S+点击  放进色板\n\n**隔离模式**  /\n\n**融并** X\n\n\n\n\n\n# 数字特效与合成技术\n## 课时1\n#### 导入文件\n* 在节点工作区按R\n* 直接拖进素材\n* 左侧Read打开\n\n\n\n## 课时2\n\n#### 导入\n导入素材后，全选节点按L键可以令其整齐排列\n\n#### 显示图像内容\n* 选中某个结点按X（数字）键，可以令viewer产生X号箭头，连接该节点，将上面的画面显示出来\n* 然后按123即可在不同画面中切换\n\n#### ProjectSettings\n> 在结点编辑区按S\n##### 帧速率\n* 电影：24帧\n* 短视频：25帧\n##### 时间线\n\n* * *\n\n### 结点\n> 选中结点后按D键可以将该节点的作用删除\n\n##### Merge合成结点\n> 1.快捷键M\n> 2.从工具架中选择merge\n> 3.右键选择merge\n> 4.tab键搜索结点名称\n\n* 用来合成两个素材\n* A输入盖在B输入上面，再连输出到viewer\n* 选中两个结点按住Shift，再按M可以快速将两个结点合成起来，但是要注意顺序，在前面选择的是A输入。\n\n##### Premult预乘结点\n 处理背景有一层灰的图像，相当于将内容抠出来\n\n##### Transform结点\n> 快捷键T\n##### Blur结点\n> 快捷键B\n> 模糊\n##### Color结点调色\n##### Write结点输出图像\n\n## 课时3\n* 三基色\n* 三原色\n##### xyY色度图\n> 横坐标0-1\n> 马蹄形\n##### 色域（gamut）\n>要精确表示某种颜色必须要有一个框架，这个框架反映在色度图中就是色域。\n>需要RGB三基色和白点的色度坐标值\n>表示某种设备或标准所能描述的颜色范围，一般为三角形。\n\n电脑显示器：sRGB色域，和ITU-709色域差不多\n\n显示器：Rec.709\n电影院：P3色域\n超高清电视：Rec.2020\n\n##### 伽马校正\n自然界：1:1正比例的转换关系\n摄像机：在处理时向上凹（伽马校正），为了抵销电视CRT处理时的伽马特性（向下凹）\n最后还原为正比。\ngamma曲线是一个幂函数\n\n* 电脑屏幕自带一个2.2的gamma\n\n##### nuke对图像的处理-色彩管理\nnuke在显示图像时，以sRGB显示，给了图像一个向上的曲线，以抵销电脑显示器的向下的曲线。\n\n## 课时4\n\n#### RGBA通道\n##### Shuffle Copy结点\n有两个输入\n可以定义不同通道的来源\n##### Shuffle结点\n有一个输入\n> 功能：层与层之间信息的转换\n> 按住shift再按shuffle可以独立地添加shuffle结点\n\n\n## 课时5\n##### Grade结点\n调节gamma值（亮度）\n\n##### Roto结点\n可用来画色块\n\n## 课时6\n\n##### RotoPaint结点\n快捷键P\noutput默认为rgba\n\n![image-20210809163653261](D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210809163653261-16284982158371.png)\n\n##### defocus 景深\n## 课时8\n##### crop结点 修改包围盒大小\n\n#### transform\n按住ctrl再按鼠标左键复位\n\n\n## 课时9\n\n##### 取色\n先选吸管，再按ctrl+shift  鼠标点击取色\n\n##### Primatte抠像\n点Auto-compute\n##### Shuffle结点\n将primatte抠出来的alpha通道提取出来\n\n##### HueCorrect 抑制背景色，调节颜色\n\n##### Dilate 收边\n","source":"_posts/2021-08-06-快捷键等小tips.md","raw":"---\ntitle: 2021-08-06-快捷键等小tips\ndate: 2021-08-06 10:41:16\ntags:\n  - Unity\ncategories:\n  - 比较杂的知识点\n---\n\n# Unity\n## 快捷键\n\n##### getter 和 setter\n\n> 选中需要创建Getter 和 Setter的变量，快捷键Ctrl + R,E\n\n<!-- more -->\n\n\n\n# maya\n\n## 快捷键\nF 选中某边、面、对象按F键可以使其处于视图中央\n\n##### alt\nalt+B  切换背景颜色\n\n##### ctrl\nctrl+A 切换属性编辑器和层编辑器\nctrl+delete 可以删除组件及其相关联的顶点\nctrl+右键  边操作菜单\nctrl+中键  微调数值\nctrl+D  复制\nctrl+shift+D 特殊复制\n\nctrl+G 打组\n\n按住ctrl是减选择\n\nctrl+shift是添加选择\n\n##### shift\nshift 复选\nshift+<    shift+>快速选择工具\nshift+ 右键   顶点操作菜单，可以合并顶点\n\n##### backspace\n去掉两条线之间的点，不能去掉连接三条边的点\n\n***\n#### 循环边\n首尾相接的边\n\n根据四边面插入\n如果碰到三角面或五边面时可以去掉或加入一条边，然后插入。\n\n#### 环形边\n互相平行不相交的线\n循环边是在环形边上插入的，相当于在环形边上架“桥梁”\n\n#### 删除\n* 删除历史：编辑-按类型删除-历史\n### 材质\n添加材质：右键选择添加新材质/在Hypershade里添加\n对象模式下选中模型，然后右键选择材质球将XXX指定给当前选择\n或按住鼠标右键然后将材质球拖给模型。\nhypershade在窗口-渲染编辑器\n\n\n#### 对称选择\n双击选择工具可以进行对称设置\n\n#### 桥接\n两个开口多边形对应在一起，且拓扑结构一样时，可以用边选择选中，然后再编辑网格-桥接，可以生成新的面和先将其连起来\n\n#### 打组\n\n打组有两种方法，一种是选择需要的物体，直接ctrl+g就可以打组，另外一种是依次点击edit-Group来打组。\n\n#### 归零数值\n* 在平移/缩放处右键-冻结\n* 修改-冻结变换\n\n#### 导出\n文件-导出当前选择-在框后面选择obj类型\n\n\n\n# blender\n\n> [文档](https://docs.blender.org/manual/zh-hans/dev/getting_started/index.html)\n>\n> [视图快捷键](https://www.bilibili.com/read/cv10547329)\n>\n> [快捷键](https://blog.csdn.net/u012204304/article/details/89030370)\n\ns 缩放\n\nr 旋转\n\n#### ctrl\n\nctrl+Tab  切换编辑模式\n\n![image-20210811105948421](D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210811105948421-16286507912294.png)\n\n\n\n#### shift\n\nshift+s 吸附游标位置\n\n游标→中心点 可以让视图以该物体为中心\n\n**取色** 绘制模式下按S  S+点击  放进色板\n\n**隔离模式**  /\n\n**融并** X\n\n\n\n\n\n# 数字特效与合成技术\n## 课时1\n#### 导入文件\n* 在节点工作区按R\n* 直接拖进素材\n* 左侧Read打开\n\n\n\n## 课时2\n\n#### 导入\n导入素材后，全选节点按L键可以令其整齐排列\n\n#### 显示图像内容\n* 选中某个结点按X（数字）键，可以令viewer产生X号箭头，连接该节点，将上面的画面显示出来\n* 然后按123即可在不同画面中切换\n\n#### ProjectSettings\n> 在结点编辑区按S\n##### 帧速率\n* 电影：24帧\n* 短视频：25帧\n##### 时间线\n\n* * *\n\n### 结点\n> 选中结点后按D键可以将该节点的作用删除\n\n##### Merge合成结点\n> 1.快捷键M\n> 2.从工具架中选择merge\n> 3.右键选择merge\n> 4.tab键搜索结点名称\n\n* 用来合成两个素材\n* A输入盖在B输入上面，再连输出到viewer\n* 选中两个结点按住Shift，再按M可以快速将两个结点合成起来，但是要注意顺序，在前面选择的是A输入。\n\n##### Premult预乘结点\n 处理背景有一层灰的图像，相当于将内容抠出来\n\n##### Transform结点\n> 快捷键T\n##### Blur结点\n> 快捷键B\n> 模糊\n##### Color结点调色\n##### Write结点输出图像\n\n## 课时3\n* 三基色\n* 三原色\n##### xyY色度图\n> 横坐标0-1\n> 马蹄形\n##### 色域（gamut）\n>要精确表示某种颜色必须要有一个框架，这个框架反映在色度图中就是色域。\n>需要RGB三基色和白点的色度坐标值\n>表示某种设备或标准所能描述的颜色范围，一般为三角形。\n\n电脑显示器：sRGB色域，和ITU-709色域差不多\n\n显示器：Rec.709\n电影院：P3色域\n超高清电视：Rec.2020\n\n##### 伽马校正\n自然界：1:1正比例的转换关系\n摄像机：在处理时向上凹（伽马校正），为了抵销电视CRT处理时的伽马特性（向下凹）\n最后还原为正比。\ngamma曲线是一个幂函数\n\n* 电脑屏幕自带一个2.2的gamma\n\n##### nuke对图像的处理-色彩管理\nnuke在显示图像时，以sRGB显示，给了图像一个向上的曲线，以抵销电脑显示器的向下的曲线。\n\n## 课时4\n\n#### RGBA通道\n##### Shuffle Copy结点\n有两个输入\n可以定义不同通道的来源\n##### Shuffle结点\n有一个输入\n> 功能：层与层之间信息的转换\n> 按住shift再按shuffle可以独立地添加shuffle结点\n\n\n## 课时5\n##### Grade结点\n调节gamma值（亮度）\n\n##### Roto结点\n可用来画色块\n\n## 课时6\n\n##### RotoPaint结点\n快捷键P\noutput默认为rgba\n\n![image-20210809163653261](D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210809163653261-16284982158371.png)\n\n##### defocus 景深\n## 课时8\n##### crop结点 修改包围盒大小\n\n#### transform\n按住ctrl再按鼠标左键复位\n\n\n## 课时9\n\n##### 取色\n先选吸管，再按ctrl+shift  鼠标点击取色\n\n##### Primatte抠像\n点Auto-compute\n##### Shuffle结点\n将primatte抠出来的alpha通道提取出来\n\n##### HueCorrect 抑制背景色，调节颜色\n\n##### Dilate 收边\n","slug":"2021-08-06-快捷键等小tips","published":1,"updated":"2021-08-11T13:52:17.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l3000b3svo2964dgbp","content":"<h1 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h1><h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><h5 id=\"getter-和-setter\"><a href=\"#getter-和-setter\" class=\"headerlink\" title=\"getter 和 setter\"></a>getter 和 setter</h5><blockquote>\n<p>选中需要创建Getter 和 Setter的变量，快捷键Ctrl + R,E</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"maya\"><a href=\"#maya\" class=\"headerlink\" title=\"maya\"></a>maya</h1><h2 id=\"快捷键-1\"><a href=\"#快捷键-1\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>F 选中某边、面、对象按F键可以使其处于视图中央</p>\n<h5 id=\"alt\"><a href=\"#alt\" class=\"headerlink\" title=\"alt\"></a>alt</h5><p>alt+B  切换背景颜色</p>\n<h5 id=\"ctrl\"><a href=\"#ctrl\" class=\"headerlink\" title=\"ctrl\"></a>ctrl</h5><p>ctrl+A 切换属性编辑器和层编辑器<br>ctrl+delete 可以删除组件及其相关联的顶点<br>ctrl+右键  边操作菜单<br>ctrl+中键  微调数值<br>ctrl+D  复制<br>ctrl+shift+D 特殊复制</p>\n<p>ctrl+G 打组</p>\n<p>按住ctrl是减选择</p>\n<p>ctrl+shift是添加选择</p>\n<h5 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h5><p>shift 复选<br>shift+&lt;    shift+&gt;快速选择工具<br>shift+ 右键   顶点操作菜单，可以合并顶点</p>\n<h5 id=\"backspace\"><a href=\"#backspace\" class=\"headerlink\" title=\"backspace\"></a>backspace</h5><p>去掉两条线之间的点，不能去掉连接三条边的点</p>\n<hr>\n<h4 id=\"循环边\"><a href=\"#循环边\" class=\"headerlink\" title=\"循环边\"></a>循环边</h4><p>首尾相接的边</p>\n<p>根据四边面插入<br>如果碰到三角面或五边面时可以去掉或加入一条边，然后插入。</p>\n<h4 id=\"环形边\"><a href=\"#环形边\" class=\"headerlink\" title=\"环形边\"></a>环形边</h4><p>互相平行不相交的线<br>循环边是在环形边上插入的，相当于在环形边上架“桥梁”</p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><ul>\n<li>删除历史：编辑-按类型删除-历史<h3 id=\"材质\"><a href=\"#材质\" class=\"headerlink\" title=\"材质\"></a>材质</h3>添加材质：右键选择添加新材质/在Hypershade里添加<br>对象模式下选中模型，然后右键选择材质球将XXX指定给当前选择<br>或按住鼠标右键然后将材质球拖给模型。<br>hypershade在窗口-渲染编辑器</li>\n</ul>\n<h4 id=\"对称选择\"><a href=\"#对称选择\" class=\"headerlink\" title=\"对称选择\"></a>对称选择</h4><p>双击选择工具可以进行对称设置</p>\n<h4 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h4><p>两个开口多边形对应在一起，且拓扑结构一样时，可以用边选择选中，然后再编辑网格-桥接，可以生成新的面和先将其连起来</p>\n<h4 id=\"打组\"><a href=\"#打组\" class=\"headerlink\" title=\"打组\"></a>打组</h4><p>打组有两种方法，一种是选择需要的物体，直接ctrl+g就可以打组，另外一种是依次点击edit-Group来打组。</p>\n<h4 id=\"归零数值\"><a href=\"#归零数值\" class=\"headerlink\" title=\"归零数值\"></a>归零数值</h4><ul>\n<li>在平移/缩放处右键-冻结</li>\n<li>修改-冻结变换</li>\n</ul>\n<h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><p>文件-导出当前选择-在框后面选择obj类型</p>\n<h1 id=\"blender\"><a href=\"#blender\" class=\"headerlink\" title=\"blender\"></a>blender</h1><blockquote>\n<p><a href=\"https://docs.blender.org/manual/zh-hans/dev/getting_started/index.html\">文档</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv10547329\">视图快捷键</a></p>\n<p><a href=\"https://blog.csdn.net/u012204304/article/details/89030370\">快捷键</a></p>\n</blockquote>\n<p>s 缩放</p>\n<p>r 旋转</p>\n<h4 id=\"ctrl-1\"><a href=\"#ctrl-1\" class=\"headerlink\" title=\"ctrl\"></a>ctrl</h4><p>ctrl+Tab  切换编辑模式</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210811105948421-16286507912294.png\" alt=\"image-20210811105948421\" loading=\"lazy\"></p>\n<h4 id=\"shift-1\"><a href=\"#shift-1\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>shift+s 吸附游标位置</p>\n<p>游标→中心点 可以让视图以该物体为中心</p>\n<p><strong>取色</strong> 绘制模式下按S  S+点击  放进色板</p>\n<p><strong>隔离模式</strong>  /</p>\n<p><strong>融并</strong> X</p>\n<h1 id=\"数字特效与合成技术\"><a href=\"#数字特效与合成技术\" class=\"headerlink\" title=\"数字特效与合成技术\"></a>数字特效与合成技术</h1><h2 id=\"课时1\"><a href=\"#课时1\" class=\"headerlink\" title=\"课时1\"></a>课时1</h2><h4 id=\"导入文件\"><a href=\"#导入文件\" class=\"headerlink\" title=\"导入文件\"></a>导入文件</h4><ul>\n<li>在节点工作区按R</li>\n<li>直接拖进素材</li>\n<li>左侧Read打开</li>\n</ul>\n<h2 id=\"课时2\"><a href=\"#课时2\" class=\"headerlink\" title=\"课时2\"></a>课时2</h2><h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><p>导入素材后，全选节点按L键可以令其整齐排列</p>\n<h4 id=\"显示图像内容\"><a href=\"#显示图像内容\" class=\"headerlink\" title=\"显示图像内容\"></a>显示图像内容</h4><ul>\n<li>选中某个结点按X（数字）键，可以令viewer产生X号箭头，连接该节点，将上面的画面显示出来</li>\n<li>然后按123即可在不同画面中切换</li>\n</ul>\n<h4 id=\"ProjectSettings\"><a href=\"#ProjectSettings\" class=\"headerlink\" title=\"ProjectSettings\"></a>ProjectSettings</h4><blockquote>\n<p>在结点编辑区按S</p>\n</blockquote>\n<h5 id=\"帧速率\"><a href=\"#帧速率\" class=\"headerlink\" title=\"帧速率\"></a>帧速率</h5><ul>\n<li>电影：24帧</li>\n<li>短视频：25帧<h5 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h5></li>\n</ul>\n<hr>\n<h3 id=\"结点\"><a href=\"#结点\" class=\"headerlink\" title=\"结点\"></a>结点</h3><blockquote>\n<p>选中结点后按D键可以将该节点的作用删除</p>\n</blockquote>\n<h5 id=\"Merge合成结点\"><a href=\"#Merge合成结点\" class=\"headerlink\" title=\"Merge合成结点\"></a>Merge合成结点</h5><blockquote>\n<p>1.快捷键M<br>2.从工具架中选择merge<br>3.右键选择merge<br>4.tab键搜索结点名称</p>\n</blockquote>\n<ul>\n<li>用来合成两个素材</li>\n<li>A输入盖在B输入上面，再连输出到viewer</li>\n<li>选中两个结点按住Shift，再按M可以快速将两个结点合成起来，但是要注意顺序，在前面选择的是A输入。</li>\n</ul>\n<h5 id=\"Premult预乘结点\"><a href=\"#Premult预乘结点\" class=\"headerlink\" title=\"Premult预乘结点\"></a>Premult预乘结点</h5><p> 处理背景有一层灰的图像，相当于将内容抠出来</p>\n<h5 id=\"Transform结点\"><a href=\"#Transform结点\" class=\"headerlink\" title=\"Transform结点\"></a>Transform结点</h5><blockquote>\n<p>快捷键T</p>\n</blockquote>\n<h5 id=\"Blur结点\"><a href=\"#Blur结点\" class=\"headerlink\" title=\"Blur结点\"></a>Blur结点</h5><blockquote>\n<p>快捷键B<br>模糊</p>\n</blockquote>\n<h5 id=\"Color结点调色\"><a href=\"#Color结点调色\" class=\"headerlink\" title=\"Color结点调色\"></a>Color结点调色</h5><h5 id=\"Write结点输出图像\"><a href=\"#Write结点输出图像\" class=\"headerlink\" title=\"Write结点输出图像\"></a>Write结点输出图像</h5><h2 id=\"课时3\"><a href=\"#课时3\" class=\"headerlink\" title=\"课时3\"></a>课时3</h2><ul>\n<li>三基色</li>\n<li>三原色<h5 id=\"xyY色度图\"><a href=\"#xyY色度图\" class=\"headerlink\" title=\"xyY色度图\"></a>xyY色度图</h5><blockquote>\n<p>横坐标0-1<br>马蹄形</p>\n</blockquote>\n<h5 id=\"色域（gamut）\"><a href=\"#色域（gamut）\" class=\"headerlink\" title=\"色域（gamut）\"></a>色域（gamut）</h5><blockquote>\n<p>要精确表示某种颜色必须要有一个框架，这个框架反映在色度图中就是色域。<br>需要RGB三基色和白点的色度坐标值<br>表示某种设备或标准所能描述的颜色范围，一般为三角形。</p>\n</blockquote>\n</li>\n</ul>\n<p>电脑显示器：sRGB色域，和ITU-709色域差不多</p>\n<p>显示器：Rec.709<br>电影院：P3色域<br>超高清电视：Rec.2020</p>\n<h5 id=\"伽马校正\"><a href=\"#伽马校正\" class=\"headerlink\" title=\"伽马校正\"></a>伽马校正</h5><p>自然界：1:1正比例的转换关系<br>摄像机：在处理时向上凹（伽马校正），为了抵销电视CRT处理时的伽马特性（向下凹）<br>最后还原为正比。<br>gamma曲线是一个幂函数</p>\n<ul>\n<li>电脑屏幕自带一个2.2的gamma</li>\n</ul>\n<h5 id=\"nuke对图像的处理-色彩管理\"><a href=\"#nuke对图像的处理-色彩管理\" class=\"headerlink\" title=\"nuke对图像的处理-色彩管理\"></a>nuke对图像的处理-色彩管理</h5><p>nuke在显示图像时，以sRGB显示，给了图像一个向上的曲线，以抵销电脑显示器的向下的曲线。</p>\n<h2 id=\"课时4\"><a href=\"#课时4\" class=\"headerlink\" title=\"课时4\"></a>课时4</h2><h4 id=\"RGBA通道\"><a href=\"#RGBA通道\" class=\"headerlink\" title=\"RGBA通道\"></a>RGBA通道</h4><h5 id=\"Shuffle-Copy结点\"><a href=\"#Shuffle-Copy结点\" class=\"headerlink\" title=\"Shuffle Copy结点\"></a>Shuffle Copy结点</h5><p>有两个输入<br>可以定义不同通道的来源</p>\n<h5 id=\"Shuffle结点\"><a href=\"#Shuffle结点\" class=\"headerlink\" title=\"Shuffle结点\"></a>Shuffle结点</h5><p>有一个输入</p>\n<blockquote>\n<p>功能：层与层之间信息的转换<br>按住shift再按shuffle可以独立地添加shuffle结点</p>\n</blockquote>\n<h2 id=\"课时5\"><a href=\"#课时5\" class=\"headerlink\" title=\"课时5\"></a>课时5</h2><h5 id=\"Grade结点\"><a href=\"#Grade结点\" class=\"headerlink\" title=\"Grade结点\"></a>Grade结点</h5><p>调节gamma值（亮度）</p>\n<h5 id=\"Roto结点\"><a href=\"#Roto结点\" class=\"headerlink\" title=\"Roto结点\"></a>Roto结点</h5><p>可用来画色块</p>\n<h2 id=\"课时6\"><a href=\"#课时6\" class=\"headerlink\" title=\"课时6\"></a>课时6</h2><h5 id=\"RotoPaint结点\"><a href=\"#RotoPaint结点\" class=\"headerlink\" title=\"RotoPaint结点\"></a>RotoPaint结点</h5><p>快捷键P<br>output默认为rgba</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210809163653261-16284982158371.png\" alt=\"image-20210809163653261\" loading=\"lazy\"></p>\n<h5 id=\"defocus-景深\"><a href=\"#defocus-景深\" class=\"headerlink\" title=\"defocus 景深\"></a>defocus 景深</h5><h2 id=\"课时8\"><a href=\"#课时8\" class=\"headerlink\" title=\"课时8\"></a>课时8</h2><h5 id=\"crop结点-修改包围盒大小\"><a href=\"#crop结点-修改包围盒大小\" class=\"headerlink\" title=\"crop结点 修改包围盒大小\"></a>crop结点 修改包围盒大小</h5><h4 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h4><p>按住ctrl再按鼠标左键复位</p>\n<h2 id=\"课时9\"><a href=\"#课时9\" class=\"headerlink\" title=\"课时9\"></a>课时9</h2><h5 id=\"取色\"><a href=\"#取色\" class=\"headerlink\" title=\"取色\"></a>取色</h5><p>先选吸管，再按ctrl+shift  鼠标点击取色</p>\n<h5 id=\"Primatte抠像\"><a href=\"#Primatte抠像\" class=\"headerlink\" title=\"Primatte抠像\"></a>Primatte抠像</h5><p>点Auto-compute</p>\n<h5 id=\"Shuffle结点-1\"><a href=\"#Shuffle结点-1\" class=\"headerlink\" title=\"Shuffle结点\"></a>Shuffle结点</h5><p>将primatte抠出来的alpha通道提取出来</p>\n<h5 id=\"HueCorrect-抑制背景色，调节颜色\"><a href=\"#HueCorrect-抑制背景色，调节颜色\" class=\"headerlink\" title=\"HueCorrect 抑制背景色，调节颜色\"></a>HueCorrect 抑制背景色，调节颜色</h5><h5 id=\"Dilate-收边\"><a href=\"#Dilate-收边\" class=\"headerlink\" title=\"Dilate 收边\"></a>Dilate 收边</h5>","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h1><h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><h5 id=\"getter-和-setter\"><a href=\"#getter-和-setter\" class=\"headerlink\" title=\"getter 和 setter\"></a>getter 和 setter</h5><blockquote>\n<p>选中需要创建Getter 和 Setter的变量，快捷键Ctrl + R,E</p>\n</blockquote>","more":"<h1 id=\"maya\"><a href=\"#maya\" class=\"headerlink\" title=\"maya\"></a>maya</h1><h2 id=\"快捷键-1\"><a href=\"#快捷键-1\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>F 选中某边、面、对象按F键可以使其处于视图中央</p>\n<h5 id=\"alt\"><a href=\"#alt\" class=\"headerlink\" title=\"alt\"></a>alt</h5><p>alt+B  切换背景颜色</p>\n<h5 id=\"ctrl\"><a href=\"#ctrl\" class=\"headerlink\" title=\"ctrl\"></a>ctrl</h5><p>ctrl+A 切换属性编辑器和层编辑器<br>ctrl+delete 可以删除组件及其相关联的顶点<br>ctrl+右键  边操作菜单<br>ctrl+中键  微调数值<br>ctrl+D  复制<br>ctrl+shift+D 特殊复制</p>\n<p>ctrl+G 打组</p>\n<p>按住ctrl是减选择</p>\n<p>ctrl+shift是添加选择</p>\n<h5 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h5><p>shift 复选<br>shift+&lt;    shift+&gt;快速选择工具<br>shift+ 右键   顶点操作菜单，可以合并顶点</p>\n<h5 id=\"backspace\"><a href=\"#backspace\" class=\"headerlink\" title=\"backspace\"></a>backspace</h5><p>去掉两条线之间的点，不能去掉连接三条边的点</p>\n<hr>\n<h4 id=\"循环边\"><a href=\"#循环边\" class=\"headerlink\" title=\"循环边\"></a>循环边</h4><p>首尾相接的边</p>\n<p>根据四边面插入<br>如果碰到三角面或五边面时可以去掉或加入一条边，然后插入。</p>\n<h4 id=\"环形边\"><a href=\"#环形边\" class=\"headerlink\" title=\"环形边\"></a>环形边</h4><p>互相平行不相交的线<br>循环边是在环形边上插入的，相当于在环形边上架“桥梁”</p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><ul>\n<li>删除历史：编辑-按类型删除-历史<h3 id=\"材质\"><a href=\"#材质\" class=\"headerlink\" title=\"材质\"></a>材质</h3>添加材质：右键选择添加新材质/在Hypershade里添加<br>对象模式下选中模型，然后右键选择材质球将XXX指定给当前选择<br>或按住鼠标右键然后将材质球拖给模型。<br>hypershade在窗口-渲染编辑器</li>\n</ul>\n<h4 id=\"对称选择\"><a href=\"#对称选择\" class=\"headerlink\" title=\"对称选择\"></a>对称选择</h4><p>双击选择工具可以进行对称设置</p>\n<h4 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h4><p>两个开口多边形对应在一起，且拓扑结构一样时，可以用边选择选中，然后再编辑网格-桥接，可以生成新的面和先将其连起来</p>\n<h4 id=\"打组\"><a href=\"#打组\" class=\"headerlink\" title=\"打组\"></a>打组</h4><p>打组有两种方法，一种是选择需要的物体，直接ctrl+g就可以打组，另外一种是依次点击edit-Group来打组。</p>\n<h4 id=\"归零数值\"><a href=\"#归零数值\" class=\"headerlink\" title=\"归零数值\"></a>归零数值</h4><ul>\n<li>在平移/缩放处右键-冻结</li>\n<li>修改-冻结变换</li>\n</ul>\n<h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><p>文件-导出当前选择-在框后面选择obj类型</p>\n<h1 id=\"blender\"><a href=\"#blender\" class=\"headerlink\" title=\"blender\"></a>blender</h1><blockquote>\n<p><a href=\"https://docs.blender.org/manual/zh-hans/dev/getting_started/index.html\">文档</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv10547329\">视图快捷键</a></p>\n<p><a href=\"https://blog.csdn.net/u012204304/article/details/89030370\">快捷键</a></p>\n</blockquote>\n<p>s 缩放</p>\n<p>r 旋转</p>\n<h4 id=\"ctrl-1\"><a href=\"#ctrl-1\" class=\"headerlink\" title=\"ctrl\"></a>ctrl</h4><p>ctrl+Tab  切换编辑模式</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210811105948421-16286507912294.png\" alt=\"image-20210811105948421\"></p>\n<h4 id=\"shift-1\"><a href=\"#shift-1\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>shift+s 吸附游标位置</p>\n<p>游标→中心点 可以让视图以该物体为中心</p>\n<p><strong>取色</strong> 绘制模式下按S  S+点击  放进色板</p>\n<p><strong>隔离模式</strong>  /</p>\n<p><strong>融并</strong> X</p>\n<h1 id=\"数字特效与合成技术\"><a href=\"#数字特效与合成技术\" class=\"headerlink\" title=\"数字特效与合成技术\"></a>数字特效与合成技术</h1><h2 id=\"课时1\"><a href=\"#课时1\" class=\"headerlink\" title=\"课时1\"></a>课时1</h2><h4 id=\"导入文件\"><a href=\"#导入文件\" class=\"headerlink\" title=\"导入文件\"></a>导入文件</h4><ul>\n<li>在节点工作区按R</li>\n<li>直接拖进素材</li>\n<li>左侧Read打开</li>\n</ul>\n<h2 id=\"课时2\"><a href=\"#课时2\" class=\"headerlink\" title=\"课时2\"></a>课时2</h2><h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><p>导入素材后，全选节点按L键可以令其整齐排列</p>\n<h4 id=\"显示图像内容\"><a href=\"#显示图像内容\" class=\"headerlink\" title=\"显示图像内容\"></a>显示图像内容</h4><ul>\n<li>选中某个结点按X（数字）键，可以令viewer产生X号箭头，连接该节点，将上面的画面显示出来</li>\n<li>然后按123即可在不同画面中切换</li>\n</ul>\n<h4 id=\"ProjectSettings\"><a href=\"#ProjectSettings\" class=\"headerlink\" title=\"ProjectSettings\"></a>ProjectSettings</h4><blockquote>\n<p>在结点编辑区按S</p>\n</blockquote>\n<h5 id=\"帧速率\"><a href=\"#帧速率\" class=\"headerlink\" title=\"帧速率\"></a>帧速率</h5><ul>\n<li>电影：24帧</li>\n<li>短视频：25帧<h5 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h5></li>\n</ul>\n<hr>\n<h3 id=\"结点\"><a href=\"#结点\" class=\"headerlink\" title=\"结点\"></a>结点</h3><blockquote>\n<p>选中结点后按D键可以将该节点的作用删除</p>\n</blockquote>\n<h5 id=\"Merge合成结点\"><a href=\"#Merge合成结点\" class=\"headerlink\" title=\"Merge合成结点\"></a>Merge合成结点</h5><blockquote>\n<p>1.快捷键M<br>2.从工具架中选择merge<br>3.右键选择merge<br>4.tab键搜索结点名称</p>\n</blockquote>\n<ul>\n<li>用来合成两个素材</li>\n<li>A输入盖在B输入上面，再连输出到viewer</li>\n<li>选中两个结点按住Shift，再按M可以快速将两个结点合成起来，但是要注意顺序，在前面选择的是A输入。</li>\n</ul>\n<h5 id=\"Premult预乘结点\"><a href=\"#Premult预乘结点\" class=\"headerlink\" title=\"Premult预乘结点\"></a>Premult预乘结点</h5><p> 处理背景有一层灰的图像，相当于将内容抠出来</p>\n<h5 id=\"Transform结点\"><a href=\"#Transform结点\" class=\"headerlink\" title=\"Transform结点\"></a>Transform结点</h5><blockquote>\n<p>快捷键T</p>\n</blockquote>\n<h5 id=\"Blur结点\"><a href=\"#Blur结点\" class=\"headerlink\" title=\"Blur结点\"></a>Blur结点</h5><blockquote>\n<p>快捷键B<br>模糊</p>\n</blockquote>\n<h5 id=\"Color结点调色\"><a href=\"#Color结点调色\" class=\"headerlink\" title=\"Color结点调色\"></a>Color结点调色</h5><h5 id=\"Write结点输出图像\"><a href=\"#Write结点输出图像\" class=\"headerlink\" title=\"Write结点输出图像\"></a>Write结点输出图像</h5><h2 id=\"课时3\"><a href=\"#课时3\" class=\"headerlink\" title=\"课时3\"></a>课时3</h2><ul>\n<li>三基色</li>\n<li>三原色<h5 id=\"xyY色度图\"><a href=\"#xyY色度图\" class=\"headerlink\" title=\"xyY色度图\"></a>xyY色度图</h5><blockquote>\n<p>横坐标0-1<br>马蹄形</p>\n</blockquote>\n<h5 id=\"色域（gamut）\"><a href=\"#色域（gamut）\" class=\"headerlink\" title=\"色域（gamut）\"></a>色域（gamut）</h5><blockquote>\n<p>要精确表示某种颜色必须要有一个框架，这个框架反映在色度图中就是色域。<br>需要RGB三基色和白点的色度坐标值<br>表示某种设备或标准所能描述的颜色范围，一般为三角形。</p>\n</blockquote>\n</li>\n</ul>\n<p>电脑显示器：sRGB色域，和ITU-709色域差不多</p>\n<p>显示器：Rec.709<br>电影院：P3色域<br>超高清电视：Rec.2020</p>\n<h5 id=\"伽马校正\"><a href=\"#伽马校正\" class=\"headerlink\" title=\"伽马校正\"></a>伽马校正</h5><p>自然界：1:1正比例的转换关系<br>摄像机：在处理时向上凹（伽马校正），为了抵销电视CRT处理时的伽马特性（向下凹）<br>最后还原为正比。<br>gamma曲线是一个幂函数</p>\n<ul>\n<li>电脑屏幕自带一个2.2的gamma</li>\n</ul>\n<h5 id=\"nuke对图像的处理-色彩管理\"><a href=\"#nuke对图像的处理-色彩管理\" class=\"headerlink\" title=\"nuke对图像的处理-色彩管理\"></a>nuke对图像的处理-色彩管理</h5><p>nuke在显示图像时，以sRGB显示，给了图像一个向上的曲线，以抵销电脑显示器的向下的曲线。</p>\n<h2 id=\"课时4\"><a href=\"#课时4\" class=\"headerlink\" title=\"课时4\"></a>课时4</h2><h4 id=\"RGBA通道\"><a href=\"#RGBA通道\" class=\"headerlink\" title=\"RGBA通道\"></a>RGBA通道</h4><h5 id=\"Shuffle-Copy结点\"><a href=\"#Shuffle-Copy结点\" class=\"headerlink\" title=\"Shuffle Copy结点\"></a>Shuffle Copy结点</h5><p>有两个输入<br>可以定义不同通道的来源</p>\n<h5 id=\"Shuffle结点\"><a href=\"#Shuffle结点\" class=\"headerlink\" title=\"Shuffle结点\"></a>Shuffle结点</h5><p>有一个输入</p>\n<blockquote>\n<p>功能：层与层之间信息的转换<br>按住shift再按shuffle可以独立地添加shuffle结点</p>\n</blockquote>\n<h2 id=\"课时5\"><a href=\"#课时5\" class=\"headerlink\" title=\"课时5\"></a>课时5</h2><h5 id=\"Grade结点\"><a href=\"#Grade结点\" class=\"headerlink\" title=\"Grade结点\"></a>Grade结点</h5><p>调节gamma值（亮度）</p>\n<h5 id=\"Roto结点\"><a href=\"#Roto结点\" class=\"headerlink\" title=\"Roto结点\"></a>Roto结点</h5><p>可用来画色块</p>\n<h2 id=\"课时6\"><a href=\"#课时6\" class=\"headerlink\" title=\"课时6\"></a>课时6</h2><h5 id=\"RotoPaint结点\"><a href=\"#RotoPaint结点\" class=\"headerlink\" title=\"RotoPaint结点\"></a>RotoPaint结点</h5><p>快捷键P<br>output默认为rgba</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-06-快捷键等小tips\\image-20210809163653261-16284982158371.png\" alt=\"image-20210809163653261\"></p>\n<h5 id=\"defocus-景深\"><a href=\"#defocus-景深\" class=\"headerlink\" title=\"defocus 景深\"></a>defocus 景深</h5><h2 id=\"课时8\"><a href=\"#课时8\" class=\"headerlink\" title=\"课时8\"></a>课时8</h2><h5 id=\"crop结点-修改包围盒大小\"><a href=\"#crop结点-修改包围盒大小\" class=\"headerlink\" title=\"crop结点 修改包围盒大小\"></a>crop结点 修改包围盒大小</h5><h4 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h4><p>按住ctrl再按鼠标左键复位</p>\n<h2 id=\"课时9\"><a href=\"#课时9\" class=\"headerlink\" title=\"课时9\"></a>课时9</h2><h5 id=\"取色\"><a href=\"#取色\" class=\"headerlink\" title=\"取色\"></a>取色</h5><p>先选吸管，再按ctrl+shift  鼠标点击取色</p>\n<h5 id=\"Primatte抠像\"><a href=\"#Primatte抠像\" class=\"headerlink\" title=\"Primatte抠像\"></a>Primatte抠像</h5><p>点Auto-compute</p>\n<h5 id=\"Shuffle结点-1\"><a href=\"#Shuffle结点-1\" class=\"headerlink\" title=\"Shuffle结点\"></a>Shuffle结点</h5><p>将primatte抠出来的alpha通道提取出来</p>\n<h5 id=\"HueCorrect-抑制背景色，调节颜色\"><a href=\"#HueCorrect-抑制背景色，调节颜色\" class=\"headerlink\" title=\"HueCorrect 抑制背景色，调节颜色\"></a>HueCorrect 抑制背景色，调节颜色</h5><h5 id=\"Dilate-收边\"><a href=\"#Dilate-收边\" class=\"headerlink\" title=\"Dilate 收边\"></a>Dilate 收边</h5>"},{"title":"2021-07-30-3d辅助作画尝试","date":"2021-07-29T23:09:04.000Z","created_at":true,"aplayer":true,"_content":"# 使用软件\n\nblender\n\nDaz\n\n## 安装Daz\n\n[安装教程](https://blog.csdn.net/weixin_38450652/article/details/105514141)\n\n> 记得要安装Installer manager\n>\n> 安装新的资源时将规定名称的压缩包放入对应的文件夹中，然后安装。\n\n### 安装Daz导入maya插件\n\n从淘宝买了一个支持maya2019版本的插件，直接安装即可。\n\n<!-- more -->\n\n","source":"_posts/2021-07-30-3d辅助作画尝试.md","raw":"---\ntitle: 2021-07-30-3d辅助作画尝试\ndate: 2021-07-30 07:09:04\ncreated_at: true\naplayer: true\ntags:\n  - 3d辅助\n  - Daz\ncategories:\n  - 画画笔记\n---\n# 使用软件\n\nblender\n\nDaz\n\n## 安装Daz\n\n[安装教程](https://blog.csdn.net/weixin_38450652/article/details/105514141)\n\n> 记得要安装Installer manager\n>\n> 安装新的资源时将规定名称的压缩包放入对应的文件夹中，然后安装。\n\n### 安装Daz导入maya插件\n\n从淘宝买了一个支持maya2019版本的插件，直接安装即可。\n\n<!-- more -->\n\n","slug":"2021-07-30-3d辅助作画尝试","published":1,"updated":"2021-08-08T10:01:25.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l5000f3svocxs4cql7","content":"<h1 id=\"使用软件\"><a href=\"#使用软件\" class=\"headerlink\" title=\"使用软件\"></a>使用软件</h1><p>blender</p>\n<p>Daz</p>\n<h2 id=\"安装Daz\"><a href=\"#安装Daz\" class=\"headerlink\" title=\"安装Daz\"></a>安装Daz</h2><p><a href=\"https://blog.csdn.net/weixin_38450652/article/details/105514141\">安装教程</a></p>\n<blockquote>\n<p>记得要安装Installer manager</p>\n<p>安装新的资源时将规定名称的压缩包放入对应的文件夹中，然后安装。</p>\n</blockquote>\n<h3 id=\"安装Daz导入maya插件\"><a href=\"#安装Daz导入maya插件\" class=\"headerlink\" title=\"安装Daz导入maya插件\"></a>安装Daz导入maya插件</h3><p>从淘宝买了一个支持maya2019版本的插件，直接安装即可。</p>\n<span id=\"more\"></span>\n\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"使用软件\"><a href=\"#使用软件\" class=\"headerlink\" title=\"使用软件\"></a>使用软件</h1><p>blender</p>\n<p>Daz</p>\n<h2 id=\"安装Daz\"><a href=\"#安装Daz\" class=\"headerlink\" title=\"安装Daz\"></a>安装Daz</h2><p><a href=\"https://blog.csdn.net/weixin_38450652/article/details/105514141\">安装教程</a></p>\n<blockquote>\n<p>记得要安装Installer manager</p>\n<p>安装新的资源时将规定名称的压缩包放入对应的文件夹中，然后安装。</p>\n</blockquote>\n<h3 id=\"安装Daz导入maya插件\"><a href=\"#安装Daz导入maya插件\" class=\"headerlink\" title=\"安装Daz导入maya插件\"></a>安装Daz导入maya插件</h3><p>从淘宝买了一个支持maya2019版本的插件，直接安装即可。</p>","more":""},{"title":"2021-08-14-天使坠落绘画过程记录","date":"2021-08-14T12:14:05.000Z","_content":"\n# 绘制过程\n\n先放一下成图：\n\n![fgj740.md.png](https://z3.ax1x.com/2021/08/15/fgj740.md.png)\n\n## 草稿\n\n这次想画天使（无防备地）躺在落着花朵的地上的场景。\n\n先大概起草一下脑补的样子，因为想画一张竖幅的图，所以把腿缩起来方便让全身入画。\n\n<!-- more -->\n\n>  这里pose怎么摆研究了很久但还是有点奇怪.......\n>\n>  天使就应该光脚！\n\n![fgjRgS.md.png](https://z3.ax1x.com/2021/08/15/fgjRgS.md.png)\n\n## 线稿\n\n由于要强化睡着时的**无防备感**，所以把草稿时闭着的嘴改成了张嘴。\n\n![fgjyNt.md.png](https://z3.ax1x.com/2021/08/15/fgjyNt.md.png)\n\n## 铺色\n\n先用大色块+正片叠底图层铺一下大致的光影效果，细化时心里比较有数。\n\n> 这个时候光影还有很多问题，就是大致看一下效果。\n\n![fgjOvF.md.png](https://z3.ax1x.com/2021/08/15/fgjOvF.md.png)\n\n## 细化\n\n为了表现圣洁感，不打算给肤色做太多强调。另外全身衣服都是黑色的，所以整体的固有色基本是黑白两种颜色。因此直接用黑白上色，之后再用渐变映射统一色调。\n\n>  第一次直接画黑白稿，必须用明度来把物体区分出来不然就会糊在一起....\n\n![fgjLgU.md.png](https://z3.ax1x.com/2021/08/15/fgjLgU.md.png)\n\n胸前的链子直接通过修改ps的笔刷设置，把硬边圆头笔的间距拉大即可。然后添加一下描边和内阴影的图层效果，就可以直接直接画出珠子。\n\n![image-20210813214857769](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-天使坠落绘画过程记录/image-20210813214857769.png)\n\n## 渐变映射\n\n细化完以后在所有图层上加一个渐变映射的调整图层，然后调一下渐变映射的颜色。\n\n![image-20210813221722505](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-天使坠落绘画过程记录/image-20210813221722505.png)\n\n\n\n![fgjju4.md.png](https://z3.ax1x.com/2021/08/15/fgjju4.md.png)\n\n## 完成\n\n最后加一些彩虹的炫光、模糊和噪点即可！(这里由于图像大小问题，没有放加噪点的版本)\n\n![fgj740.md.png](https://z3.ax1x.com/2021/08/15/fgj740.md.png)\n\n\n\n\n\n","source":"_posts/2021-08-14-天使坠落绘画过程记录.md","raw":"---\ntitle: 2021-08-14-天使坠落绘画过程记录\ndate: 2021-08-14 20:14:05\ntags:\n  - 渐变映射\ncategories:\n  - 画画笔记\n---\n\n# 绘制过程\n\n先放一下成图：\n\n![fgj740.md.png](https://z3.ax1x.com/2021/08/15/fgj740.md.png)\n\n## 草稿\n\n这次想画天使（无防备地）躺在落着花朵的地上的场景。\n\n先大概起草一下脑补的样子，因为想画一张竖幅的图，所以把腿缩起来方便让全身入画。\n\n<!-- more -->\n\n>  这里pose怎么摆研究了很久但还是有点奇怪.......\n>\n>  天使就应该光脚！\n\n![fgjRgS.md.png](https://z3.ax1x.com/2021/08/15/fgjRgS.md.png)\n\n## 线稿\n\n由于要强化睡着时的**无防备感**，所以把草稿时闭着的嘴改成了张嘴。\n\n![fgjyNt.md.png](https://z3.ax1x.com/2021/08/15/fgjyNt.md.png)\n\n## 铺色\n\n先用大色块+正片叠底图层铺一下大致的光影效果，细化时心里比较有数。\n\n> 这个时候光影还有很多问题，就是大致看一下效果。\n\n![fgjOvF.md.png](https://z3.ax1x.com/2021/08/15/fgjOvF.md.png)\n\n## 细化\n\n为了表现圣洁感，不打算给肤色做太多强调。另外全身衣服都是黑色的，所以整体的固有色基本是黑白两种颜色。因此直接用黑白上色，之后再用渐变映射统一色调。\n\n>  第一次直接画黑白稿，必须用明度来把物体区分出来不然就会糊在一起....\n\n![fgjLgU.md.png](https://z3.ax1x.com/2021/08/15/fgjLgU.md.png)\n\n胸前的链子直接通过修改ps的笔刷设置，把硬边圆头笔的间距拉大即可。然后添加一下描边和内阴影的图层效果，就可以直接直接画出珠子。\n\n![image-20210813214857769](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-天使坠落绘画过程记录/image-20210813214857769.png)\n\n## 渐变映射\n\n细化完以后在所有图层上加一个渐变映射的调整图层，然后调一下渐变映射的颜色。\n\n![image-20210813221722505](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-天使坠落绘画过程记录/image-20210813221722505.png)\n\n\n\n![fgjju4.md.png](https://z3.ax1x.com/2021/08/15/fgjju4.md.png)\n\n## 完成\n\n最后加一些彩虹的炫光、模糊和噪点即可！(这里由于图像大小问题，没有放加噪点的版本)\n\n![fgj740.md.png](https://z3.ax1x.com/2021/08/15/fgj740.md.png)\n\n\n\n\n\n","slug":"2021-08-14-天使坠落绘画过程记录","published":1,"updated":"2021-08-17T12:01:01.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l7000g3svog7wh3cnk","content":"<h1 id=\"绘制过程\"><a href=\"#绘制过程\" class=\"headerlink\" title=\"绘制过程\"></a>绘制过程</h1><p>先放一下成图：</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgj740.md.png\" alt=\"fgj740.md.png\" loading=\"lazy\"></p>\n<h2 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h2><p>这次想画天使（无防备地）躺在落着花朵的地上的场景。</p>\n<p>先大概起草一下脑补的样子，因为想画一张竖幅的图，所以把腿缩起来方便让全身入画。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> 这里pose怎么摆研究了很久但还是有点奇怪…….</p>\n<p> 天使就应该光脚！</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjRgS.md.png\" alt=\"fgjRgS.md.png\" loading=\"lazy\"></p>\n<h2 id=\"线稿\"><a href=\"#线稿\" class=\"headerlink\" title=\"线稿\"></a>线稿</h2><p>由于要强化睡着时的<strong>无防备感</strong>，所以把草稿时闭着的嘴改成了张嘴。</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjyNt.md.png\" alt=\"fgjyNt.md.png\" loading=\"lazy\"></p>\n<h2 id=\"铺色\"><a href=\"#铺色\" class=\"headerlink\" title=\"铺色\"></a>铺色</h2><p>先用大色块+正片叠底图层铺一下大致的光影效果，细化时心里比较有数。</p>\n<blockquote>\n<p>这个时候光影还有很多问题，就是大致看一下效果。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjOvF.md.png\" alt=\"fgjOvF.md.png\" loading=\"lazy\"></p>\n<h2 id=\"细化\"><a href=\"#细化\" class=\"headerlink\" title=\"细化\"></a>细化</h2><p>为了表现圣洁感，不打算给肤色做太多强调。另外全身衣服都是黑色的，所以整体的固有色基本是黑白两种颜色。因此直接用黑白上色，之后再用渐变映射统一色调。</p>\n<blockquote>\n<p> 第一次直接画黑白稿，必须用明度来把物体区分出来不然就会糊在一起….</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjLgU.md.png\" alt=\"fgjLgU.md.png\" loading=\"lazy\"></p>\n<p>胸前的链子直接通过修改ps的笔刷设置，把硬边圆头笔的间距拉大即可。然后添加一下描边和内阴影的图层效果，就可以直接直接画出珠子。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-%E5%A4%A9%E4%BD%BF%E5%9D%A0%E8%90%BD%E7%BB%98%E7%94%BB%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20210813214857769.png\" alt=\"image-20210813214857769\" loading=\"lazy\"></p>\n<h2 id=\"渐变映射\"><a href=\"#渐变映射\" class=\"headerlink\" title=\"渐变映射\"></a>渐变映射</h2><p>细化完以后在所有图层上加一个渐变映射的调整图层，然后调一下渐变映射的颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-%E5%A4%A9%E4%BD%BF%E5%9D%A0%E8%90%BD%E7%BB%98%E7%94%BB%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20210813221722505.png\" alt=\"image-20210813221722505\" loading=\"lazy\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjju4.md.png\" alt=\"fgjju4.md.png\" loading=\"lazy\"></p>\n<h2 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h2><p>最后加一些彩虹的炫光、模糊和噪点即可！(这里由于图像大小问题，没有放加噪点的版本)</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgj740.md.png\" alt=\"fgj740.md.png\" loading=\"lazy\"></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"绘制过程\"><a href=\"#绘制过程\" class=\"headerlink\" title=\"绘制过程\"></a>绘制过程</h1><p>先放一下成图：</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgj740.md.png\" alt=\"fgj740.md.png\"></p>\n<h2 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h2><p>这次想画天使（无防备地）躺在落着花朵的地上的场景。</p>\n<p>先大概起草一下脑补的样子，因为想画一张竖幅的图，所以把腿缩起来方便让全身入画。</p>","more":"<blockquote>\n<p> 这里pose怎么摆研究了很久但还是有点奇怪…….</p>\n<p> 天使就应该光脚！</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjRgS.md.png\" alt=\"fgjRgS.md.png\"></p>\n<h2 id=\"线稿\"><a href=\"#线稿\" class=\"headerlink\" title=\"线稿\"></a>线稿</h2><p>由于要强化睡着时的<strong>无防备感</strong>，所以把草稿时闭着的嘴改成了张嘴。</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjyNt.md.png\" alt=\"fgjyNt.md.png\"></p>\n<h2 id=\"铺色\"><a href=\"#铺色\" class=\"headerlink\" title=\"铺色\"></a>铺色</h2><p>先用大色块+正片叠底图层铺一下大致的光影效果，细化时心里比较有数。</p>\n<blockquote>\n<p>这个时候光影还有很多问题，就是大致看一下效果。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjOvF.md.png\" alt=\"fgjOvF.md.png\"></p>\n<h2 id=\"细化\"><a href=\"#细化\" class=\"headerlink\" title=\"细化\"></a>细化</h2><p>为了表现圣洁感，不打算给肤色做太多强调。另外全身衣服都是黑色的，所以整体的固有色基本是黑白两种颜色。因此直接用黑白上色，之后再用渐变映射统一色调。</p>\n<blockquote>\n<p> 第一次直接画黑白稿，必须用明度来把物体区分出来不然就会糊在一起….</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjLgU.md.png\" alt=\"fgjLgU.md.png\"></p>\n<p>胸前的链子直接通过修改ps的笔刷设置，把硬边圆头笔的间距拉大即可。然后添加一下描边和内阴影的图层效果，就可以直接直接画出珠子。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-%E5%A4%A9%E4%BD%BF%E5%9D%A0%E8%90%BD%E7%BB%98%E7%94%BB%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20210813214857769.png\" alt=\"image-20210813214857769\"></p>\n<h2 id=\"渐变映射\"><a href=\"#渐变映射\" class=\"headerlink\" title=\"渐变映射\"></a>渐变映射</h2><p>细化完以后在所有图层上加一个渐变映射的调整图层，然后调一下渐变映射的颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-14-%E5%A4%A9%E4%BD%BF%E5%9D%A0%E8%90%BD%E7%BB%98%E7%94%BB%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20210813221722505.png\" alt=\"image-20210813221722505\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgjju4.md.png\" alt=\"fgjju4.md.png\"></p>\n<h2 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h2><p>最后加一些彩虹的炫光、模糊和噪点即可！(这里由于图像大小问题，没有放加噪点的版本)</p>\n<p><img src=\"https://z3.ax1x.com/2021/08/15/fgj740.md.png\" alt=\"fgj740.md.png\"></p>"},{"title":"2021-08-09-小学期建造游戏Demo开发笔记（三）","date":"2021-08-09T09:27:17.000Z","password":130024,"_content":"\n# 技术美术部分\n\n### 材质外发光Shader\n\n\n\n\n\n## 卡通渲染Shader\n\n\n\n\n\n# 美术部分\n\n## 使用blender绘制贴图\n\n[视频教程](https://www.bilibili.com/video/BV1w54y187nG/?spm_id_from=333.788.recommend_more_video.-1)\n\n右键该部分，选择垂直切分，出现两个视图。\n\n![image-20210811105137078](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105137078-16286502992751-16286527735535.png)\n\n在一边的视图选择UV编辑器。\n\n![image-20210811105727012](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105727012.png)\n\n切换到编辑模式→按A全选所有定点→点击UV→只能UV投射，按默认选项\n\n![image-20210811105417918](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105417918-16286504605682.png)_编辑模式_\n\n![image-20210811105551654](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105551654-16286505538173.png)\n\n进入纹理绘制模式，然后切换模式为单张图像。新建一张图片。\n\n![image-20210811113341047](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113341047.png)\n\n\n\n![image-20210811113318359](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113318359.png)\n\n然后在实体模式显示的状态下可以看到绘制的内容。但切换到渲染模式则无法看到。\n\n因此我们需要给它添加材质。\n\n进入材质选项卡，添加新的材质，然后修改它的基础色为使用图片纹理，选中之前新建的图片纹理即可。\n\n![image-20210811113700259](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113700259.png)\n\n为了方便观察，切换回实体模式来绘制贴图。\n\n","source":"_posts/2021-08-09-小学期建造游戏Demo开发笔记（三）.md","raw":"---\ntitle: 2021-08-09-小学期建造游戏Demo开发笔记（三）\ndate: 2021-08-09 17:27:17\npassword: 130024\ntags:\n  - Blender贴图绘制\ncategories:\n  - 小学期建造游戏Demo开发笔记 \n---\n\n# 技术美术部分\n\n### 材质外发光Shader\n\n\n\n\n\n## 卡通渲染Shader\n\n\n\n\n\n# 美术部分\n\n## 使用blender绘制贴图\n\n[视频教程](https://www.bilibili.com/video/BV1w54y187nG/?spm_id_from=333.788.recommend_more_video.-1)\n\n右键该部分，选择垂直切分，出现两个视图。\n\n![image-20210811105137078](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105137078-16286502992751-16286527735535.png)\n\n在一边的视图选择UV编辑器。\n\n![image-20210811105727012](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105727012.png)\n\n切换到编辑模式→按A全选所有定点→点击UV→只能UV投射，按默认选项\n\n![image-20210811105417918](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105417918-16286504605682.png)_编辑模式_\n\n![image-20210811105551654](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105551654-16286505538173.png)\n\n进入纹理绘制模式，然后切换模式为单张图像。新建一张图片。\n\n![image-20210811113341047](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113341047.png)\n\n\n\n![image-20210811113318359](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113318359.png)\n\n然后在实体模式显示的状态下可以看到绘制的内容。但切换到渲染模式则无法看到。\n\n因此我们需要给它添加材质。\n\n进入材质选项卡，添加新的材质，然后修改它的基础色为使用图片纹理，选中之前新建的图片纹理即可。\n\n![image-20210811113700259](D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113700259.png)\n\n为了方便观察，切换回实体模式来绘制贴图。\n\n","slug":"2021-08-09-小学期建造游戏Demo开发笔记（三）","published":1,"updated":"2021-08-29T08:42:01.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l8000k3svo9399dzvk","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"5c1c14d06457faba1a4c16ddbd588fe07ee6f629a3bb34cdb72fa4d68287f994\">3e465fd97ca21e2c34553ed0afce514fcb9240ca5512951300ea0d6ae8a4e1a12208d7459f22c6078d2664896667336c875b1c846a3a67a35a3c7c4e4a71efbb5aac840655ae4310ad544182fca03de7155403c3dd91e96cc2e83b77947001be2d293477c569ca87b8967ae7b7f85f62488fd4e5dcf6ebca8f7389e729298c288ee88dcf9f30eb6c35217eb7ac242a1039c8ef3ff87c50c612a1937e14fa0ecd7d9b1a8a57f54976f88349a8c94d8dba28924b5dc1d0848d32f47654e03cdce188f62068dc762a479387177f44bf35241981d5e89fea0fb4c40da80ba4b910f11b74005896cfd81cd6e259ee1c22b3ef85415c8a290b15dd538079e6f3c6573c1eec64f3cfd0d2c5f7aaeeea62d60381fd4235063567df774cd960bf7013b22feba27bb9a86a3c9c039854e15110165f0fa384b2a466bea40fb5a81a98197bfac30142e768666425f0c83baaad8f2b6b2dfb4e7b07cddd3f4fc4bc97d698cafc88fb54f5ef41d03f69553ecde8ac0465b37efb5920426c3ddfa6d7b98ceb1f45df75e102352e803968ed27a0f213d9b428d68c0cbe282b8d0c5214fa4e81146690119f2da9b8cf3fa6c0bbe259f4b022f1c359875b3e4d2512f3710daa8aef40a2279b42a878e4c967479e4a247bb11f6ae77513bdcfedcf88b8e4894076105a3fea5c7f7f294cfd48cfb511f77fcee7144c3f752c7e5a370ba05bd7cacb9a9d24e8c1c306bde28ea7dedbd6721cdae01f74bfefee3c26fba7fd6eda7a733c193b080ca22be2c1fdc0516495d39f2d7cfde2d8f0825b9c01456f6bfcbf7c114e9985cfef4f730057163586227678d4e9d03c91811a6867469440012b806879cb0e5fb2ea0b0a08ca993c93b6932b0b2d33c7710329e339976fff5a9f05c76893e7b8072b3eb71435dbc85ea1dbb0c5dee92cdf22d3ad41a4508cc72802ccd2a11575283037c58ba4d277cbe65e5e6f1ebfc21248698bf9f209fd52daf3a25008d04e21b72aed68d6a2d7d3620a1cb7cf85dced1db9c6e3d9f5b716701b90229a8cb656bee4a30d53cdcad2b662f3e1ed52fafa9584d1a40047d183b66c84184327eb1d133597507c4fdcbb14d256aff2b0c3cdde8739620c5cd828d43017896dfcd346f10d59d04a862360635e056770cb41d5ed19425bfaa56e4d240b8f8fcd3d39f1ec9043f869350da4efa4dea3d248d46caef5c90e1e14a9be5dc9cd07354758e685f26b3a1dc900c090420c9da9839dc22babf801b8b06de792d9aa89af1f54277f08c7e6c42d107527078a76efade3e7a9be21fe14f6124b7bd68d2964fa35811b17152751d280df853711171abad1b1bfe3a19731320bf6b38a81d07e7e98604b0d090715d1267aa71a003edf857efec7a17f3df4f215913854e488dcc7d7ff05c8de9aa57b93e4ca4516df3464d48e730d66bbc617bee6cc2ee707dbc118859391b0375b707346d6f612ef71d23047d0ce4c076d3f1b66e2d7982c594feddf32df74b8059435c728a0defeeb81f59d123d81e910d60d398bc7a153cf46df81d22ca700c7c5b8845eed39c3688072307175e6ab23b350d36089c242f61523d1f611989ee28c8a65f22f3c89b7bc736bfcb3ea017b6ad1e05d41a1ad6f6d16d5d2470de7acfc813612c13b88e58f237a39df8fb44c8d518ef1ffaa3658d946ee3d74f1e0bc4a167056f81a137dec21701d5e99a58dbfdc40d71b5335c938e753e03ee404dc9645bb35f58b614003162549b6a8ae7c4e69790f560bac85ae6078e79b37be21a6f4b672514c6dd988f6ad8ebf70a53eb3a53a5d106df1c8d70e95988807939a5e273bbedef6c073424cb5cba55b49fb5345b4d463bd11af861b63ad16901c594b85161e898a8ce613953ab47d8021fec1b5f5e6d38b9fa412dfda455c80be1c24788d88621fbcb31e068cf25a9cf7d9dbe66a0eadbe447f17d03e7b952a0c6796691a896576362cae044acc0b08330c876f35b70affc3f7bf6cf86c59388428cd384e6ae8abb9c26ba37429e5d9ac6a9e1ac3bfb185620dd9ba58a62dea33953df813d4d163a0b79a29e790802f3329a508303e71ac9f170ce2e415269fbaa030e356af0e433842785bb6611b9f98d769bdf823b1b272476d6ab3039a7434076d4f83b0a67502ef6990c58027565088d4300ca1443cccb6407774582c68f126f7f9bf7eb2172fda32898b89d17dacb7f6e977ef5bb73f6365b8761ee8fec30e8fd95bb565603a10d144d6077cf776125c0fdca9cfb1b5263d8369750f7ccd9b1a9f9f8b6f7eaccfbfcceac7efb604753923ffe8aa6e75483b9f44e9e668d49dcaca0c13656bb39b15e59a8111b3dfe00191030abc74834cf048ac317c529e90f6f5095e2a72c5f88ceb0e9779e9e99a72515933a85914c34c586d933174b1787145ba19ac52dd2d908b79ab1bff69fb8a4412073f931507f709cb6608e4ef5950fb334d3f8b24d5df491bdf7d3d943b8da910cb6c4c1cb473224b0d5fbcfab5c0d634a14dee71384451530d5861e922d7fbcb08dd91734db618837ea7856ae130d910ce918619c645b45765a7a2bf5a5c1accad2b27c37411ee51ece7546a667dd281cddc5bb2cfc104a259afbce07bba8ed5660a9848c1e32f77fbeae082cee314367159261b5234c759dfa5a62e83fafece4fb059d6642edfbca7713ba1856b17caf00be8163ed35359b69f27115f4a45328c12ee038edd9b709faa007957f3d5361be83e632c5c3a407c1cfaacaa6993246dc65ffc27460427e84273d90ef704439ecf02ddbd3932ccbbac2e3c79845a78df286016bf95b7981f55ab383ea5f4b5a69307c612a1810af1aa24a2c6b98be3c26ebfb3a77f098e516ac617b1d267f1611ad34184912cd67057bae955a4561d8b628675a1399e01934bf158eaa8603cf689ba5b3a9ac95bf518bcac95b28ecaf3af04c4ebf8ac37950d7461a125498e61fe5819ee195534e1ec8023410fa3d581db4bac2e7fafee8aa632435cae8c48df4e589ce0f04accbdd4a6b7515d3051e59679e8ffcd39da6e7c73ff6b5afd5c562d76be221ffe2761162f0c72cce63ca26df47ebc647a44ad709811bcbe09f147b4d40c8755940a804bd4aee367d289fd0bfd555b1d446a4a46a9e78517fb4dbf14bcdbab62ae303266c50f7d210811d58a9bf82807505766f7203af1badad8b9a5168421f5f6661c3001947215110261a420b1132a367ef95962a46b37954160db90cef85cf6c6837785e0499f4821b4a9107ef7808d7a87c7a1fd41b4063e66d293719a7d95ddddefbfce7fe63f52fac7fa0385cf574d0482000a8f476771e63b3ac91953c29fd5a6bd870333e4d13ee4e6f97205263e070e9ae7a04c49e36766c3f2025d6d8ce065e630e8d620323022fef30a4bfc2e7bb83cadf68039f539da3710c990cc6e3e61b577f94fea06eb37eea5c248fc6fd01c41c5231f2ddd1b15951ee7202761b78a0e67804f3d9777c1d25705aa82ab55249ec9edc6660fe159485df555c3af1835672c0a4a85430dfa1f36479bd59ac089d2599b79c4359d08feac013a48c102c3f86fa1ee5bd70097967a784916baafb9c4e052cd9fce0e933303489703e93a24d2bd6ef2b819d3404b28a1361ad432a54fa3c1fab5236e6907afd17f596f739efce98845a92965e73b138472a57abb8e8aed835238c40b371772e87395895bc04e4c33fa61e6a81c8a96b950256be5fd5d372a2b9511367532d5697ddb7e23e7992d71372d3318845c7a147bf1999ce9052e82401c60b4dff65494eb4ef9f6fcee578255097ba15855b6358dfaab8f6fe33ac0210e78fb6a754109651c280bf01d4b4c1df0bd8de56091fb418f5cb2956598e48589429b79df00490145cbab6d943e72c717fa7bb0fcb964f631226f17e89516bf711ffc4a598c2e4de98e069f4e5e3ed9edb0328fbcd08f</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Hey, password is required here.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<h1 id=\"技术美术部分\"><a href=\"#技术美术部分\" class=\"headerlink\" title=\"技术美术部分\"></a>技术美术部分</h1><h3 id=\"材质外发光Shader\"><a href=\"#材质外发光Shader\" class=\"headerlink\" title=\"材质外发光Shader\"></a>材质外发光Shader</h3><h2 id=\"卡通渲染Shader\"><a href=\"#卡通渲染Shader\" class=\"headerlink\" title=\"卡通渲染Shader\"></a>卡通渲染Shader</h2><h1 id=\"美术部分\"><a href=\"#美术部分\" class=\"headerlink\" title=\"美术部分\"></a>美术部分</h1><h2 id=\"使用blender绘制贴图\"><a href=\"#使用blender绘制贴图\" class=\"headerlink\" title=\"使用blender绘制贴图\"></a>使用blender绘制贴图</h2><p><a href=\"https://www.bilibili.com/video/BV1w54y187nG/?spm_id_from=333.788.recommend_more_video.-1\">视频教程</a></p>\n<p>右键该部分，选择垂直切分，出现两个视图。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105137078-16286502992751-16286527735535.png\" alt=\"image-20210811105137078\" loading=\"lazy\"></p>\n<p>在一边的视图选择UV编辑器。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105727012.png\" alt=\"image-20210811105727012\" loading=\"lazy\"></p>\n<p>切换到编辑模式→按A全选所有定点→点击UV→只能UV投射，按默认选项</p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105417918-16286504605682.png\" alt=\"image-20210811105417918\" loading=\"lazy\"><em>编辑模式</em></p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811105551654-16286505538173.png\" alt=\"image-20210811105551654\" loading=\"lazy\"></p>\n<p>进入纹理绘制模式，然后切换模式为单张图像。新建一张图片。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113341047.png\" alt=\"image-20210811113341047\" loading=\"lazy\"></p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113318359.png\" alt=\"image-20210811113318359\" loading=\"lazy\"></p>\n<p>然后在实体模式显示的状态下可以看到绘制的内容。但切换到渲染模式则无法看到。</p>\n<p>因此我们需要给它添加材质。</p>\n<p>进入材质选项卡，添加新的材质，然后修改它的基础色为使用图片纹理，选中之前新建的图片纹理即可。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\20210-08-09-小学期建造游戏Demo开发笔记（三）\\image-20210811113700259.png\" alt=\"image-20210811113700259\" loading=\"lazy\"></p>\n<p>为了方便观察，切换回实体模式来绘制贴图。</p>\n","encrypt":true},{"title":"2021-08-15-庄懂的技术美术入门课学习笔记（一）","date":"2021-08-15T11:31:53.000Z","katex":true,"_content":"\n# 开始学习\n\n[视频链接](https://space.bilibili.com/6373917/video)\n\n[Shader Forge中文文档](https://acegikmo.com/shaderforge/nodes/?lang=zh_cn)\n\n\n\n<!-- more -->\n\n> 对应课程0~3课内容\n\n## 光照模型\n\n### Lambert光照模型\n\n根据向量点乘的图形学含义，令\n\n- 模型表面的垂直方向为向量nDir（法线方向）\n\n- 光照方向的反方向为向量lDir\n\n- 输出nDir·lDir的结果为下图的光照表现：\n\n  ![image-20210815210059777](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815210059777.png)\n\n其中明暗交接处之后的（即点积小于0的部分）都为纯黑色。由于负数是无意义的光照，把负数部分都取0，即为Lambert光照模型。\n\n![image-20210815210900380](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815210900380.png)\n\n#### ShaderForge实现\n\n上述公式，两个向量点乘，输出到Emission上。然后用Clamp结点来限制一下范围0-1\n\n![image-20210815212830722](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815212830722.png)\n\n#### 代码实现\n\n```c#\n\t\t\tstruct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n```\n\n完整代码：\n\n<details>\n  <summary>LambertShader.shader</summary>\n\n```c#\nShader \"Class1/LambertShader\" {\n    Properties {\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n### 半Lambert光照模型\n\nLambert在明暗交界线后的部分是死黑的，半Lambert模型就是整体*0.5+0.5,让暗部显得更透气，但这样没有了明暗交界线。\n\n![image-20210815211247604](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815211247604.png)\n\n#### ShaderForge实现\n\n把点乘的结果用multiply*0.5再add0.5\n\n![image-20210815213237161](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815213237161.png)\n\n## 调子映射\n\n![image-20210815213947360](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815213947360.png)\n\nShaderForge：\n\n在上面半Lambert模型的基础上，把输出的点乘结果和另一个常量通过Append结点结合成一个向量。这样可以得到一个uv坐标，对输入的RampTex图像文件根据该坐标采样，即可输出上面的映射后结果。\n\n![image-20210815214138597](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815214138597.png)\n\n\n\n## 应用\n\n### 卡通渲染效果\n\n> 在最亮部可能出现暗点，需要把贴图的Wrap Mode修改为Clamp而不是Repeat。\n>\n> 目前的描边会有比较明显的锯齿，卡渲一般会加抗锯齿后处理。\n\n![image-20210815221158922](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815221158922.png)\n\n### 次表面散射效果（SSS效果）\n\n> 次表面散射(Sub-Surface-Scattering)简称3S，用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。\n>\n> 主要用于模拟不完全透明材质内部表现出来的一种真实光影特效次表面散射材质是高质量渲染中最复杂的材质之一，次表面反射一般是在半透明的材质上表现最为明显，如蜡烛、大理石、玉石、等上表现最为明显。我们知道，当灯光照射到玻璃或清澈的液体表面时，灯光会穿透这些介质，[菲涅尔反射](https://baike.baidu.com/item/菲涅尔反射/6556664)的3S效果可用来模拟灯光进入介质内部后发生的散射。最典型的就是一根点亮的蜡烛，仔细观察你会[发现](https://baike.baidu.com/item/发现/75066)在烛光的照耀下，蜡烛靠近火焰的那端显出的半透明效果。实际上，3S的最大用处之一在于表现灯光照射下的人的皮肤。\n\n\n\n上面的调子映射的v坐标采样值直接用了一个常数，即RampTex的上下没有变化。\n\n若我们让RampTex的上下有变化，然后用一个Slider来调节v坐标采样的值，则可以实现光穿透效果的平滑变化。\n\n![image-20210816202038366](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816202038366.png)\n\n\n\n### 玉石效果\n\n底色部分同上。\n\n**1. 一个高光点**：\n\n同样提取点积的结果后，在输出时加一个if结点，输入A，B为一个参数阈值，当A>B时输出1，小于时输出0，则可以得到高光点。\n\n![image-20210816103327816](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816103327816.png)\n\n\n\n**2. 两个高光点**：\n\n给lDir加一个参数偏移向量，即光照方向的偏移值，再做点积。最后把两个If输出的结果用Max结点合起来再用Clamp结点来限制范围在0-1内。\n\n\n\n**3. 把高光和底色合起来**：\n\n用Lerp结点。\n\nLerp结点的意思：相当于ps里的两个图层，A在B上面，然后给A加一个蒙版。但在Lerp中黑白和这里的蒙版相反，即T中白色的部分露出B结点的颜色。\n\n![image-20210816104447153](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816104447153.png)\n\n![image-20210816105416138](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816105416138.png)\n\n关键部分的结点连接：\n\n![image-20210816105608144](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816105608144.png)\n\n**4. 菲涅耳结点：**\n\n>*什么是菲涅耳效应？*\n>\n>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。\n>\n>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？\n>\n>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：\n>\n>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)\n\n给材质添加菲涅耳效果：\n\n记得在Exp输入中给一个常量，然后用Multiply结点给它乘一个颜色。然后用Blend结点把上面得到的结果和菲涅耳效果叠加（Screen处的下拉选项为叠加方式）\n\n![image-20210816112113052](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816112113052.png)\n\n最后效果：\n\n![image-20210816121532159](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816121532159.png)\n\n### 条纹排线效果\n\n**1.屏幕坐标**\n\n直接根据屏幕坐标取UV，则uv直接根据屏幕大小来展平，不会随着物体的放大缩小旋转而改变。\n\n若乘一个深度Depth结点，则uv会根据物体的深度而变化。\n\n**2.step结点**\n\n和if类似，若A<=B，则输出1，否则输出0。\n\n上面两步的效果如下：使用点乘的结果输入step的B输入，则<0，即暗部完全为黑色，中间为条纹，亮部为白色。\n\n![image-20210816123439908](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816123439908.png)\n\n**3. 添加颜色**\n\n使用Lerp结点添加一个亮部颜色和一个暗部颜色，然后用上面获得的黑白结果做蒙版遮罩即可。相当于把上面的黑色替换为A输入，白色替换为B输入。\n\n最后可以给一个模型的基础颜色再和上面的结果相加，做一个比较平滑的颜色效果。\n\n![image-20210816124408419](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816124408419.png)\n\n### Halftone半色调效果\n\n**1. 生成点阵纹理**\n\n获取屏幕坐标，然后乘一个较大的值20，利用Frac结点取余得到一个比较密集的条纹形状。\n\n然后使用Remap进行重映射到-0.5到0.5，再使用length结点得到一个密集的有渐变的点阵图像。length结点的公式如下：输入两个分量a和b，输出\n$$\na^2+b^2=c^2\n$$\n![image-20210816161533779](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816161533779.png)\n\n>  注意如果不进行重映射到-0.5到0.5，则生成的图像为一个四分之一圆形：\n>\n> ![image-20210816162045714](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816162045714.png)\n\n**2. 结合lambert光照模型**\n\n获取法向量和光线方向向量点积的值，然后做一个重映射，从1-0重映射到-0.5-2。\n\n> 注意这里原本是1-0，也就是说把亮部映射到负值，暗部映射到正值。因为对于亮部来说，不管上面length后得到的点阵图取0-1内的任何值，它的负数次幂都大于1。即亮部会呈现为全白，不会有点阵。\n>\n> 对于暗部，假设映射到1-2范围内的部分映射后取值为a，对于任何0-1的数的a次幂的结果均会比原来的取值更小，当小于0.5时四舍五入取整后这部分则为全黑。\n\n然后使用**Power结点**，把重映射的结果输入Exp。\n\n> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。\n\n![image-20210816164734797](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816164734797.png)_Power结点公式_\n\n然后用round结点把渐变部分取整变成黑白即可。\n\n![image-20210816165823653](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816165823653.png)\n\n\n\n### 参数面板\n\n创建一个模拟平行光（输入参数为光线方向、颜色、强度）\n\n![image-20210816200645649](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816200645649.png)\n\n\n\n### 风格化-把暗部做三层分离\n\n输入一个可调节的参数vector4，然后将点积的结果和vector4的XYZ三个通道用step结点进行对比，可以得到三个分层的亮部遮罩。\n\n![image-20210816203911475](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816203911475.png)\n\n然后可以将上面得到的结果作为遮罩，然后分别给亮部和暗部一个颜色。\n\n![image-20210816211440348](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816211440348.png)\n\n\n# 情报\n\n## Lut图\n\n![image-20210816215734597](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816215734597.png)\n\n## Houdini\n\n\n\n![image-20210816220236911](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816220236911.png)\n","source":"_posts/2021-08-15-庄懂的技术美术入门课学习笔记（一）.md","raw":"---\ntitle: 2021-08-15-庄懂的技术美术入门课学习笔记（一）\ndate: 2021-08-15 19:31:53\nkatex: true\ntags:\n  - 光照模型\n  - Lambert\n  - 卡通渲染\n  - 半色调Halftone\n  - 3S效果\n  - 菲涅尔\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n# 开始学习\n\n[视频链接](https://space.bilibili.com/6373917/video)\n\n[Shader Forge中文文档](https://acegikmo.com/shaderforge/nodes/?lang=zh_cn)\n\n\n\n<!-- more -->\n\n> 对应课程0~3课内容\n\n## 光照模型\n\n### Lambert光照模型\n\n根据向量点乘的图形学含义，令\n\n- 模型表面的垂直方向为向量nDir（法线方向）\n\n- 光照方向的反方向为向量lDir\n\n- 输出nDir·lDir的结果为下图的光照表现：\n\n  ![image-20210815210059777](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815210059777.png)\n\n其中明暗交接处之后的（即点积小于0的部分）都为纯黑色。由于负数是无意义的光照，把负数部分都取0，即为Lambert光照模型。\n\n![image-20210815210900380](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815210900380.png)\n\n#### ShaderForge实现\n\n上述公式，两个向量点乘，输出到Emission上。然后用Clamp结点来限制一下范围0-1\n\n![image-20210815212830722](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815212830722.png)\n\n#### 代码实现\n\n```c#\n\t\t\tstruct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n```\n\n完整代码：\n\n<details>\n  <summary>LambertShader.shader</summary>\n\n```c#\nShader \"Class1/LambertShader\" {\n    Properties {\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n### 半Lambert光照模型\n\nLambert在明暗交界线后的部分是死黑的，半Lambert模型就是整体*0.5+0.5,让暗部显得更透气，但这样没有了明暗交界线。\n\n![image-20210815211247604](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815211247604.png)\n\n#### ShaderForge实现\n\n把点乘的结果用multiply*0.5再add0.5\n\n![image-20210815213237161](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815213237161.png)\n\n## 调子映射\n\n![image-20210815213947360](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815213947360.png)\n\nShaderForge：\n\n在上面半Lambert模型的基础上，把输出的点乘结果和另一个常量通过Append结点结合成一个向量。这样可以得到一个uv坐标，对输入的RampTex图像文件根据该坐标采样，即可输出上面的映射后结果。\n\n![image-20210815214138597](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815214138597.png)\n\n\n\n## 应用\n\n### 卡通渲染效果\n\n> 在最亮部可能出现暗点，需要把贴图的Wrap Mode修改为Clamp而不是Repeat。\n>\n> 目前的描边会有比较明显的锯齿，卡渲一般会加抗锯齿后处理。\n\n![image-20210815221158922](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210815221158922.png)\n\n### 次表面散射效果（SSS效果）\n\n> 次表面散射(Sub-Surface-Scattering)简称3S，用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。\n>\n> 主要用于模拟不完全透明材质内部表现出来的一种真实光影特效次表面散射材质是高质量渲染中最复杂的材质之一，次表面反射一般是在半透明的材质上表现最为明显，如蜡烛、大理石、玉石、等上表现最为明显。我们知道，当灯光照射到玻璃或清澈的液体表面时，灯光会穿透这些介质，[菲涅尔反射](https://baike.baidu.com/item/菲涅尔反射/6556664)的3S效果可用来模拟灯光进入介质内部后发生的散射。最典型的就是一根点亮的蜡烛，仔细观察你会[发现](https://baike.baidu.com/item/发现/75066)在烛光的照耀下，蜡烛靠近火焰的那端显出的半透明效果。实际上，3S的最大用处之一在于表现灯光照射下的人的皮肤。\n\n\n\n上面的调子映射的v坐标采样值直接用了一个常数，即RampTex的上下没有变化。\n\n若我们让RampTex的上下有变化，然后用一个Slider来调节v坐标采样的值，则可以实现光穿透效果的平滑变化。\n\n![image-20210816202038366](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816202038366.png)\n\n\n\n### 玉石效果\n\n底色部分同上。\n\n**1. 一个高光点**：\n\n同样提取点积的结果后，在输出时加一个if结点，输入A，B为一个参数阈值，当A>B时输出1，小于时输出0，则可以得到高光点。\n\n![image-20210816103327816](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816103327816.png)\n\n\n\n**2. 两个高光点**：\n\n给lDir加一个参数偏移向量，即光照方向的偏移值，再做点积。最后把两个If输出的结果用Max结点合起来再用Clamp结点来限制范围在0-1内。\n\n\n\n**3. 把高光和底色合起来**：\n\n用Lerp结点。\n\nLerp结点的意思：相当于ps里的两个图层，A在B上面，然后给A加一个蒙版。但在Lerp中黑白和这里的蒙版相反，即T中白色的部分露出B结点的颜色。\n\n![image-20210816104447153](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816104447153.png)\n\n![image-20210816105416138](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816105416138.png)\n\n关键部分的结点连接：\n\n![image-20210816105608144](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816105608144.png)\n\n**4. 菲涅耳结点：**\n\n>*什么是菲涅耳效应？*\n>\n>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。\n>\n>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？\n>\n>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：\n>\n>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)\n\n给材质添加菲涅耳效果：\n\n记得在Exp输入中给一个常量，然后用Multiply结点给它乘一个颜色。然后用Blend结点把上面得到的结果和菲涅耳效果叠加（Screen处的下拉选项为叠加方式）\n\n![image-20210816112113052](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816112113052.png)\n\n最后效果：\n\n![image-20210816121532159](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816121532159.png)\n\n### 条纹排线效果\n\n**1.屏幕坐标**\n\n直接根据屏幕坐标取UV，则uv直接根据屏幕大小来展平，不会随着物体的放大缩小旋转而改变。\n\n若乘一个深度Depth结点，则uv会根据物体的深度而变化。\n\n**2.step结点**\n\n和if类似，若A<=B，则输出1，否则输出0。\n\n上面两步的效果如下：使用点乘的结果输入step的B输入，则<0，即暗部完全为黑色，中间为条纹，亮部为白色。\n\n![image-20210816123439908](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816123439908.png)\n\n**3. 添加颜色**\n\n使用Lerp结点添加一个亮部颜色和一个暗部颜色，然后用上面获得的黑白结果做蒙版遮罩即可。相当于把上面的黑色替换为A输入，白色替换为B输入。\n\n最后可以给一个模型的基础颜色再和上面的结果相加，做一个比较平滑的颜色效果。\n\n![image-20210816124408419](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816124408419.png)\n\n### Halftone半色调效果\n\n**1. 生成点阵纹理**\n\n获取屏幕坐标，然后乘一个较大的值20，利用Frac结点取余得到一个比较密集的条纹形状。\n\n然后使用Remap进行重映射到-0.5到0.5，再使用length结点得到一个密集的有渐变的点阵图像。length结点的公式如下：输入两个分量a和b，输出\n$$\na^2+b^2=c^2\n$$\n![image-20210816161533779](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816161533779.png)\n\n>  注意如果不进行重映射到-0.5到0.5，则生成的图像为一个四分之一圆形：\n>\n> ![image-20210816162045714](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816162045714.png)\n\n**2. 结合lambert光照模型**\n\n获取法向量和光线方向向量点积的值，然后做一个重映射，从1-0重映射到-0.5-2。\n\n> 注意这里原本是1-0，也就是说把亮部映射到负值，暗部映射到正值。因为对于亮部来说，不管上面length后得到的点阵图取0-1内的任何值，它的负数次幂都大于1。即亮部会呈现为全白，不会有点阵。\n>\n> 对于暗部，假设映射到1-2范围内的部分映射后取值为a，对于任何0-1的数的a次幂的结果均会比原来的取值更小，当小于0.5时四舍五入取整后这部分则为全黑。\n\n然后使用**Power结点**，把重映射的结果输入Exp。\n\n> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。\n\n![image-20210816164734797](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816164734797.png)_Power结点公式_\n\n然后用round结点把渐变部分取整变成黑白即可。\n\n![image-20210816165823653](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816165823653.png)\n\n\n\n### 参数面板\n\n创建一个模拟平行光（输入参数为光线方向、颜色、强度）\n\n![image-20210816200645649](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816200645649.png)\n\n\n\n### 风格化-把暗部做三层分离\n\n输入一个可调节的参数vector4，然后将点积的结果和vector4的XYZ三个通道用step结点进行对比，可以得到三个分层的亮部遮罩。\n\n![image-20210816203911475](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816203911475.png)\n\n然后可以将上面得到的结果作为遮罩，然后分别给亮部和暗部一个颜色。\n\n![image-20210816211440348](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816211440348.png)\n\n\n# 情报\n\n## Lut图\n\n![image-20210816215734597](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816215734597.png)\n\n## Houdini\n\n\n\n![image-20210816220236911](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-庄懂的技术美术入门课学习笔记（一）/image-20210816220236911.png)\n","slug":"2021-08-15-庄懂的技术美术入门课学习笔记（一）","published":1,"updated":"2021-08-17T12:03:13.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100l9000m3svo3hzv36gn","content":"<h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><p><a href=\"https://space.bilibili.com/6373917/video\">视频链接</a></p>\n<p><a href=\"https://acegikmo.com/shaderforge/nodes/?lang=zh_cn\">Shader Forge中文文档</a></p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>对应课程0~3课内容</p>\n</blockquote>\n<h2 id=\"光照模型\"><a href=\"#光照模型\" class=\"headerlink\" title=\"光照模型\"></a>光照模型</h2><h3 id=\"Lambert光照模型\"><a href=\"#Lambert光照模型\" class=\"headerlink\" title=\"Lambert光照模型\"></a>Lambert光照模型</h3><p>根据向量点乘的图形学含义，令</p>\n<ul>\n<li><p>模型表面的垂直方向为向量nDir（法线方向）</p>\n</li>\n<li><p>光照方向的反方向为向量lDir</p>\n</li>\n<li><p>输出nDir·lDir的结果为下图的光照表现：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815210059777.png\" alt=\"image-20210815210059777\" loading=\"lazy\"></p>\n</li>\n</ul>\n<p>其中明暗交接处之后的（即点积小于0的部分）都为纯黑色。由于负数是无意义的光照，把负数部分都取0，即为Lambert光照模型。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815210900380.png\" alt=\"image-20210815210900380\" loading=\"lazy\"></p>\n<h4 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>上述公式，两个向量点乘，输出到Emission上。然后用Clamp结点来限制一下范围0-1</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815212830722.png\" alt=\"image-20210815212830722\" loading=\"lazy\"></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\t\t\tstruct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完整代码：</p>\n<details>\n  <summary>LambertShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class1&#x2F;LambertShader&quot; &#123;\n    Properties &#123;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n<h3 id=\"半Lambert光照模型\"><a href=\"#半Lambert光照模型\" class=\"headerlink\" title=\"半Lambert光照模型\"></a>半Lambert光照模型</h3><p>Lambert在明暗交界线后的部分是死黑的，半Lambert模型就是整体*0.5+0.5,让暗部显得更透气，但这样没有了明暗交界线。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815211247604.png\" alt=\"image-20210815211247604\" loading=\"lazy\"></p>\n<h4 id=\"ShaderForge实现-1\"><a href=\"#ShaderForge实现-1\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>把点乘的结果用multiply*0.5再add0.5</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815213237161.png\" alt=\"image-20210815213237161\" loading=\"lazy\"></p>\n<h2 id=\"调子映射\"><a href=\"#调子映射\" class=\"headerlink\" title=\"调子映射\"></a>调子映射</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815213947360.png\" alt=\"image-20210815213947360\" loading=\"lazy\"></p>\n<p>ShaderForge：</p>\n<p>在上面半Lambert模型的基础上，把输出的点乘结果和另一个常量通过Append结点结合成一个向量。这样可以得到一个uv坐标，对输入的RampTex图像文件根据该坐标采样，即可输出上面的映射后结果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815214138597.png\" alt=\"image-20210815214138597\" loading=\"lazy\"></p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"卡通渲染效果\"><a href=\"#卡通渲染效果\" class=\"headerlink\" title=\"卡通渲染效果\"></a>卡通渲染效果</h3><blockquote>\n<p>在最亮部可能出现暗点，需要把贴图的Wrap Mode修改为Clamp而不是Repeat。</p>\n<p>目前的描边会有比较明显的锯齿，卡渲一般会加抗锯齿后处理。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815221158922.png\" alt=\"image-20210815221158922\" loading=\"lazy\"></p>\n<h3 id=\"次表面散射效果（SSS效果）\"><a href=\"#次表面散射效果（SSS效果）\" class=\"headerlink\" title=\"次表面散射效果（SSS效果）\"></a>次表面散射效果（SSS效果）</h3><blockquote>\n<p>次表面散射(Sub-Surface-Scattering)简称3S，用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。</p>\n<p>主要用于模拟不完全透明材质内部表现出来的一种真实光影特效次表面散射材质是高质量渲染中最复杂的材质之一，次表面反射一般是在半透明的材质上表现最为明显，如蜡烛、大理石、玉石、等上表现最为明显。我们知道，当灯光照射到玻璃或清澈的液体表面时，灯光会穿透这些介质，<a href=\"https://baike.baidu.com/item/%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84/6556664\">菲涅尔反射</a>的3S效果可用来模拟灯光进入介质内部后发生的散射。最典型的就是一根点亮的蜡烛，仔细观察你会<a href=\"https://baike.baidu.com/item/%E5%8F%91%E7%8E%B0/75066\">发现</a>在烛光的照耀下，蜡烛靠近火焰的那端显出的半透明效果。实际上，3S的最大用处之一在于表现灯光照射下的人的皮肤。</p>\n</blockquote>\n<p>上面的调子映射的v坐标采样值直接用了一个常数，即RampTex的上下没有变化。</p>\n<p>若我们让RampTex的上下有变化，然后用一个Slider来调节v坐标采样的值，则可以实现光穿透效果的平滑变化。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816202038366.png\" alt=\"image-20210816202038366\" loading=\"lazy\"></p>\n<h3 id=\"玉石效果\"><a href=\"#玉石效果\" class=\"headerlink\" title=\"玉石效果\"></a>玉石效果</h3><p>底色部分同上。</p>\n<p><strong>1. 一个高光点</strong>：</p>\n<p>同样提取点积的结果后，在输出时加一个if结点，输入A，B为一个参数阈值，当A&gt;B时输出1，小于时输出0，则可以得到高光点。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816103327816.png\" alt=\"image-20210816103327816\" loading=\"lazy\"></p>\n<p><strong>2. 两个高光点</strong>：</p>\n<p>给lDir加一个参数偏移向量，即光照方向的偏移值，再做点积。最后把两个If输出的结果用Max结点合起来再用Clamp结点来限制范围在0-1内。</p>\n<p><strong>3. 把高光和底色合起来</strong>：</p>\n<p>用Lerp结点。</p>\n<p>Lerp结点的意思：相当于ps里的两个图层，A在B上面，然后给A加一个蒙版。但在Lerp中黑白和这里的蒙版相反，即T中白色的部分露出B结点的颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816104447153.png\" alt=\"image-20210816104447153\" loading=\"lazy\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816105416138.png\" alt=\"image-20210816105416138\" loading=\"lazy\"></p>\n<p>关键部分的结点连接：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816105608144.png\" alt=\"image-20210816105608144\" loading=\"lazy\"></p>\n<p><strong>4. 菲涅耳结点：</strong></p>\n<blockquote>\n<p><em>什么是菲涅耳效应？</em></p>\n<p>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是<strong>物体材质反射率随角度改变</strong>的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。</p>\n<p>理论上，对于所有表面光滑的物体来说，<strong>视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。</strong>那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？</p>\n<p>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：</p>\n<p><img src=\"https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg\" alt=\"img\" loading=\"lazy\"></p>\n</blockquote>\n<p>给材质添加菲涅耳效果：</p>\n<p>记得在Exp输入中给一个常量，然后用Multiply结点给它乘一个颜色。然后用Blend结点把上面得到的结果和菲涅耳效果叠加（Screen处的下拉选项为叠加方式）</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816112113052.png\" alt=\"image-20210816112113052\" loading=\"lazy\"></p>\n<p>最后效果：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816121532159.png\" alt=\"image-20210816121532159\" loading=\"lazy\"></p>\n<h3 id=\"条纹排线效果\"><a href=\"#条纹排线效果\" class=\"headerlink\" title=\"条纹排线效果\"></a>条纹排线效果</h3><p><strong>1.屏幕坐标</strong></p>\n<p>直接根据屏幕坐标取UV，则uv直接根据屏幕大小来展平，不会随着物体的放大缩小旋转而改变。</p>\n<p>若乘一个深度Depth结点，则uv会根据物体的深度而变化。</p>\n<p><strong>2.step结点</strong></p>\n<p>和if类似，若A&lt;=B，则输出1，否则输出0。</p>\n<p>上面两步的效果如下：使用点乘的结果输入step的B输入，则&lt;0，即暗部完全为黑色，中间为条纹，亮部为白色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816123439908.png\" alt=\"image-20210816123439908\" loading=\"lazy\"></p>\n<p><strong>3. 添加颜色</strong></p>\n<p>使用Lerp结点添加一个亮部颜色和一个暗部颜色，然后用上面获得的黑白结果做蒙版遮罩即可。相当于把上面的黑色替换为A输入，白色替换为B输入。</p>\n<p>最后可以给一个模型的基础颜色再和上面的结果相加，做一个比较平滑的颜色效果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816124408419.png\" alt=\"image-20210816124408419\" loading=\"lazy\"></p>\n<h3 id=\"Halftone半色调效果\"><a href=\"#Halftone半色调效果\" class=\"headerlink\" title=\"Halftone半色调效果\"></a>Halftone半色调效果</h3><p><strong>1. 生成点阵纹理</strong></p>\n<p>获取屏幕坐标，然后乘一个较大的值20，利用Frac结点取余得到一个比较密集的条纹形状。</p>\n<p>然后使用Remap进行重映射到-0.5到0.5，再使用length结点得到一个密集的有渐变的点阵图像。length结点的公式如下：输入两个分量a和b，输出<br>$$<br>a^2+b^2=c^2<br>$$<br><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816161533779.png\" alt=\"image-20210816161533779\" loading=\"lazy\"></p>\n<blockquote>\n<p> 注意如果不进行重映射到-0.5到0.5，则生成的图像为一个四分之一圆形：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816162045714.png\" alt=\"image-20210816162045714\" loading=\"lazy\"></p>\n</blockquote>\n<p><strong>2. 结合lambert光照模型</strong></p>\n<p>获取法向量和光线方向向量点积的值，然后做一个重映射，从1-0重映射到-0.5-2。</p>\n<blockquote>\n<p>注意这里原本是1-0，也就是说把亮部映射到负值，暗部映射到正值。因为对于亮部来说，不管上面length后得到的点阵图取0-1内的任何值，它的负数次幂都大于1。即亮部会呈现为全白，不会有点阵。</p>\n<p>对于暗部，假设映射到1-2范围内的部分映射后取值为a，对于任何0-1的数的a次幂的结果均会比原来的取值更小，当小于0.5时四舍五入取整后这部分则为全黑。</p>\n</blockquote>\n<p>然后使用<strong>Power结点</strong>，把重映射的结果输入Exp。</p>\n<blockquote>\n<p>tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816164734797.png\" alt=\"image-20210816164734797\" loading=\"lazy\"><em>Power结点公式</em></p>\n<p>然后用round结点把渐变部分取整变成黑白即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816165823653.png\" alt=\"image-20210816165823653\" loading=\"lazy\"></p>\n<h3 id=\"参数面板\"><a href=\"#参数面板\" class=\"headerlink\" title=\"参数面板\"></a>参数面板</h3><p>创建一个模拟平行光（输入参数为光线方向、颜色、强度）</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816200645649.png\" alt=\"image-20210816200645649\" loading=\"lazy\"></p>\n<h3 id=\"风格化-把暗部做三层分离\"><a href=\"#风格化-把暗部做三层分离\" class=\"headerlink\" title=\"风格化-把暗部做三层分离\"></a>风格化-把暗部做三层分离</h3><p>输入一个可调节的参数vector4，然后将点积的结果和vector4的XYZ三个通道用step结点进行对比，可以得到三个分层的亮部遮罩。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816203911475.png\" alt=\"image-20210816203911475\" loading=\"lazy\"></p>\n<p>然后可以将上面得到的结果作为遮罩，然后分别给亮部和暗部一个颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816211440348.png\" alt=\"image-20210816211440348\" loading=\"lazy\"></p>\n<h1 id=\"情报\"><a href=\"#情报\" class=\"headerlink\" title=\"情报\"></a>情报</h1><h2 id=\"Lut图\"><a href=\"#Lut图\" class=\"headerlink\" title=\"Lut图\"></a>Lut图</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816215734597.png\" alt=\"image-20210816215734597\" loading=\"lazy\"></p>\n<h2 id=\"Houdini\"><a href=\"#Houdini\" class=\"headerlink\" title=\"Houdini\"></a>Houdini</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816220236911.png\" alt=\"image-20210816220236911\" loading=\"lazy\"></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"<h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><p><a href=\"https://space.bilibili.com/6373917/video\">视频链接</a></p>\n<p><a href=\"https://acegikmo.com/shaderforge/nodes/?lang=zh_cn\">Shader Forge中文文档</a></p>","more":"<blockquote>\n<p>对应课程0~3课内容</p>\n</blockquote>\n<h2 id=\"光照模型\"><a href=\"#光照模型\" class=\"headerlink\" title=\"光照模型\"></a>光照模型</h2><h3 id=\"Lambert光照模型\"><a href=\"#Lambert光照模型\" class=\"headerlink\" title=\"Lambert光照模型\"></a>Lambert光照模型</h3><p>根据向量点乘的图形学含义，令</p>\n<ul>\n<li><p>模型表面的垂直方向为向量nDir（法线方向）</p>\n</li>\n<li><p>光照方向的反方向为向量lDir</p>\n</li>\n<li><p>输出nDir·lDir的结果为下图的光照表现：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815210059777.png\" alt=\"image-20210815210059777\"></p>\n</li>\n</ul>\n<p>其中明暗交接处之后的（即点积小于0的部分）都为纯黑色。由于负数是无意义的光照，把负数部分都取0，即为Lambert光照模型。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815210900380.png\" alt=\"image-20210815210900380\"></p>\n<h4 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>上述公式，两个向量点乘，输出到Emission上。然后用Clamp结点来限制一下范围0-1</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815212830722.png\" alt=\"image-20210815212830722\"></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\t\t\tstruct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完整代码：</p>\n<details>\n  <summary>LambertShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class1&#x2F;LambertShader&quot; &#123;\n    Properties &#123;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n<h3 id=\"半Lambert光照模型\"><a href=\"#半Lambert光照模型\" class=\"headerlink\" title=\"半Lambert光照模型\"></a>半Lambert光照模型</h3><p>Lambert在明暗交界线后的部分是死黑的，半Lambert模型就是整体*0.5+0.5,让暗部显得更透气，但这样没有了明暗交界线。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815211247604.png\" alt=\"image-20210815211247604\"></p>\n<h4 id=\"ShaderForge实现-1\"><a href=\"#ShaderForge实现-1\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>把点乘的结果用multiply*0.5再add0.5</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815213237161.png\" alt=\"image-20210815213237161\"></p>\n<h2 id=\"调子映射\"><a href=\"#调子映射\" class=\"headerlink\" title=\"调子映射\"></a>调子映射</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815213947360.png\" alt=\"image-20210815213947360\"></p>\n<p>ShaderForge：</p>\n<p>在上面半Lambert模型的基础上，把输出的点乘结果和另一个常量通过Append结点结合成一个向量。这样可以得到一个uv坐标，对输入的RampTex图像文件根据该坐标采样，即可输出上面的映射后结果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815214138597.png\" alt=\"image-20210815214138597\"></p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"卡通渲染效果\"><a href=\"#卡通渲染效果\" class=\"headerlink\" title=\"卡通渲染效果\"></a>卡通渲染效果</h3><blockquote>\n<p>在最亮部可能出现暗点，需要把贴图的Wrap Mode修改为Clamp而不是Repeat。</p>\n<p>目前的描边会有比较明显的锯齿，卡渲一般会加抗锯齿后处理。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210815221158922.png\" alt=\"image-20210815221158922\"></p>\n<h3 id=\"次表面散射效果（SSS效果）\"><a href=\"#次表面散射效果（SSS效果）\" class=\"headerlink\" title=\"次表面散射效果（SSS效果）\"></a>次表面散射效果（SSS效果）</h3><blockquote>\n<p>次表面散射(Sub-Surface-Scattering)简称3S，用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。</p>\n<p>主要用于模拟不完全透明材质内部表现出来的一种真实光影特效次表面散射材质是高质量渲染中最复杂的材质之一，次表面反射一般是在半透明的材质上表现最为明显，如蜡烛、大理石、玉石、等上表现最为明显。我们知道，当灯光照射到玻璃或清澈的液体表面时，灯光会穿透这些介质，<a href=\"https://baike.baidu.com/item/%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84/6556664\">菲涅尔反射</a>的3S效果可用来模拟灯光进入介质内部后发生的散射。最典型的就是一根点亮的蜡烛，仔细观察你会<a href=\"https://baike.baidu.com/item/%E5%8F%91%E7%8E%B0/75066\">发现</a>在烛光的照耀下，蜡烛靠近火焰的那端显出的半透明效果。实际上，3S的最大用处之一在于表现灯光照射下的人的皮肤。</p>\n</blockquote>\n<p>上面的调子映射的v坐标采样值直接用了一个常数，即RampTex的上下没有变化。</p>\n<p>若我们让RampTex的上下有变化，然后用一个Slider来调节v坐标采样的值，则可以实现光穿透效果的平滑变化。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816202038366.png\" alt=\"image-20210816202038366\"></p>\n<h3 id=\"玉石效果\"><a href=\"#玉石效果\" class=\"headerlink\" title=\"玉石效果\"></a>玉石效果</h3><p>底色部分同上。</p>\n<p><strong>1. 一个高光点</strong>：</p>\n<p>同样提取点积的结果后，在输出时加一个if结点，输入A，B为一个参数阈值，当A&gt;B时输出1，小于时输出0，则可以得到高光点。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816103327816.png\" alt=\"image-20210816103327816\"></p>\n<p><strong>2. 两个高光点</strong>：</p>\n<p>给lDir加一个参数偏移向量，即光照方向的偏移值，再做点积。最后把两个If输出的结果用Max结点合起来再用Clamp结点来限制范围在0-1内。</p>\n<p><strong>3. 把高光和底色合起来</strong>：</p>\n<p>用Lerp结点。</p>\n<p>Lerp结点的意思：相当于ps里的两个图层，A在B上面，然后给A加一个蒙版。但在Lerp中黑白和这里的蒙版相反，即T中白色的部分露出B结点的颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816104447153.png\" alt=\"image-20210816104447153\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816105416138.png\" alt=\"image-20210816105416138\"></p>\n<p>关键部分的结点连接：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816105608144.png\" alt=\"image-20210816105608144\"></p>\n<p><strong>4. 菲涅耳结点：</strong></p>\n<blockquote>\n<p><em>什么是菲涅耳效应？</em></p>\n<p>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是<strong>物体材质反射率随角度改变</strong>的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。</p>\n<p>理论上，对于所有表面光滑的物体来说，<strong>视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。</strong>那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？</p>\n<p>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：</p>\n<p><img src=\"https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg\" alt=\"img\"></p>\n</blockquote>\n<p>给材质添加菲涅耳效果：</p>\n<p>记得在Exp输入中给一个常量，然后用Multiply结点给它乘一个颜色。然后用Blend结点把上面得到的结果和菲涅耳效果叠加（Screen处的下拉选项为叠加方式）</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816112113052.png\" alt=\"image-20210816112113052\"></p>\n<p>最后效果：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816121532159.png\" alt=\"image-20210816121532159\"></p>\n<h3 id=\"条纹排线效果\"><a href=\"#条纹排线效果\" class=\"headerlink\" title=\"条纹排线效果\"></a>条纹排线效果</h3><p><strong>1.屏幕坐标</strong></p>\n<p>直接根据屏幕坐标取UV，则uv直接根据屏幕大小来展平，不会随着物体的放大缩小旋转而改变。</p>\n<p>若乘一个深度Depth结点，则uv会根据物体的深度而变化。</p>\n<p><strong>2.step结点</strong></p>\n<p>和if类似，若A&lt;=B，则输出1，否则输出0。</p>\n<p>上面两步的效果如下：使用点乘的结果输入step的B输入，则&lt;0，即暗部完全为黑色，中间为条纹，亮部为白色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816123439908.png\" alt=\"image-20210816123439908\"></p>\n<p><strong>3. 添加颜色</strong></p>\n<p>使用Lerp结点添加一个亮部颜色和一个暗部颜色，然后用上面获得的黑白结果做蒙版遮罩即可。相当于把上面的黑色替换为A输入，白色替换为B输入。</p>\n<p>最后可以给一个模型的基础颜色再和上面的结果相加，做一个比较平滑的颜色效果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816124408419.png\" alt=\"image-20210816124408419\"></p>\n<h3 id=\"Halftone半色调效果\"><a href=\"#Halftone半色调效果\" class=\"headerlink\" title=\"Halftone半色调效果\"></a>Halftone半色调效果</h3><p><strong>1. 生成点阵纹理</strong></p>\n<p>获取屏幕坐标，然后乘一个较大的值20，利用Frac结点取余得到一个比较密集的条纹形状。</p>\n<p>然后使用Remap进行重映射到-0.5到0.5，再使用length结点得到一个密集的有渐变的点阵图像。length结点的公式如下：输入两个分量a和b，输出<br>$$<br>a^2+b^2=c^2<br>$$<br><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816161533779.png\" alt=\"image-20210816161533779\"></p>\n<blockquote>\n<p> 注意如果不进行重映射到-0.5到0.5，则生成的图像为一个四分之一圆形：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816162045714.png\" alt=\"image-20210816162045714\"></p>\n</blockquote>\n<p><strong>2. 结合lambert光照模型</strong></p>\n<p>获取法向量和光线方向向量点积的值，然后做一个重映射，从1-0重映射到-0.5-2。</p>\n<blockquote>\n<p>注意这里原本是1-0，也就是说把亮部映射到负值，暗部映射到正值。因为对于亮部来说，不管上面length后得到的点阵图取0-1内的任何值，它的负数次幂都大于1。即亮部会呈现为全白，不会有点阵。</p>\n<p>对于暗部，假设映射到1-2范围内的部分映射后取值为a，对于任何0-1的数的a次幂的结果均会比原来的取值更小，当小于0.5时四舍五入取整后这部分则为全黑。</p>\n</blockquote>\n<p>然后使用<strong>Power结点</strong>，把重映射的结果输入Exp。</p>\n<blockquote>\n<p>tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816164734797.png\" alt=\"image-20210816164734797\"><em>Power结点公式</em></p>\n<p>然后用round结点把渐变部分取整变成黑白即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816165823653.png\" alt=\"image-20210816165823653\"></p>\n<h3 id=\"参数面板\"><a href=\"#参数面板\" class=\"headerlink\" title=\"参数面板\"></a>参数面板</h3><p>创建一个模拟平行光（输入参数为光线方向、颜色、强度）</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816200645649.png\" alt=\"image-20210816200645649\"></p>\n<h3 id=\"风格化-把暗部做三层分离\"><a href=\"#风格化-把暗部做三层分离\" class=\"headerlink\" title=\"风格化-把暗部做三层分离\"></a>风格化-把暗部做三层分离</h3><p>输入一个可调节的参数vector4，然后将点积的结果和vector4的XYZ三个通道用step结点进行对比，可以得到三个分层的亮部遮罩。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816203911475.png\" alt=\"image-20210816203911475\"></p>\n<p>然后可以将上面得到的结果作为遮罩，然后分别给亮部和暗部一个颜色。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816211440348.png\" alt=\"image-20210816211440348\"></p>\n<h1 id=\"情报\"><a href=\"#情报\" class=\"headerlink\" title=\"情报\"></a>情报</h1><h2 id=\"Lut图\"><a href=\"#Lut图\" class=\"headerlink\" title=\"Lut图\"></a>Lut图</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816215734597.png\" alt=\"image-20210816215734597\"></p>\n<h2 id=\"Houdini\"><a href=\"#Houdini\" class=\"headerlink\" title=\"Houdini\"></a>Houdini</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-15-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20210816220236911.png\" alt=\"image-20210816220236911\"></p>"},{"title":"2021-08-16-庄懂的技术美术入门课学习笔记（二）","date":"2021-08-16T14:14:03.000Z","katex":true,"_content":"\n> 对应课程4~6课内容\n\n# 常用向量\n\n\n\n![image-20210816222259466](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222259466.png)\n\n# 反射\n\n## 漫反射Diffuse\n\n![image-20210816222732514](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222732514.png)\n\n## 镜面反射Specular\n\n![image-20210816222904721](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222904721.png)\n\n### Phong\n\n> 公式：r dot v（反射方向点乘观察方向）\n\n#### ShaderForge实现\n\n1. 先对l取反方向，然后求以N为对称的向量得到反射方向，然后再和观察方向点乘。记得要把负值变成0。\n\n   1.5 这一步等效于ViewReflect点乘光照方向$rDir=Reflect(-lDir,nDir)$\n   \n2. 用power结点得到高光。\n\n> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。\n>\n> 注意前面lDir要乘-1！\n\n![image-20210816234350760](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816234350760.png)\n\n### Blinn-Phong\n\n> Blinn-Phong的计算消耗少一些，但效果没有Phong真实，二者的高光范围有差别。\n>\n> 公式：n dot h （法线方向点乘半角方向）\n>\n> 半角：视角方向和观察方向的中间角\n\n#### ShaderForge实现\n\nn和h点乘后和0取max，然后再用power结点得到高光。\n\n![image-20210816233430097](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816233430097.png)\n\n\n\n\n\n\n\n# 应用\n\n用Phong获得高光部分，然后和漫反射的结果add一下，得到一种常用的光照模型。\n\n代码如下：\n\n### Lambert+Blinn-Phong/Phong\n\n> 获得世界空间坐标：\n>\n> ```c#\n> o.posWS = mul(unity_ObjectToWorld,v.vertex);\n> ```\n>\n> 求观察向量：\n>\n> ```c#\n> float3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS)\n> ```\n>\n> 求两个向量a、b的中间角：\n> $$ normalize(\\vec{a}+\\vec{b}) $$\n\n\n\n<details>\n\t<summary>OldSchoolShader.shader(相当于Lambert+Blinn-Phong)</summary>\n\n\n\n```c#\nShader \"Class2/OldSchoolShader\" {\n    Properties {\n\t\t_MainCol(\"颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(\"高光次幂\",range(1,90))=30\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _MainCol;\n\t\t\tuniform float _SpecularPow;\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\t\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);//世界空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS);\n\t\t\t\tfloat3 hDir = normalize(vDir+lDir);\n\t\t\t\tfloat3 rDir = reflect(-lDir,nDir);\n\n\t\t\t\t//中间值\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat nDoth = dot(nDir,hDir);//Blinn-Phong\n\t\t\t\tfloat rDotv= dot(rDir,vDir);//Phong\n\n\t\t\t\t//光照模型\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\t\t\t\tfloat blinnPhong = pow(max(0.0,nDoth),_SpecularPow);\n\t\t\t\tfloat phong = pow(max(0.0,rDotv),_SpecularPow);\n\t\t\t\tfloat3 finalBP = _MainCol * lambert + blinnPhong;\n\t\t\t\tfloat3 finalP = _MainCol * lambert + phong;\n\n                return float4(finalBP,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n### 使用贴图来给物体不同部分不同光滑度\n如果想使物体的不同部分看起来有不同的光滑度/粗糙度，可以用一个贴图来作为Lerp的蒙版，然后设置两种SpecularPower\n\n![image-20210817154859550](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817154859550.png)\n\n为了增强这种效果，可以对高光Power后再和贴图的一个通道做一次乘法，即可产生不均匀的高光。\n\n![image-20210817155011644](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817155011644.png)\n\n**样例1：每颗葡萄的高光范围不同**\n\n![image-20210817155050682](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817155050682.png)\n\n**样例2：铁上有脱落的漆皮（漆皮的光滑程度更高）**\n\n同样直接用step处理后的贴图对两种specularPower做插值得到高光，然后用同样的贴图对两种颜色做插值，和漫反射结果相乘后加上高光即可。\n\n![image-20210817160509757](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817160509757.png)\n\n# 情报\n\n## BRDF双向反射分布函数\n\n> 通俗理解：\n>\n> 想象你有一个不透明的桌面，一个激光发射器。你先让激光向下垂直地射在那个桌面上，这样你就可以在桌面上看到一个亮点，接着你从各个不同的方向来观察那个亮点，你会发现亮点的亮度随着观察方向的不同而发生了改变。然后你站着不动，改变激光发射方向和桌面的夹角，你又会发现亮点的亮度发生了改变。这就是说，一个表面对不同的光线入射角和反射角的组合，拥有不同的反射率。BRDF就是用来对这种反射性质进行定义的。\n\n![image-20210817161630691](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817161630691.png)\n\n其他的BRDF效果：可用BRDF Explorer查看其他模型\n\n![image-20210817161932407](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817161932407.png)\n\n## 开源Shader\n\n![image-20210822154247033](D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154247033.png)\n\n![image-20210822154428928](D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154428928.png)\n","source":"_posts/2021-08-16-庄懂的技术美术入门课学习笔记（二）.md","raw":"---\ntitle: 2021-08-16-庄懂的技术美术入门课学习笔记（二）\ndate: 2021-08-16 22:14:03\nkatex: true\ntags:\n  - 反射\n  - Phong\n  -\tBlinn-Phong\n  - BRDF\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n> 对应课程4~6课内容\n\n# 常用向量\n\n\n\n![image-20210816222259466](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222259466.png)\n\n# 反射\n\n## 漫反射Diffuse\n\n![image-20210816222732514](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222732514.png)\n\n## 镜面反射Specular\n\n![image-20210816222904721](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816222904721.png)\n\n### Phong\n\n> 公式：r dot v（反射方向点乘观察方向）\n\n#### ShaderForge实现\n\n1. 先对l取反方向，然后求以N为对称的向量得到反射方向，然后再和观察方向点乘。记得要把负值变成0。\n\n   1.5 这一步等效于ViewReflect点乘光照方向$rDir=Reflect(-lDir,nDir)$\n   \n2. 用power结点得到高光。\n\n> tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。\n>\n> 注意前面lDir要乘-1！\n\n![image-20210816234350760](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816234350760.png)\n\n### Blinn-Phong\n\n> Blinn-Phong的计算消耗少一些，但效果没有Phong真实，二者的高光范围有差别。\n>\n> 公式：n dot h （法线方向点乘半角方向）\n>\n> 半角：视角方向和观察方向的中间角\n\n#### ShaderForge实现\n\nn和h点乘后和0取max，然后再用power结点得到高光。\n\n![image-20210816233430097](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816233430097.png)\n\n\n\n\n\n\n\n# 应用\n\n用Phong获得高光部分，然后和漫反射的结果add一下，得到一种常用的光照模型。\n\n代码如下：\n\n### Lambert+Blinn-Phong/Phong\n\n> 获得世界空间坐标：\n>\n> ```c#\n> o.posWS = mul(unity_ObjectToWorld,v.vertex);\n> ```\n>\n> 求观察向量：\n>\n> ```c#\n> float3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS)\n> ```\n>\n> 求两个向量a、b的中间角：\n> $$ normalize(\\vec{a}+\\vec{b}) $$\n\n\n\n<details>\n\t<summary>OldSchoolShader.shader(相当于Lambert+Blinn-Phong)</summary>\n\n\n\n```c#\nShader \"Class2/OldSchoolShader\" {\n    Properties {\n\t\t_MainCol(\"颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(\"高光次幂\",range(1,90))=30\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _MainCol;\n\t\t\tuniform float _SpecularPow;\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n            };\n            struct VertexOutput {\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\t\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);//世界空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = i.nDirWS;\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS);\n\t\t\t\tfloat3 hDir = normalize(vDir+lDir);\n\t\t\t\tfloat3 rDir = reflect(-lDir,nDir);\n\n\t\t\t\t//中间值\n\t\t\t\t\n\t\t\t\tfloat nDotl = dot(nDir, lDir );//点乘\n\t\t\t\tfloat nDoth = dot(nDir,hDir);//Blinn-Phong\n\t\t\t\tfloat rDotv= dot(rDir,vDir);//Phong\n\n\t\t\t\t//光照模型\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\t\t\t\tfloat blinnPhong = pow(max(0.0,nDoth),_SpecularPow);\n\t\t\t\tfloat phong = pow(max(0.0,rDotv),_SpecularPow);\n\t\t\t\tfloat3 finalBP = _MainCol * lambert + blinnPhong;\n\t\t\t\tfloat3 finalP = _MainCol * lambert + phong;\n\n                return float4(finalBP,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n### 使用贴图来给物体不同部分不同光滑度\n如果想使物体的不同部分看起来有不同的光滑度/粗糙度，可以用一个贴图来作为Lerp的蒙版，然后设置两种SpecularPower\n\n![image-20210817154859550](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817154859550.png)\n\n为了增强这种效果，可以对高光Power后再和贴图的一个通道做一次乘法，即可产生不均匀的高光。\n\n![image-20210817155011644](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817155011644.png)\n\n**样例1：每颗葡萄的高光范围不同**\n\n![image-20210817155050682](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817155050682.png)\n\n**样例2：铁上有脱落的漆皮（漆皮的光滑程度更高）**\n\n同样直接用step处理后的贴图对两种specularPower做插值得到高光，然后用同样的贴图对两种颜色做插值，和漫反射结果相乘后加上高光即可。\n\n![image-20210817160509757](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817160509757.png)\n\n# 情报\n\n## BRDF双向反射分布函数\n\n> 通俗理解：\n>\n> 想象你有一个不透明的桌面，一个激光发射器。你先让激光向下垂直地射在那个桌面上，这样你就可以在桌面上看到一个亮点，接着你从各个不同的方向来观察那个亮点，你会发现亮点的亮度随着观察方向的不同而发生了改变。然后你站着不动，改变激光发射方向和桌面的夹角，你又会发现亮点的亮度发生了改变。这就是说，一个表面对不同的光线入射角和反射角的组合，拥有不同的反射率。BRDF就是用来对这种反射性质进行定义的。\n\n![image-20210817161630691](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817161630691.png)\n\n其他的BRDF效果：可用BRDF Explorer查看其他模型\n\n![image-20210817161932407](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210817161932407.png)\n\n## 开源Shader\n\n![image-20210822154247033](D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154247033.png)\n\n![image-20210822154428928](D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154428928.png)\n","slug":"2021-08-16-庄懂的技术美术入门课学习笔记（二）","published":1,"updated":"2021-08-22T07:44:33.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100lc000q3svoeesc0lov","content":"<blockquote>\n<p>对应课程4~6课内容</p>\n</blockquote>\n<h1 id=\"常用向量\"><a href=\"#常用向量\" class=\"headerlink\" title=\"常用向量\"></a>常用向量</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222259466.png\" alt=\"image-20210816222259466\" loading=\"lazy\"></p>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><h2 id=\"漫反射Diffuse\"><a href=\"#漫反射Diffuse\" class=\"headerlink\" title=\"漫反射Diffuse\"></a>漫反射Diffuse</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222732514.png\" alt=\"image-20210816222732514\" loading=\"lazy\"></p>\n<h2 id=\"镜面反射Specular\"><a href=\"#镜面反射Specular\" class=\"headerlink\" title=\"镜面反射Specular\"></a>镜面反射Specular</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222904721.png\" alt=\"image-20210816222904721\" loading=\"lazy\"></p>\n<h3 id=\"Phong\"><a href=\"#Phong\" class=\"headerlink\" title=\"Phong\"></a>Phong</h3><blockquote>\n<p>公式：r dot v（反射方向点乘观察方向）</p>\n</blockquote>\n<h4 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><ol>\n<li><p>先对l取反方向，然后求以N为对称的向量得到反射方向，然后再和观察方向点乘。记得要把负值变成0。</p>\n<p>1.5 这一步等效于ViewReflect点乘光照方向$rDir=Reflect(-lDir,nDir)$</p>\n</li>\n<li><p>用power结点得到高光。</p>\n</li>\n</ol>\n<blockquote>\n<p>tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。</p>\n<p>注意前面lDir要乘-1！</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816234350760.png\" alt=\"image-20210816234350760\" loading=\"lazy\"></p>\n<h3 id=\"Blinn-Phong\"><a href=\"#Blinn-Phong\" class=\"headerlink\" title=\"Blinn-Phong\"></a>Blinn-Phong</h3><blockquote>\n<p>Blinn-Phong的计算消耗少一些，但效果没有Phong真实，二者的高光范围有差别。</p>\n<p>公式：n dot h （法线方向点乘半角方向）</p>\n<p>半角：视角方向和观察方向的中间角</p>\n</blockquote>\n<h4 id=\"ShaderForge实现-1\"><a href=\"#ShaderForge实现-1\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>n和h点乘后和0取max，然后再用power结点得到高光。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816233430097.png\" alt=\"image-20210816233430097\" loading=\"lazy\"></p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>用Phong获得高光部分，然后和漫反射的结果add一下，得到一种常用的光照模型。</p>\n<p>代码如下：</p>\n<h3 id=\"Lambert-Blinn-Phong-Phong\"><a href=\"#Lambert-Blinn-Phong-Phong\" class=\"headerlink\" title=\"Lambert+Blinn-Phong/Phong\"></a>Lambert+Blinn-Phong/Phong</h3><blockquote>\n<p>获得世界空间坐标：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">o.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>求观察向量：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>求两个向量a、b的中间角：<br>$$ normalize(\\vec{a}+\\vec{b}) $$</p>\n</blockquote>\n<details>\n    <summary>OldSchoolShader.shader(相当于Lambert+Blinn-Phong)</summary>\n\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class2&#x2F;OldSchoolShader&quot; &#123;\n    Properties &#123;\n\t\t_MainCol(&quot;颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D;30\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _MainCol;\n\t\t\tuniform float _SpecularPow;\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\t\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.posCS &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);&#x2F;&#x2F;世界空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS);\n\t\t\t\tfloat3 hDir &#x3D; normalize(vDir+lDir);\n\t\t\t\tfloat3 rDir &#x3D; reflect(-lDir,nDir);\n\n\t\t\t\t&#x2F;&#x2F;中间值\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat nDoth &#x3D; dot(nDir,hDir);&#x2F;&#x2F;Blinn-Phong\n\t\t\t\tfloat rDotv&#x3D; dot(rDir,vDir);&#x2F;&#x2F;Phong\n\n\t\t\t\t&#x2F;&#x2F;光照模型\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\t\t\t\tfloat blinnPhong &#x3D; pow(max(0.0,nDoth),_SpecularPow);\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,rDotv),_SpecularPow);\n\t\t\t\tfloat3 finalBP &#x3D; _MainCol * lambert + blinnPhong;\n\t\t\t\tfloat3 finalP &#x3D; _MainCol * lambert + phong;\n\n                return float4(finalBP,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n<h3 id=\"使用贴图来给物体不同部分不同光滑度\"><a href=\"#使用贴图来给物体不同部分不同光滑度\" class=\"headerlink\" title=\"使用贴图来给物体不同部分不同光滑度\"></a>使用贴图来给物体不同部分不同光滑度</h3><p>如果想使物体的不同部分看起来有不同的光滑度/粗糙度，可以用一个贴图来作为Lerp的蒙版，然后设置两种SpecularPower</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817154859550.png\" alt=\"image-20210817154859550\" loading=\"lazy\"></p>\n<p>为了增强这种效果，可以对高光Power后再和贴图的一个通道做一次乘法，即可产生不均匀的高光。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817155011644.png\" alt=\"image-20210817155011644\" loading=\"lazy\"></p>\n<p><strong>样例1：每颗葡萄的高光范围不同</strong></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817155050682.png\" alt=\"image-20210817155050682\" loading=\"lazy\"></p>\n<p><strong>样例2：铁上有脱落的漆皮（漆皮的光滑程度更高）</strong></p>\n<p>同样直接用step处理后的贴图对两种specularPower做插值得到高光，然后用同样的贴图对两种颜色做插值，和漫反射结果相乘后加上高光即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817160509757.png\" alt=\"image-20210817160509757\" loading=\"lazy\"></p>\n<h1 id=\"情报\"><a href=\"#情报\" class=\"headerlink\" title=\"情报\"></a>情报</h1><h2 id=\"BRDF双向反射分布函数\"><a href=\"#BRDF双向反射分布函数\" class=\"headerlink\" title=\"BRDF双向反射分布函数\"></a>BRDF双向反射分布函数</h2><blockquote>\n<p>通俗理解：</p>\n<p>想象你有一个不透明的桌面，一个激光发射器。你先让激光向下垂直地射在那个桌面上，这样你就可以在桌面上看到一个亮点，接着你从各个不同的方向来观察那个亮点，你会发现亮点的亮度随着观察方向的不同而发生了改变。然后你站着不动，改变激光发射方向和桌面的夹角，你又会发现亮点的亮度发生了改变。这就是说，一个表面对不同的光线入射角和反射角的组合，拥有不同的反射率。BRDF就是用来对这种反射性质进行定义的。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817161630691.png\" alt=\"image-20210817161630691\" loading=\"lazy\"></p>\n<p>其他的BRDF效果：可用BRDF Explorer查看其他模型</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817161932407.png\" alt=\"image-20210817161932407\" loading=\"lazy\"></p>\n<h2 id=\"开源Shader\"><a href=\"#开源Shader\" class=\"headerlink\" title=\"开源Shader\"></a>开源Shader</h2><p><img src=\"D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154247033.png\" alt=\"image-20210822154247033\" loading=\"lazy\"></p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154428928.png\" alt=\"image-20210822154428928\" loading=\"lazy\"></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<blockquote>\n<p>对应课程4~6课内容</p>\n</blockquote>\n<h1 id=\"常用向量\"><a href=\"#常用向量\" class=\"headerlink\" title=\"常用向量\"></a>常用向量</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222259466.png\" alt=\"image-20210816222259466\"></p>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><h2 id=\"漫反射Diffuse\"><a href=\"#漫反射Diffuse\" class=\"headerlink\" title=\"漫反射Diffuse\"></a>漫反射Diffuse</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222732514.png\" alt=\"image-20210816222732514\"></p>\n<h2 id=\"镜面反射Specular\"><a href=\"#镜面反射Specular\" class=\"headerlink\" title=\"镜面反射Specular\"></a>镜面反射Specular</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816222904721.png\" alt=\"image-20210816222904721\"></p>\n<h3 id=\"Phong\"><a href=\"#Phong\" class=\"headerlink\" title=\"Phong\"></a>Phong</h3><blockquote>\n<p>公式：r dot v（反射方向点乘观察方向）</p>\n</blockquote>\n<h4 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><ol>\n<li><p>先对l取反方向，然后求以N为对称的向量得到反射方向，然后再和观察方向点乘。记得要把负值变成0。</p>\n<p>1.5 这一步等效于ViewReflect点乘光照方向$rDir=Reflect(-lDir,nDir)$</p>\n</li>\n<li><p>用power结点得到高光。</p>\n</li>\n</ol>\n<blockquote>\n<p>tips: 两个rgb相乘就相当于正片叠底，power的指数相当于正片叠底的层数。power一般叫高光次幂。</p>\n<p>注意前面lDir要乘-1！</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816234350760.png\" alt=\"image-20210816234350760\"></p>\n<h3 id=\"Blinn-Phong\"><a href=\"#Blinn-Phong\" class=\"headerlink\" title=\"Blinn-Phong\"></a>Blinn-Phong</h3><blockquote>\n<p>Blinn-Phong的计算消耗少一些，但效果没有Phong真实，二者的高光范围有差别。</p>\n<p>公式：n dot h （法线方向点乘半角方向）</p>\n<p>半角：视角方向和观察方向的中间角</p>\n</blockquote>\n<h4 id=\"ShaderForge实现-1\"><a href=\"#ShaderForge实现-1\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h4><p>n和h点乘后和0取max，然后再用power结点得到高光。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816233430097.png\" alt=\"image-20210816233430097\"></p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>用Phong获得高光部分，然后和漫反射的结果add一下，得到一种常用的光照模型。</p>\n<p>代码如下：</p>\n<h3 id=\"Lambert-Blinn-Phong-Phong\"><a href=\"#Lambert-Blinn-Phong-Phong\" class=\"headerlink\" title=\"Lambert+Blinn-Phong/Phong\"></a>Lambert+Blinn-Phong/Phong</h3><blockquote>\n<p>获得世界空间坐标：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">o.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>求观察向量：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>求两个向量a、b的中间角：<br>$$ normalize(\\vec{a}+\\vec{b}) $$</p>\n</blockquote>\n<details>\n    <summary>OldSchoolShader.shader(相当于Lambert+Blinn-Phong)</summary>\n\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class2&#x2F;OldSchoolShader&quot; &#123;\n    Properties &#123;\n\t\t_MainCol(&quot;颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D;30\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _MainCol;\n\t\t\tuniform float _SpecularPow;\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n            &#125;;\n            struct VertexOutput &#123;\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\t\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.posCS &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);&#x2F;&#x2F;世界空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS);\n\t\t\t\tfloat3 hDir &#x3D; normalize(vDir+lDir);\n\t\t\t\tfloat3 rDir &#x3D; reflect(-lDir,nDir);\n\n\t\t\t\t&#x2F;&#x2F;中间值\n\t\t\t\t\n\t\t\t\tfloat nDotl &#x3D; dot(nDir, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat nDoth &#x3D; dot(nDir,hDir);&#x2F;&#x2F;Blinn-Phong\n\t\t\t\tfloat rDotv&#x3D; dot(rDir,vDir);&#x2F;&#x2F;Phong\n\n\t\t\t\t&#x2F;&#x2F;光照模型\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\t\t\t\tfloat blinnPhong &#x3D; pow(max(0.0,nDoth),_SpecularPow);\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,rDotv),_SpecularPow);\n\t\t\t\tfloat3 finalBP &#x3D; _MainCol * lambert + blinnPhong;\n\t\t\t\tfloat3 finalP &#x3D; _MainCol * lambert + phong;\n\n                return float4(finalBP,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n<h3 id=\"使用贴图来给物体不同部分不同光滑度\"><a href=\"#使用贴图来给物体不同部分不同光滑度\" class=\"headerlink\" title=\"使用贴图来给物体不同部分不同光滑度\"></a>使用贴图来给物体不同部分不同光滑度</h3><p>如果想使物体的不同部分看起来有不同的光滑度/粗糙度，可以用一个贴图来作为Lerp的蒙版，然后设置两种SpecularPower</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817154859550.png\" alt=\"image-20210817154859550\"></p>\n<p>为了增强这种效果，可以对高光Power后再和贴图的一个通道做一次乘法，即可产生不均匀的高光。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817155011644.png\" alt=\"image-20210817155011644\"></p>\n<p><strong>样例1：每颗葡萄的高光范围不同</strong></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817155050682.png\" alt=\"image-20210817155050682\"></p>\n<p><strong>样例2：铁上有脱落的漆皮（漆皮的光滑程度更高）</strong></p>\n<p>同样直接用step处理后的贴图对两种specularPower做插值得到高光，然后用同样的贴图对两种颜色做插值，和漫反射结果相乘后加上高光即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817160509757.png\" alt=\"image-20210817160509757\"></p>\n<h1 id=\"情报\"><a href=\"#情报\" class=\"headerlink\" title=\"情报\"></a>情报</h1><h2 id=\"BRDF双向反射分布函数\"><a href=\"#BRDF双向反射分布函数\" class=\"headerlink\" title=\"BRDF双向反射分布函数\"></a>BRDF双向反射分布函数</h2><blockquote>\n<p>通俗理解：</p>\n<p>想象你有一个不透明的桌面，一个激光发射器。你先让激光向下垂直地射在那个桌面上，这样你就可以在桌面上看到一个亮点，接着你从各个不同的方向来观察那个亮点，你会发现亮点的亮度随着观察方向的不同而发生了改变。然后你站着不动，改变激光发射方向和桌面的夹角，你又会发现亮点的亮度发生了改变。这就是说，一个表面对不同的光线入射角和反射角的组合，拥有不同的反射率。BRDF就是用来对这种反射性质进行定义的。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817161630691.png\" alt=\"image-20210817161630691\"></p>\n<p>其他的BRDF效果：可用BRDF Explorer查看其他模型</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210817161932407.png\" alt=\"image-20210817161932407\"></p>\n<h2 id=\"开源Shader\"><a href=\"#开源Shader\" class=\"headerlink\" title=\"开源Shader\"></a>开源Shader</h2><p><img src=\"D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154247033.png\" alt=\"image-20210822154247033\"></p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-16-庄懂的技术美术入门课学习笔记（二）\\image-20210822154428928.png\" alt=\"image-20210822154428928\"></p>\n"},{"title":"2021-08-17-庄懂的技术美术入门课学习笔记（三）","date":"2021-08-17T08:24:40.000Z","katex":true,"_content":"\n> 对应课程7-8课内容\n\n# AO（Ambient Occlusion）环境光遮蔽\n\n> AO是来描绘物体和物体[相交](https://baike.baidu.com/item/相交/10077492)或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：\n>\n> AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。\n\n## 在blender中导出AO贴图\n\n1. 创建一个新的图片文件。打开图片预览。\n\n2. 然后在渲染属性中设置烘焙类型为环境光遮蔽。\n\n   ![image-20210817171811952](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171811952.png)\n\n   3. 烘焙后即可看到AO贴图，另存为图片即可。\n\n      ![image-20210817171900860](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171900860.png)\n\n## 3个方向的环境光\n\n输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。\n\n![image-20210817164458000](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817164458000.png)\n\n根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。\n\n### ShaderForge实现\n\n![image-20210817173142732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173142732.png)\n\n最后获得的结果如图：\n\n![image-20210817173346922](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173346922.png)\n\n### Code\n\n>**Key Point:**\n>\n>1. 面板贴图参数定义：`_Occlusion(\"AO贴图\",2d)= \"white\" {}`  \n>\n>`uniform sampler2D _Occlusion;`\n>\n>2. 输入模型uv0：\n>\n>  `float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0`\n>\n>3. 输出结构添加uv：\n>\n>  `float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图`\n>\n>4. 定点着色器对uv赋值：\n>\n>   `o.uv = v.uv0;`\n>\n>5. 片元着色器中根据输出的uv采样AO贴图：\n>\n>   `float occlusion=tex2D(_Occlusion,i.uv);`\n\n<details>\n    <summary>MyThreeColAmbientShader.shader</summary>\n\n```c#\nShader \"Class3/MyThreeColAmbientShader\"\n{\n    Properties {\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n            };\n            struct VertexOutput {\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n\t\t\t\tfloat2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv = v.uv0;\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = i.nDirWS;\n\n\t\t\t\t//计算各部位遮罩\n\t\t\t\tfloat upMask = max(0.0,nDir.g);\n\t\t\t\tfloat downMask = max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask = max(0.0,1-upMask-downMask);\n\n\n\t\t\t\t//混合颜色\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//采样Occlusion贴图\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv);\n\t\t\t\t//AO\n\t\t\t\tfloat3 finalRGB = envCol*occlusion;\n\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n# 投影\n\n## Unity内置投影代码调用方法\n\n> 注意要包含的库文件：\n>\n> ```c#\n> #include \"AutoLight.cginc\"  //使用unity投影必须包含\n> #include \"Lighting.cginc\"  //使用unity投影必须包含\n> ```\n\n![image-20210817181801721](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181801721.png)\n\n![image-20210817181543732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181543732.png)\n\n# 综合应用-简化理解光照的构成\n\n![image-20210817205326280](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205326280.png)\n\n![image-20210817205548075](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205548075.png)\n\n对于上述模型，把之前学习的内容结合起来：\n\n注意Lambert+Phong之后要和光源遮挡相乘之后才得到光源的结果。\n\n![image-20210817205808746](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205808746.png)\n\n## Code\n\n<details>\n    <summary>OldSchoolPlusShader.shader</summary>\n\n```c#\nShader \"Class3/OldSchoolPlusShader\"\n{\n    Properties {\n\t\t_BaseCol(\"基本颜色\",color)=(1.0,0.0,0.0,1.0)\n\t\t_LightCol(\"光照颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(\"高光次幂\",range(1,90))= 30\n\t\t_Intensity(\"光照强度\",range(0,5))=1\n\n\t\t_EnvIntensity(\"环境光强度\",range(0,5))=1\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\tuniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat4 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat2 uv : TEXCOORD2;//追加uv输出用于采样AO贴图\n\t\t\t\tLIGHTING_COORDS(3,4)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = normalize(i.nDirWS);\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS.xyz);\n\t\t\t\tfloat3 rDir = reflect(-lDir,nDir);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n////// Light:\n\t\t\t\tfloat nDotl = dot(nDir,lDir);\n\t\t\t\tfloat vDotr = dot(vDir,rDir);\n\n\t\t\t\tfloat lambert = max(0.0,nDotl);\n\t\t\t\tfloat phong = pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t///add shadow\n\t\t\t\t\n\t\t\t\tfloat3 lightRes =_LightCol*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n////// env:\n\t\t\t\t\n\n\t\t\t\t//计算各部位遮罩\n\t\t\t\tfloat upMask = max(0.0,nDir.g);\n\t\t\t\tfloat downMask = max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask = 1.0-upMask-downMask;\n\n\n\t\t\t\t//混合颜色\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//采样Occlusion贴图\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv);\n\t\t\t\t//AO\n\t\t\t\tfloat3 envRes = envCol*_BaseCol*_EnvIntensity*occlusion;\n\n\t\t\t\tfloat3 finalRGB = lightRes+envRes;\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n","source":"_posts/2021-08-17-庄懂的技术美术入门课学习笔记（三）.md","raw":"---\ntitle: 2021-08-17-庄懂的技术美术入门课学习笔记（三）\ndate: 2021-08-17 16:24:40\nkatex: true\ntags:\n  - 环境光\n  - AO\n  - 投影\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n> 对应课程7-8课内容\n\n# AO（Ambient Occlusion）环境光遮蔽\n\n> AO是来描绘物体和物体[相交](https://baike.baidu.com/item/相交/10077492)或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：\n>\n> AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。\n\n## 在blender中导出AO贴图\n\n1. 创建一个新的图片文件。打开图片预览。\n\n2. 然后在渲染属性中设置烘焙类型为环境光遮蔽。\n\n   ![image-20210817171811952](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171811952.png)\n\n   3. 烘焙后即可看到AO贴图，另存为图片即可。\n\n      ![image-20210817171900860](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817171900860.png)\n\n## 3个方向的环境光\n\n输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。\n\n![image-20210817164458000](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817164458000.png)\n\n根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。\n\n### ShaderForge实现\n\n![image-20210817173142732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173142732.png)\n\n最后获得的结果如图：\n\n![image-20210817173346922](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817173346922.png)\n\n### Code\n\n>**Key Point:**\n>\n>1. 面板贴图参数定义：`_Occlusion(\"AO贴图\",2d)= \"white\" {}`  \n>\n>`uniform sampler2D _Occlusion;`\n>\n>2. 输入模型uv0：\n>\n>  `float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0`\n>\n>3. 输出结构添加uv：\n>\n>  `float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图`\n>\n>4. 定点着色器对uv赋值：\n>\n>   `o.uv = v.uv0;`\n>\n>5. 片元着色器中根据输出的uv采样AO贴图：\n>\n>   `float occlusion=tex2D(_Occlusion,i.uv);`\n\n<details>\n    <summary>MyThreeColAmbientShader.shader</summary>\n\n```c#\nShader \"Class3/MyThreeColAmbientShader\"\n{\n    Properties {\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n            };\n            struct VertexOutput {\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n\t\t\t\tfloat2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.posCS = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv = v.uv0;\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = i.nDirWS;\n\n\t\t\t\t//计算各部位遮罩\n\t\t\t\tfloat upMask = max(0.0,nDir.g);\n\t\t\t\tfloat downMask = max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask = max(0.0,1-upMask-downMask);\n\n\n\t\t\t\t//混合颜色\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//采样Occlusion贴图\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv);\n\t\t\t\t//AO\n\t\t\t\tfloat3 finalRGB = envCol*occlusion;\n\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n# 投影\n\n## Unity内置投影代码调用方法\n\n> 注意要包含的库文件：\n>\n> ```c#\n> #include \"AutoLight.cginc\"  //使用unity投影必须包含\n> #include \"Lighting.cginc\"  //使用unity投影必须包含\n> ```\n\n![image-20210817181801721](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181801721.png)\n\n![image-20210817181543732](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-庄懂的技术美术入门课学习笔记（三）/image-20210817181543732.png)\n\n# 综合应用-简化理解光照的构成\n\n![image-20210817205326280](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205326280.png)\n\n![image-20210817205548075](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205548075.png)\n\n对于上述模型，把之前学习的内容结合起来：\n\n注意Lambert+Phong之后要和光源遮挡相乘之后才得到光源的结果。\n\n![image-20210817205808746](D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205808746.png)\n\n## Code\n\n<details>\n    <summary>OldSchoolPlusShader.shader</summary>\n\n```c#\nShader \"Class3/OldSchoolPlusShader\"\n{\n    Properties {\n\t\t_BaseCol(\"基本颜色\",color)=(1.0,0.0,0.0,1.0)\n\t\t_LightCol(\"光照颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(\"高光次幂\",range(1,90))= 30\n\t\t_Intensity(\"光照强度\",range(0,5))=1\n\n\t\t_EnvIntensity(\"环境光强度\",range(0,5))=1\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\tuniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat4 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat2 uv : TEXCOORD2;//追加uv输出用于采样AO贴图\n\t\t\t\tLIGHTING_COORDS(3,4)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\t\t\t\tfloat3 nDir = normalize(i.nDirWS);\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir = normalize(_WorldSpaceCameraPos.xyz-i.posWS.xyz);\n\t\t\t\tfloat3 rDir = reflect(-lDir,nDir);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n////// Light:\n\t\t\t\tfloat nDotl = dot(nDir,lDir);\n\t\t\t\tfloat vDotr = dot(vDir,rDir);\n\n\t\t\t\tfloat lambert = max(0.0,nDotl);\n\t\t\t\tfloat phong = pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t///add shadow\n\t\t\t\t\n\t\t\t\tfloat3 lightRes =_LightCol*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n////// env:\n\t\t\t\t\n\n\t\t\t\t//计算各部位遮罩\n\t\t\t\tfloat upMask = max(0.0,nDir.g);\n\t\t\t\tfloat downMask = max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask = 1.0-upMask-downMask;\n\n\n\t\t\t\t//混合颜色\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//采样Occlusion贴图\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv);\n\t\t\t\t//AO\n\t\t\t\tfloat3 envRes = envCol*_BaseCol*_EnvIntensity*occlusion;\n\n\t\t\t\tfloat3 finalRGB = lightRes+envRes;\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n","slug":"2021-08-17-庄懂的技术美术入门课学习笔记（三）","published":1,"updated":"2021-08-18T12:43:36.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100lw002g3svo6i9i3yka","content":"<blockquote>\n<p>对应课程7-8课内容</p>\n</blockquote>\n<h1 id=\"AO（Ambient-Occlusion）环境光遮蔽\"><a href=\"#AO（Ambient-Occlusion）环境光遮蔽\" class=\"headerlink\" title=\"AO（Ambient Occlusion）环境光遮蔽\"></a>AO（Ambient Occlusion）环境光遮蔽</h1><blockquote>\n<p>AO是来描绘物体和物体<a href=\"https://baike.baidu.com/item/%E7%9B%B8%E4%BA%A4/10077492\">相交</a>或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：</p>\n<p>AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。</p>\n</blockquote>\n<h2 id=\"在blender中导出AO贴图\"><a href=\"#在blender中导出AO贴图\" class=\"headerlink\" title=\"在blender中导出AO贴图\"></a>在blender中导出AO贴图</h2><ol>\n<li><p>创建一个新的图片文件。打开图片预览。</p>\n</li>\n<li><p>然后在渲染属性中设置烘焙类型为环境光遮蔽。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817171811952.png\" alt=\"image-20210817171811952\" loading=\"lazy\"></p>\n<ol start=\"3\">\n<li><p>烘焙后即可看到AO贴图，另存为图片即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817171900860.png\" alt=\"image-20210817171900860\" loading=\"lazy\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3个方向的环境光\"><a href=\"#3个方向的环境光\" class=\"headerlink\" title=\"3个方向的环境光\"></a>3个方向的环境光</h2><p>输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817164458000.png\" alt=\"image-20210817164458000\" loading=\"lazy\"></p>\n<p>根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。</p>\n<h3 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817173142732.png\" alt=\"image-20210817173142732\" loading=\"lazy\"></p>\n<p>最后获得的结果如图：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817173346922.png\" alt=\"image-20210817173346922\" loading=\"lazy\"></p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><blockquote>\n<p><strong>Key Point:</strong></p>\n<ol>\n<li>面板贴图参数定义：<code>_Occlusion(&quot;AO贴图&quot;,2d)= &quot;white&quot; &#123;&#125;</code>  </li>\n</ol>\n<p><code>uniform sampler2D _Occlusion;</code></p>\n<ol start=\"2\">\n<li>输入模型uv0：</li>\n</ol>\n<p> <code>float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0</code></p>\n<ol start=\"3\">\n<li>输出结构添加uv：</li>\n</ol>\n<p> <code>float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图</code></p>\n<ol start=\"4\">\n<li>定点着色器对uv赋值：</li>\n</ol>\n<p>  <code>o.uv = v.uv0;</code></p>\n<ol start=\"5\">\n<li>片元着色器中根据输出的uv采样AO贴图：</li>\n</ol>\n<p>  <code>float occlusion=tex2D(_Occlusion,i.uv);</code></p>\n</blockquote>\n<details>\n    <summary>MyThreeColAmbientShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class3&#x2F;MyThreeColAmbientShader&quot;\n&#123;\n    Properties &#123;\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n            &#125;;\n            struct VertexOutput &#123;\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n\t\t\t\tfloat2 uv : TEXCOORD1;&#x2F;&#x2F;追加uv输出用于采样AO贴图\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.posCS &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv &#x3D; v.uv0;\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\n\t\t\t\t&#x2F;&#x2F;计算各部位遮罩\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDir.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask &#x3D; max(0.0,1-upMask-downMask);\n\n\n\t\t\t\t&#x2F;&#x2F;混合颜色\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;采样Occlusion贴图\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv);\n\t\t\t\t&#x2F;&#x2F;AO\n\t\t\t\tfloat3 finalRGB &#x3D; envCol*occlusion;\n\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a>投影</h1><h2 id=\"Unity内置投影代码调用方法\"><a href=\"#Unity内置投影代码调用方法\" class=\"headerlink\" title=\"Unity内置投影代码调用方法\"></a>Unity内置投影代码调用方法</h2><blockquote>\n<p>注意要包含的库文件：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817181801721.png\" alt=\"image-20210817181801721\" loading=\"lazy\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817181543732.png\" alt=\"image-20210817181543732\" loading=\"lazy\"></p>\n<h1 id=\"综合应用-简化理解光照的构成\"><a href=\"#综合应用-简化理解光照的构成\" class=\"headerlink\" title=\"综合应用-简化理解光照的构成\"></a>综合应用-简化理解光照的构成</h1><p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205326280.png\" alt=\"image-20210817205326280\" loading=\"lazy\"></p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205548075.png\" alt=\"image-20210817205548075\" loading=\"lazy\"></p>\n<p>对于上述模型，把之前学习的内容结合起来：</p>\n<p>注意Lambert+Phong之后要和光源遮挡相乘之后才得到光源的结果。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205808746.png\" alt=\"image-20210817205808746\" loading=\"lazy\"></p>\n<h2 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h2><details>\n    <summary>OldSchoolPlusShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class3&#x2F;OldSchoolPlusShader&quot;\n&#123;\n    Properties &#123;\n\t\t_BaseCol(&quot;基本颜色&quot;,color)&#x3D;(1.0,0.0,0.0,1.0)\n\t\t_LightCol(&quot;光照颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_Intensity(&quot;光照强度&quot;,range(0,5))&#x3D;1\n\n\t\t_EnvIntensity(&quot;环境光强度&quot;,range(0,5))&#x3D;1\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\tuniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat4 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat2 uv : TEXCOORD2;&#x2F;&#x2F;追加uv输出用于采样AO贴图\n\t\t\t\tLIGHTING_COORDS(3,4)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; normalize(i.nDirWS);\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS.xyz);\n\t\t\t\tfloat3 rDir &#x3D; reflect(-lDir,nDir);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Light:\n\t\t\t\tfloat nDotl &#x3D; dot(nDir,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDir,rDir);\n\n\t\t\t\tfloat lambert &#x3D; max(0.0,nDotl);\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t&#x2F;&#x2F;&#x2F;add shadow\n\t\t\t\t\n\t\t\t\tfloat3 lightRes &#x3D;_LightCol*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; env:\n\t\t\t\t\n\n\t\t\t\t&#x2F;&#x2F;计算各部位遮罩\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDir.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\n\n\t\t\t\t&#x2F;&#x2F;混合颜色\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;采样Occlusion贴图\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv);\n\t\t\t\t&#x2F;&#x2F;AO\n\t\t\t\tfloat3 envRes &#x3D; envCol*_BaseCol*_EnvIntensity*occlusion;\n\n\t\t\t\tfloat3 finalRGB &#x3D; lightRes+envRes;\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<blockquote>\n<p>对应课程7-8课内容</p>\n</blockquote>\n<h1 id=\"AO（Ambient-Occlusion）环境光遮蔽\"><a href=\"#AO（Ambient-Occlusion）环境光遮蔽\" class=\"headerlink\" title=\"AO（Ambient Occlusion）环境光遮蔽\"></a>AO（Ambient Occlusion）环境光遮蔽</h1><blockquote>\n<p>AO是来描绘物体和物体<a href=\"https://baike.baidu.com/item/%E7%9B%B8%E4%BA%A4/10077492\">相交</a>或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。可以说：</p>\n<p>AO特效在直观上给我们玩家的感受主要体现在画面的明暗度上，未开启AO特效的画面光照稍亮一些；而开启AO特效之后，局部的细节画面尤其是暗部阴影会更加明显一些。</p>\n</blockquote>\n<h2 id=\"在blender中导出AO贴图\"><a href=\"#在blender中导出AO贴图\" class=\"headerlink\" title=\"在blender中导出AO贴图\"></a>在blender中导出AO贴图</h2><ol>\n<li><p>创建一个新的图片文件。打开图片预览。</p>\n</li>\n<li><p>然后在渲染属性中设置烘焙类型为环境光遮蔽。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817171811952.png\" alt=\"image-20210817171811952\"></p>\n<ol start=\"3\">\n<li><p>烘焙后即可看到AO贴图，另存为图片即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817171900860.png\" alt=\"image-20210817171900860\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3个方向的环境光\"><a href=\"#3个方向的环境光\" class=\"headerlink\" title=\"3个方向的环境光\"></a>3个方向的环境光</h2><p>输出模型法向量的G分量，可得G分量只在模型的顶部（世界空间），范围为[-1,1]。记得和0.0做max运算。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817164458000.png\" alt=\"image-20210817164458000\"></p>\n<p>根据这个思路，用-1*G分量获得的值和0取max则为底部，侧面=1-顶部-底部。然后分别乘三种不同的颜色，把结果相加后再和AO贴图相乘。</p>\n<h3 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817173142732.png\" alt=\"image-20210817173142732\"></p>\n<p>最后获得的结果如图：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817173346922.png\" alt=\"image-20210817173346922\"></p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><blockquote>\n<p><strong>Key Point:</strong></p>\n<ol>\n<li>面板贴图参数定义：<code>_Occlusion(&quot;AO贴图&quot;,2d)= &quot;white&quot; &#123;&#125;</code>  </li>\n</ol>\n<p><code>uniform sampler2D _Occlusion;</code></p>\n<ol start=\"2\">\n<li>输入模型uv0：</li>\n</ol>\n<p> <code>float2 uv0 : TEXCOORD0;//将模型uv信息输入进来，共有4套uv，一般用uv0</code></p>\n<ol start=\"3\">\n<li>输出结构添加uv：</li>\n</ol>\n<p> <code>float2 uv : TEXCOORD1;//追加uv输出用于采样AO贴图</code></p>\n<ol start=\"4\">\n<li>定点着色器对uv赋值：</li>\n</ol>\n<p>  <code>o.uv = v.uv0;</code></p>\n<ol start=\"5\">\n<li>片元着色器中根据输出的uv采样AO贴图：</li>\n</ol>\n<p>  <code>float occlusion=tex2D(_Occlusion,i.uv);</code></p>\n</blockquote>\n<details>\n    <summary>MyThreeColAmbientShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class3&#x2F;MyThreeColAmbientShader&quot;\n&#123;\n    Properties &#123;\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n            &#125;;\n            struct VertexOutput &#123;\n                float4 posCS : SV_POSITION;\n\t\t\t\tfloat3 nDirWS : TEXCOORD0;\n\t\t\t\tfloat2 uv : TEXCOORD1;&#x2F;&#x2F;追加uv输出用于采样AO贴图\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.posCS &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv &#x3D; v.uv0;\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; i.nDirWS;\n\n\t\t\t\t&#x2F;&#x2F;计算各部位遮罩\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDir.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask &#x3D; max(0.0,1-upMask-downMask);\n\n\n\t\t\t\t&#x2F;&#x2F;混合颜色\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;采样Occlusion贴图\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv);\n\t\t\t\t&#x2F;&#x2F;AO\n\t\t\t\tfloat3 finalRGB &#x3D; envCol*occlusion;\n\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a>投影</h1><h2 id=\"Unity内置投影代码调用方法\"><a href=\"#Unity内置投影代码调用方法\" class=\"headerlink\" title=\"Unity内置投影代码调用方法\"></a>Unity内置投影代码调用方法</h2><blockquote>\n<p>注意要包含的库文件：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817181801721.png\" alt=\"image-20210817181801721\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-17-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/image-20210817181543732.png\" alt=\"image-20210817181543732\"></p>\n<h1 id=\"综合应用-简化理解光照的构成\"><a href=\"#综合应用-简化理解光照的构成\" class=\"headerlink\" title=\"综合应用-简化理解光照的构成\"></a>综合应用-简化理解光照的构成</h1><p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205326280.png\" alt=\"image-20210817205326280\"></p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205548075.png\" alt=\"image-20210817205548075\"></p>\n<p>对于上述模型，把之前学习的内容结合起来：</p>\n<p>注意Lambert+Phong之后要和光源遮挡相乘之后才得到光源的结果。</p>\n<p><img src=\"D:\\Blog\\blog\\images\\2021-08-17-庄懂的技术美术入门课学习笔记（三）\\image-20210817205808746.png\" alt=\"image-20210817205808746\"></p>\n<h2 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h2><details>\n    <summary>OldSchoolPlusShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class3&#x2F;OldSchoolPlusShader&quot;\n&#123;\n    Properties &#123;\n\t\t_BaseCol(&quot;基本颜色&quot;,color)&#x3D;(1.0,0.0,0.0,1.0)\n\t\t_LightCol(&quot;光照颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_Intensity(&quot;光照强度&quot;,range(0,5))&#x3D;1\n\n\t\t_EnvIntensity(&quot;环境光强度&quot;,range(0,5))&#x3D;1\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\tuniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat4 posWS : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat2 uv : TEXCOORD2;&#x2F;&#x2F;追加uv输出用于采样AO贴图\n\t\t\t\tLIGHTING_COORDS(3,4)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.uv &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\t\t\t\tfloat3 nDir &#x3D; normalize(i.nDirWS);\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\tfloat3 vDir &#x3D; normalize(_WorldSpaceCameraPos.xyz-i.posWS.xyz);\n\t\t\t\tfloat3 rDir &#x3D; reflect(-lDir,nDir);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Light:\n\t\t\t\tfloat nDotl &#x3D; dot(nDir,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDir,rDir);\n\n\t\t\t\tfloat lambert &#x3D; max(0.0,nDotl);\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t&#x2F;&#x2F;&#x2F;add shadow\n\t\t\t\t\n\t\t\t\tfloat3 lightRes &#x3D;_LightCol*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; env:\n\t\t\t\t\n\n\t\t\t\t&#x2F;&#x2F;计算各部位遮罩\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDir.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDir.g);\n\t\t\t\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\n\n\t\t\t\t&#x2F;&#x2F;混合颜色\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;采样Occlusion贴图\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv);\n\t\t\t\t&#x2F;&#x2F;AO\n\t\t\t\tfloat3 envRes &#x3D; envCol*_BaseCol*_EnvIntensity*occlusion;\n\n\t\t\t\tfloat3 finalRGB &#x3D; lightRes+envRes;\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n"},{"title":"2021-08-19-庄懂的技术美术入门课学习笔记（五）","date":"2021-08-19T11:46:42.000Z","_content":"\n# 代码总结\n\n> 对应课程11课内容\n\n## 参数\n\n### 参数格式\n\n![image-20210816235743704](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816235743704.png)\n\n#### 面板参数声明格式\n\n![image-20210819200128414](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819200128414.png)\n\n#### 参数属性\n\n注意是HideInInspector↓\n\n![image-20210819200240084](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819200240084.png)\n\n![image-20210819203303668](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819203303668.png)\n\n#### 参数类型\n\n![image-20210819210301451](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210301451.png)\n\n![image-20210819210658871](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210658871.png)\n\n## 输入结构\n\n![image-20210819210911711](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210911711.png)\n\n## 输出结构\n\n![image-20210819210955175](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210955175.png)\n\n## 常用顶点Shader操作\n\n![image-20210819213002880](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819213002880.png)\n\n<div class=\"warning\">\n\n> 原本贴图的Tiling和offset是无效的，以_MainTex为例，需要在`uniform sampler2D _MainTex`后面定义`uniform sampler2D _MainTex_ST;`，然后在顶点shader中写`o.uv0 = TRANSFORM_TEX(v.uv0,_MainTex);`\n>\n> 等效于o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;\n>\n> 注意顶点shader中不需要_ST！！上面写错了！\n\n</div>\n\n## 常用方法归纳\n\n### 定义cginc文件\n\n![image-20210819213900896](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819213900896.png)\n\n<div class=\"warning\">\n\n> 方法需要定义在使用前\n\n</div>\n\n<details>\n    <summary>MyCginc.cginc</summary>\n\n```c#\n#ifndef MY_CGINC\n#define MY_CGINC\n\n//三颜色（顶侧底)环境光方法\nfloat3 TriColAmbient(float3 n,float3 uCol, float3 sCol, float3 dCol){\n\tfloat upMask = max(0.0,n.g);\n\tfloat downMask = max(0.0,-n.g);\n\tfloat sideMask = 1.0-upMask-downMask;\n\tfloat3 envCol= uCol*upMask+sCol*downMask+dCol*sideMask;\n\treturn envCol;\n}\n\n#endif\n```\n\n</details>\n\n在shader中引用库文件：`#include \"../cginc/MyCginc.cginc\"`\n\n","source":"_posts/2021-08-19-庄懂的技术美术入门课学习笔记（五）.md","raw":"---\ntitle: 2021-08-19-庄懂的技术美术入门课学习笔记（五）\ndate: 2021-08-19 19:46:42\ntags:\n  - 参数\n  - 输入类型\n  - 输出类型\n  - 顶点操作\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n# 代码总结\n\n> 对应课程11课内容\n\n## 参数\n\n### 参数格式\n\n![image-20210816235743704](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-庄懂的技术美术入门课学习笔记（二）/image-20210816235743704.png)\n\n#### 面板参数声明格式\n\n![image-20210819200128414](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819200128414.png)\n\n#### 参数属性\n\n注意是HideInInspector↓\n\n![image-20210819200240084](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819200240084.png)\n\n![image-20210819203303668](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819203303668.png)\n\n#### 参数类型\n\n![image-20210819210301451](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210301451.png)\n\n![image-20210819210658871](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210658871.png)\n\n## 输入结构\n\n![image-20210819210911711](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210911711.png)\n\n## 输出结构\n\n![image-20210819210955175](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819210955175.png)\n\n## 常用顶点Shader操作\n\n![image-20210819213002880](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819213002880.png)\n\n<div class=\"warning\">\n\n> 原本贴图的Tiling和offset是无效的，以_MainTex为例，需要在`uniform sampler2D _MainTex`后面定义`uniform sampler2D _MainTex_ST;`，然后在顶点shader中写`o.uv0 = TRANSFORM_TEX(v.uv0,_MainTex);`\n>\n> 等效于o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;\n>\n> 注意顶点shader中不需要_ST！！上面写错了！\n\n</div>\n\n## 常用方法归纳\n\n### 定义cginc文件\n\n![image-20210819213900896](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（五）/image-20210819213900896.png)\n\n<div class=\"warning\">\n\n> 方法需要定义在使用前\n\n</div>\n\n<details>\n    <summary>MyCginc.cginc</summary>\n\n```c#\n#ifndef MY_CGINC\n#define MY_CGINC\n\n//三颜色（顶侧底)环境光方法\nfloat3 TriColAmbient(float3 n,float3 uCol, float3 sCol, float3 dCol){\n\tfloat upMask = max(0.0,n.g);\n\tfloat downMask = max(0.0,-n.g);\n\tfloat sideMask = 1.0-upMask-downMask;\n\tfloat3 envCol= uCol*upMask+sCol*downMask+dCol*sideMask;\n\treturn envCol;\n}\n\n#endif\n```\n\n</details>\n\n在shader中引用库文件：`#include \"../cginc/MyCginc.cginc\"`\n\n","slug":"2021-08-19-庄懂的技术美术入门课学习笔记（五）","published":1,"updated":"2021-08-29T08:58:22.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100lx002h3svo5i5ie6y0","content":"<h1 id=\"代码总结\"><a href=\"#代码总结\" class=\"headerlink\" title=\"代码总结\"></a>代码总结</h1><blockquote>\n<p>对应课程11课内容</p>\n</blockquote>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"参数格式\"><a href=\"#参数格式\" class=\"headerlink\" title=\"参数格式\"></a>参数格式</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816235743704.png\" alt=\"image-20210816235743704\" loading=\"lazy\"></p>\n<h4 id=\"面板参数声明格式\"><a href=\"#面板参数声明格式\" class=\"headerlink\" title=\"面板参数声明格式\"></a>面板参数声明格式</h4><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819200128414.png\" alt=\"image-20210819200128414\" loading=\"lazy\"></p>\n<h4 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h4><p>注意是HideInInspector↓</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819200240084.png\" alt=\"image-20210819200240084\" loading=\"lazy\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819203303668.png\" alt=\"image-20210819203303668\" loading=\"lazy\"></p>\n<h4 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h4><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210301451.png\" alt=\"image-20210819210301451\" loading=\"lazy\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210658871.png\" alt=\"image-20210819210658871\" loading=\"lazy\"></p>\n<h2 id=\"输入结构\"><a href=\"#输入结构\" class=\"headerlink\" title=\"输入结构\"></a>输入结构</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210911711.png\" alt=\"image-20210819210911711\" loading=\"lazy\"></p>\n<h2 id=\"输出结构\"><a href=\"#输出结构\" class=\"headerlink\" title=\"输出结构\"></a>输出结构</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210955175.png\" alt=\"image-20210819210955175\" loading=\"lazy\"></p>\n<h2 id=\"常用顶点Shader操作\"><a href=\"#常用顶点Shader操作\" class=\"headerlink\" title=\"常用顶点Shader操作\"></a>常用顶点Shader操作</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819213002880.png\" alt=\"image-20210819213002880\" loading=\"lazy\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>原本贴图的Tiling和offset是无效的，以_MainTex为例，需要在<code>uniform sampler2D _MainTex</code>后面定义<code>uniform sampler2D _MainTex_ST;</code>，然后在顶点shader中写<code>o.uv0 = TRANSFORM_TEX(v.uv0,_MainTex);</code></p>\n<p>等效于o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;</p>\n<p>注意顶点shader中不需要_ST！！上面写错了！</p>\n</blockquote>\n</div>\n\n<h2 id=\"常用方法归纳\"><a href=\"#常用方法归纳\" class=\"headerlink\" title=\"常用方法归纳\"></a>常用方法归纳</h2><h3 id=\"定义cginc文件\"><a href=\"#定义cginc文件\" class=\"headerlink\" title=\"定义cginc文件\"></a>定义cginc文件</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819213900896.png\" alt=\"image-20210819213900896\" loading=\"lazy\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>方法需要定义在使用前</p>\n</blockquote>\n</div>\n\n<details>\n    <summary>MyCginc.cginc</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">#ifndef MY_CGINC\n#define MY_CGINC\n\n&#x2F;&#x2F;三颜色（顶侧底)环境光方法\nfloat3 TriColAmbient(float3 n,float3 uCol, float3 sCol, float3 dCol)&#123;\n\tfloat upMask &#x3D; max(0.0,n.g);\n\tfloat downMask &#x3D; max(0.0,-n.g);\n\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\tfloat3 envCol&#x3D; uCol*upMask+sCol*downMask+dCol*sideMask;\n\treturn envCol;\n&#125;\n\n#endif<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<p>在shader中引用库文件：<code>#include &quot;../cginc/MyCginc.cginc&quot;</code></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<h1 id=\"代码总结\"><a href=\"#代码总结\" class=\"headerlink\" title=\"代码总结\"></a>代码总结</h1><blockquote>\n<p>对应课程11课内容</p>\n</blockquote>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"参数格式\"><a href=\"#参数格式\" class=\"headerlink\" title=\"参数格式\"></a>参数格式</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-16-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20210816235743704.png\" alt=\"image-20210816235743704\"></p>\n<h4 id=\"面板参数声明格式\"><a href=\"#面板参数声明格式\" class=\"headerlink\" title=\"面板参数声明格式\"></a>面板参数声明格式</h4><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819200128414.png\" alt=\"image-20210819200128414\"></p>\n<h4 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h4><p>注意是HideInInspector↓</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819200240084.png\" alt=\"image-20210819200240084\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819203303668.png\" alt=\"image-20210819203303668\"></p>\n<h4 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h4><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210301451.png\" alt=\"image-20210819210301451\"></p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210658871.png\" alt=\"image-20210819210658871\"></p>\n<h2 id=\"输入结构\"><a href=\"#输入结构\" class=\"headerlink\" title=\"输入结构\"></a>输入结构</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210911711.png\" alt=\"image-20210819210911711\"></p>\n<h2 id=\"输出结构\"><a href=\"#输出结构\" class=\"headerlink\" title=\"输出结构\"></a>输出结构</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819210955175.png\" alt=\"image-20210819210955175\"></p>\n<h2 id=\"常用顶点Shader操作\"><a href=\"#常用顶点Shader操作\" class=\"headerlink\" title=\"常用顶点Shader操作\"></a>常用顶点Shader操作</h2><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819213002880.png\" alt=\"image-20210819213002880\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>原本贴图的Tiling和offset是无效的，以_MainTex为例，需要在<code>uniform sampler2D _MainTex</code>后面定义<code>uniform sampler2D _MainTex_ST;</code>，然后在顶点shader中写<code>o.uv0 = TRANSFORM_TEX(v.uv0,_MainTex);</code></p>\n<p>等效于o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;</p>\n<p>注意顶点shader中不需要_ST！！上面写错了！</p>\n</blockquote>\n</div>\n\n<h2 id=\"常用方法归纳\"><a href=\"#常用方法归纳\" class=\"headerlink\" title=\"常用方法归纳\"></a>常用方法归纳</h2><h3 id=\"定义cginc文件\"><a href=\"#定义cginc文件\" class=\"headerlink\" title=\"定义cginc文件\"></a>定义cginc文件</h3><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/image-20210819213900896.png\" alt=\"image-20210819213900896\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>方法需要定义在使用前</p>\n</blockquote>\n</div>\n\n<details>\n    <summary>MyCginc.cginc</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">#ifndef MY_CGINC\n#define MY_CGINC\n\n&#x2F;&#x2F;三颜色（顶侧底)环境光方法\nfloat3 TriColAmbient(float3 n,float3 uCol, float3 sCol, float3 dCol)&#123;\n\tfloat upMask &#x3D; max(0.0,n.g);\n\tfloat downMask &#x3D; max(0.0,-n.g);\n\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\tfloat3 envCol&#x3D; uCol*upMask+sCol*downMask+dCol*sideMask;\n\treturn envCol;\n&#125;\n\n#endif<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<p>在shader中引用库文件：<code>#include &quot;../cginc/MyCginc.cginc&quot;</code></p>\n"},{"title":"2021-08-20-庄懂的技术美术入门课学习笔记（六）","date":"2021-08-20T14:27:31.000Z","_content":"\n# 完整任务-Hero Shader In Dota2\n\n[链接](https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish#overview)\n\n[模型下载](https://www.dota2.com/workshop/requirements/ogre_magi)\n\n# 资源优化\n\n可以直接在ps通道里面操作。把图像转为灰度格式，然后选中用来合并的文件的r/g/b通道，粘贴图像。\n\n在输出时输出**tga图像**，勾选**alpha通道**，并选择**32位**格式。\n\n在unity导入图片时不要勾选alpha is transparency。\n\n1. 将basecolor 和 translucency贴图合并为一张。transluency作为alpha通道。\n\n   ![image-20210821200527858](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200527858.png)\n\n2. specularMask，RimMask，TinyBaseMask，SpecularExponent作为RGBA四个通道合并为一张。注意处理图片上下翻转的问题。\n\n   ![image-20210821200700134](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200700134.png)\n\n3. FresnelWrapColor，FresnelWrapRim，FresnelWrapSpec作为RGB通道合并为一张。\n\n   ![image-20210821200826441](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200826441.png)\n\n4. 剩下一系列图片都类似处理一遍。\n\n# 属性面板\n\n```c#\n    Properties {\n\t\t[Header(Texture)]\n\t\t_MainTex(\"RGB:颜色,A:透贴\",2D )= \"white\" {}\n\t\t_MaskTex(\"R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂\")=\"white\"{}\n\t\t[Normal]_NormTex(\"法线贴图\",2D) = \"bump\" {}\n\t\t_MetalnessMask(\"金属度遮罩\",2D) = \"black\" {}\n\t\t_EmissionMask(\"自发光遮罩\",2D) = \"black\" {}\n\t\t_DiffuseWrapTex(\"颜色Wrap图\",2D) = \"gray\"{}\n\t\t_FresnelWrapTex(\"菲涅尔Wrap图\",2D) = \"gray\"{}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t}\n```\n\n# 向量准备和获取贴图信息\n\n> 注意这里使用specInt对cubemapMip做插值。\n\n```c#\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n\t\t\t\t//采样纹理\n\t\t\t\thalf4 mainTex = tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex = tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可\n\t\t\t\thalf emissionMask = tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);//注意用vDotn来采样\n\n\t\t\t\t//获取信息\n\t\t\t\thalf3 baseColor = mainTex.rgb;\n\t\t\t\thalf opacity = mainTex.a;\n\t\t\t\thalf specInt = maskTex.r;\n\t\t\t\thalf rimInt = maskTex.g;\n\t\t\t\thalf specTint = maskTex.b;\n\t\t\t\thalf specExp = maskTex.a;\n```\n\n# 光照模型\n\n![image-20210821220939073](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821220939073.png)\n\n\n\n## 漫反射和镜面反射颜色\n\n> specTint指高光染色，一般只有金属的高光有颜色。\n>\n> 所以将漫反射和镜面反射分开来处理，分别用metalnessMask和specTint来做插值。\n\n```c#\n//漫反射颜色用metalness，镜面反射颜色用tintmask\nhalf3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\nhalf3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n```\n\n## Fresnel的处理\n\n> 金属的fresnel程度比较弱，所以插值时根据matellic来插值，注意顺序。\n\n![image-20210821222652945](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821222652945.png)\n\n```c#\n//Fresnel\nhalf3 fresnel = lerp(fresnelTex,0.0,metalnessMask);\nhalf fresnelCol = fresnel.r;\nhalf fresnelRim = fresnel.g;//轮廓光\nhalf fresnelSpec = fresnel.b;//镜面反射用\n```\n\n输出fresnel的效果如图，可以看见金属部分的fresnel效果被明显削弱。\n\n![image-20210821223506595](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821223506595.png)\n\n\n\n## 主光\n\n### 漫反射：使用Diffuse Mask\n\n第一节课学习的内容，用一个常数和halfLambert组成uv坐标，对该图片采样。\n\n`half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));`\n\n这样可以给皮肤叠加3S效果。上面采样的结果如下：\n\n![image-20210822112047972](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822112047972.png)\n\n```c#\n//主光：halflambert\nhalf halfLambert = nDotl*0.5+0.5;\nhalf3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\nhalf3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;//记得乘主光颜色\n```\n\n\n\n### 镜面反射\n\n由于美术给的贴图的SpecExp范围在0-1，不足以控制高光次幂的范围，所以需要在属性面板上添加一个_SpecPow来调节。\n\n高光强度同样加一个_SpecInt调节。\n\n```c#\n[Header(Specular)]\n[PowerSlider(2)] _SpecPow(\"高光次幂\",range(1,90))= 30\n_SpecInt(\"高光强度\",range(0.0,10.0))=5.0\n```\n\n计算主光镜面反射步骤：\n\n> 注意phong的结果要和fresnelSpec混合起来，混合的方式是max，也可以相加\n\n```c#\n//镜面反射\n//主光\nhalf phong = pow(max(0.0,vDotr),specExp*_SpecPow);\nhalf spec = phong*max(0.0,nDotl);//Phong*Lambert\nspec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max\nspec = spec*_SpecInt;//乘一个高光强度方便调节范围\nhalf3 dirSpec = specCol*spec*_LightColor0;//记得乘主光颜色\n```\n\n得到结果：\n\n![image-20210822120043210](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822120043210.png)\n\n## 环境光\n\n### 漫反射\n\n```c#\n//环境：单色光\nhalf3 envDiff = _EnvCol*_EnvDiffInt*diffCol;//环境光颜色*环境光漫反射强度*漫反射颜色\n```\n\n### 镜面反射\n\n使用cubemap\n\n1. 计算反射率：考虑非金属（fresnel）和金属（metalness）的最大值\n2. 混合高光颜色，反射率、反射环境和强度\n\n```c#\n//cubemap\nhalf reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\nhalf envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度\n```\n\n## 轮廓光\n\n> 只保留角色上半部分的轮廓光：乘max(0.0,nDirWS.g)\n>\n> 定义轮廓光时使用HDR，使其可以直接调强度。\n\n```c#\n//轮廓光\nhalf3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n```\n\n![image-20210822124126070](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822124126070.png)\n\n## 自发光\n\n```c#\n//Emission\nhalf3 emissionRes = diffCol*_EmissionInt*emissionMask;\n```\n\n# 透明剪切\n\n添加_Cutoff属性。\n\n```c#\n[HideInInspector] _Cutoff(\"Alpha cutoff\",range(0.0,1.0)) = 0.5//必须叫_Cutoff,不能有差别\n    \n\nclip(opacity - _Cutoff);\n```\n\n![image-20210822153014157](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153014157.png)\n\n## 透明剪切投影修正\n\n此时透明剪切的投影是错误的。\n\n原因是原来Fallback 到“Diffuse”，投影不支持剪切。\n\n```c#\n//在属性面板中添加_Color\n[HideInInspector] _Color(\"Main Color\",Color) = (1.0,1.0,1.0,1.0)\nuniform half _Color;\n\n//声明正确的回退shader\nFallBack \"Legacy Shaders/Transparent/Cutout/VertexLit\"\n```\n\n![image-20210822153513102](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153513102.png)\n\n# 开启双面显示\n\n在PassTags后面声明`Cull off`即可。\n\n![image-20210822153833360](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153833360.png)\n\n# 完整代码\n\n<details>\n    <summary>MagiShader.shader</summary>\n\n```c#\nShader \"Magi/MagiShader\"\n{\n    Properties {\n\t\t[Header(Texture)]\n\t\t_MainTex(\"RGB:颜色,A:透贴\",2D )= \"white\" {}\n\t\t_MaskTex(\"R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂\",2D)=\"white\"{}\n\t\t[Normal]_NormTex(\"法线贴图\",2D) = \"bump\" {}\n\t\t_MetalnessMask(\"金属度遮罩\",2D) = \"black\" {}\n\t\t_EmissionMask(\"自发光遮罩\",2D) = \"black\" {}\n\t\t_DiffuseWrapTex(\"颜色Wrap图\",2D) = \"gray\"{}\n\t\t_FresnelWrapTex(\"菲涅尔Wrap图\",2D) = \"gray\"{}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t[Header(Diffuse)]\n\t\t_EnvCol(\"环境光颜色\",color)=(1.0,1.0,1.0,1.0)\n\n\t\t[Header(Specular)]\n\t\t[PowerSlider(2)] _SpecPow(\"高光次幂\",range(1,90))= 30\n\t\t_SpecInt(\"高光强度\",range(0.0,10.0))=5.0\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0.0,10.0))=1.0\n\n\t\t[Header(RimLight)]\n\t\t[HDR] _RimCol(\"轮廓光颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t[Header(Emission)]\n\t\t_EmissionInt(\"自发光强度\",range(0.0,10.0))=1.0\n\n\t\t[HideInInspector] _Cutoff(\"Alpha cutoff\",range(0.0,1.0)) = 0.5\n\t\t[HideInInspector] _Color(\"Main Color\",Color) = (1.0,1.0,1.0,1.0)\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            Cull off\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n\n\t\t\t#include \"../cginc/MyCginc.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\t//texture\n\t\t\tuniform sampler2D _MainTex;\n\t\t\tuniform sampler2D _MaskTex;\n\t\t\tuniform sampler2D _NormTex;\n\t\t\tuniform sampler2D _MetalnessMask;\n\t\t\tuniform sampler2D _EmissionMask;\n\t\t\tuniform sampler2D _DiffuseWrapTex;\n\t\t\tuniform sampler2D _FresnelWrapTex;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\t//DIFFUSE\n\t\t\tuniform half3 _EnvCol;\n\n\t\t\t//SPECULAR\n\t\t\tuniform half _SpecPow;\n\t\t\tuniform half _SpecInt;\n\t\t\tuniform half _EnvSpecInt;\n\n\t\t\t//rimLight\n\t\t\tuniform half3 _RimCol;\n\n\t\t\t//Emission\n\t\t\tuniform half _EmissionInt;\n\t\t\t\n\t\t\tuniform half _Cutoff;\n\t\t\tuniform half _Color;\n\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n\n\t\t\t\tfloat nDotl = dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr = dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn = dot(vDirWS,nDirWS);\n\n\t\t\t\t//采样纹理\n\t\t\t\thalf4 mainTex = tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex = tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可\n\t\t\t\thalf emissionMask = tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);\n\t\t\t\t//获取信息\n\t\t\t\thalf3 baseColor = mainTex.rgb;\n\t\t\t\thalf opacity = mainTex.a;\n\t\t\t\thalf specInt = maskTex.r;\n\t\t\t\thalf rimInt = maskTex.g;\n\t\t\t\thalf specTint = maskTex.b;\n\t\t\t\thalf specExp = maskTex.a;\n\n\t\t\t\t//漫反射颜色用metalness，镜面反射颜色用tintmask\n\t\t\t\thalf3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\n\t\t\t\thalf3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n\n\t\t\t\t//Fresnel\n\t\t\t\thalf3 fresnel = lerp(fresnelTex,0.0,metalnessMask);\n\t\t\t\thalf fresnelCol = fresnel.r;\n\t\t\t\thalf fresnelRim = fresnel.g;//轮廓光\n\t\t\t\thalf fresnelSpec = fresnel.b;//镜面反射用\n\n\n\t\t\t\t//镜面反射\n\t\t\t\t//主光\n\t\t\t\thalf phong = pow(max(0.0,vDotr),specExp*_SpecPow);\n\t\t\t\thalf spec = phong*max(0.0,nDotl);//Phong*Lambert\n\t\t\t\tspec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max\n\t\t\t\tspec = spec*_SpecInt;//乘一个高光强度方便调节范围\n\t\t\t\thalf3 dirSpec = specCol*spec*_LightColor0;\n\t\t\t\t//cubemap\n\t\t\t\thalf reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\n\t\t\t\thalf3 envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度\n\n\t\t\t\t//fresnel\n\t\t\t\thalf3 specRes = dirSpec*shadow+envSpec;\n\n\t\t\t\t//漫反射\n\t\t\t\t//主光：halflambert\n\t\t\t\thalf halfLambert = nDotl*0.5+0.5;\n\t\t\t\thalf3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\n\t\t\t\thalf3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;\n\t\t\t\t//环境：单色光\n\t\t\t\thalf3 envDiff = _EnvCol*diffCol;//环境光颜色*漫反射颜色\n\t\t\t\thalf3 diffRes = dirDiff*shadow+envDiff;\n\n\t\t\t\t//轮廓光\n\t\t\t\thalf3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n\t\t\t\n\t\t\t\t//Emission\n\t\t\t\thalf3 emissionRes = diffCol*_EmissionInt*emissionMask;\n\n\t\t\t\tclip(opacity - _Cutoff);\n\n\t\t\t\thalf3 res = specRes+diffRes+rimLight+emissionRes;\n\n                return float4(res,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n\t//声明正确的回退shader\n    FallBack \"Legacy Shaders/Transparent/Cutout/VertexLit\"\n}\n\n```\n\n</details>\n\n#  最终效果\n\n\n\n![image-20210822170059378](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822170059378.png)\n","source":"_posts/2021-08-20-庄懂的技术美术入门课学习笔记（六）.md","raw":"---\ntitle: 2021-08-20-庄懂的技术美术入门课学习笔记（六）\ndate: 2021-08-20 22:27:31\ntags:\n  - Hero Shader In Dota2\n  - 贴图使用\n  - 透明剪切\n  - 轮廓光\n  - 自发光\n  - 双面显示\n  - 贴图资源优化\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n# 完整任务-Hero Shader In Dota2\n\n[链接](https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish#overview)\n\n[模型下载](https://www.dota2.com/workshop/requirements/ogre_magi)\n\n# 资源优化\n\n可以直接在ps通道里面操作。把图像转为灰度格式，然后选中用来合并的文件的r/g/b通道，粘贴图像。\n\n在输出时输出**tga图像**，勾选**alpha通道**，并选择**32位**格式。\n\n在unity导入图片时不要勾选alpha is transparency。\n\n1. 将basecolor 和 translucency贴图合并为一张。transluency作为alpha通道。\n\n   ![image-20210821200527858](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200527858.png)\n\n2. specularMask，RimMask，TinyBaseMask，SpecularExponent作为RGBA四个通道合并为一张。注意处理图片上下翻转的问题。\n\n   ![image-20210821200700134](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200700134.png)\n\n3. FresnelWrapColor，FresnelWrapRim，FresnelWrapSpec作为RGB通道合并为一张。\n\n   ![image-20210821200826441](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821200826441.png)\n\n4. 剩下一系列图片都类似处理一遍。\n\n# 属性面板\n\n```c#\n    Properties {\n\t\t[Header(Texture)]\n\t\t_MainTex(\"RGB:颜色,A:透贴\",2D )= \"white\" {}\n\t\t_MaskTex(\"R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂\")=\"white\"{}\n\t\t[Normal]_NormTex(\"法线贴图\",2D) = \"bump\" {}\n\t\t_MetalnessMask(\"金属度遮罩\",2D) = \"black\" {}\n\t\t_EmissionMask(\"自发光遮罩\",2D) = \"black\" {}\n\t\t_DiffuseWrapTex(\"颜色Wrap图\",2D) = \"gray\"{}\n\t\t_FresnelWrapTex(\"菲涅尔Wrap图\",2D) = \"gray\"{}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t}\n```\n\n# 向量准备和获取贴图信息\n\n> 注意这里使用specInt对cubemapMip做插值。\n\n```c#\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n\t\t\t\t//采样纹理\n\t\t\t\thalf4 mainTex = tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex = tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可\n\t\t\t\thalf emissionMask = tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);//注意用vDotn来采样\n\n\t\t\t\t//获取信息\n\t\t\t\thalf3 baseColor = mainTex.rgb;\n\t\t\t\thalf opacity = mainTex.a;\n\t\t\t\thalf specInt = maskTex.r;\n\t\t\t\thalf rimInt = maskTex.g;\n\t\t\t\thalf specTint = maskTex.b;\n\t\t\t\thalf specExp = maskTex.a;\n```\n\n# 光照模型\n\n![image-20210821220939073](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821220939073.png)\n\n\n\n## 漫反射和镜面反射颜色\n\n> specTint指高光染色，一般只有金属的高光有颜色。\n>\n> 所以将漫反射和镜面反射分开来处理，分别用metalnessMask和specTint来做插值。\n\n```c#\n//漫反射颜色用metalness，镜面反射颜色用tintmask\nhalf3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\nhalf3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n```\n\n## Fresnel的处理\n\n> 金属的fresnel程度比较弱，所以插值时根据matellic来插值，注意顺序。\n\n![image-20210821222652945](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821222652945.png)\n\n```c#\n//Fresnel\nhalf3 fresnel = lerp(fresnelTex,0.0,metalnessMask);\nhalf fresnelCol = fresnel.r;\nhalf fresnelRim = fresnel.g;//轮廓光\nhalf fresnelSpec = fresnel.b;//镜面反射用\n```\n\n输出fresnel的效果如图，可以看见金属部分的fresnel效果被明显削弱。\n\n![image-20210821223506595](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-庄懂的技术美术入门课学习笔记（六）/image-20210821223506595.png)\n\n\n\n## 主光\n\n### 漫反射：使用Diffuse Mask\n\n第一节课学习的内容，用一个常数和halfLambert组成uv坐标，对该图片采样。\n\n`half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));`\n\n这样可以给皮肤叠加3S效果。上面采样的结果如下：\n\n![image-20210822112047972](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822112047972.png)\n\n```c#\n//主光：halflambert\nhalf halfLambert = nDotl*0.5+0.5;\nhalf3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\nhalf3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;//记得乘主光颜色\n```\n\n\n\n### 镜面反射\n\n由于美术给的贴图的SpecExp范围在0-1，不足以控制高光次幂的范围，所以需要在属性面板上添加一个_SpecPow来调节。\n\n高光强度同样加一个_SpecInt调节。\n\n```c#\n[Header(Specular)]\n[PowerSlider(2)] _SpecPow(\"高光次幂\",range(1,90))= 30\n_SpecInt(\"高光强度\",range(0.0,10.0))=5.0\n```\n\n计算主光镜面反射步骤：\n\n> 注意phong的结果要和fresnelSpec混合起来，混合的方式是max，也可以相加\n\n```c#\n//镜面反射\n//主光\nhalf phong = pow(max(0.0,vDotr),specExp*_SpecPow);\nhalf spec = phong*max(0.0,nDotl);//Phong*Lambert\nspec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max\nspec = spec*_SpecInt;//乘一个高光强度方便调节范围\nhalf3 dirSpec = specCol*spec*_LightColor0;//记得乘主光颜色\n```\n\n得到结果：\n\n![image-20210822120043210](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822120043210.png)\n\n## 环境光\n\n### 漫反射\n\n```c#\n//环境：单色光\nhalf3 envDiff = _EnvCol*_EnvDiffInt*diffCol;//环境光颜色*环境光漫反射强度*漫反射颜色\n```\n\n### 镜面反射\n\n使用cubemap\n\n1. 计算反射率：考虑非金属（fresnel）和金属（metalness）的最大值\n2. 混合高光颜色，反射率、反射环境和强度\n\n```c#\n//cubemap\nhalf reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\nhalf envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度\n```\n\n## 轮廓光\n\n> 只保留角色上半部分的轮廓光：乘max(0.0,nDirWS.g)\n>\n> 定义轮廓光时使用HDR，使其可以直接调强度。\n\n```c#\n//轮廓光\nhalf3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n```\n\n![image-20210822124126070](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822124126070.png)\n\n## 自发光\n\n```c#\n//Emission\nhalf3 emissionRes = diffCol*_EmissionInt*emissionMask;\n```\n\n# 透明剪切\n\n添加_Cutoff属性。\n\n```c#\n[HideInInspector] _Cutoff(\"Alpha cutoff\",range(0.0,1.0)) = 0.5//必须叫_Cutoff,不能有差别\n    \n\nclip(opacity - _Cutoff);\n```\n\n![image-20210822153014157](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153014157.png)\n\n## 透明剪切投影修正\n\n此时透明剪切的投影是错误的。\n\n原因是原来Fallback 到“Diffuse”，投影不支持剪切。\n\n```c#\n//在属性面板中添加_Color\n[HideInInspector] _Color(\"Main Color\",Color) = (1.0,1.0,1.0,1.0)\nuniform half _Color;\n\n//声明正确的回退shader\nFallBack \"Legacy Shaders/Transparent/Cutout/VertexLit\"\n```\n\n![image-20210822153513102](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153513102.png)\n\n# 开启双面显示\n\n在PassTags后面声明`Cull off`即可。\n\n![image-20210822153833360](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822153833360.png)\n\n# 完整代码\n\n<details>\n    <summary>MagiShader.shader</summary>\n\n```c#\nShader \"Magi/MagiShader\"\n{\n    Properties {\n\t\t[Header(Texture)]\n\t\t_MainTex(\"RGB:颜色,A:透贴\",2D )= \"white\" {}\n\t\t_MaskTex(\"R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂\",2D)=\"white\"{}\n\t\t[Normal]_NormTex(\"法线贴图\",2D) = \"bump\" {}\n\t\t_MetalnessMask(\"金属度遮罩\",2D) = \"black\" {}\n\t\t_EmissionMask(\"自发光遮罩\",2D) = \"black\" {}\n\t\t_DiffuseWrapTex(\"颜色Wrap图\",2D) = \"gray\"{}\n\t\t_FresnelWrapTex(\"菲涅尔Wrap图\",2D) = \"gray\"{}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t[Header(Diffuse)]\n\t\t_EnvCol(\"环境光颜色\",color)=(1.0,1.0,1.0,1.0)\n\n\t\t[Header(Specular)]\n\t\t[PowerSlider(2)] _SpecPow(\"高光次幂\",range(1,90))= 30\n\t\t_SpecInt(\"高光强度\",range(0.0,10.0))=5.0\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0.0,10.0))=1.0\n\n\t\t[Header(RimLight)]\n\t\t[HDR] _RimCol(\"轮廓光颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t[Header(Emission)]\n\t\t_EmissionInt(\"自发光强度\",range(0.0,10.0))=1.0\n\n\t\t[HideInInspector] _Cutoff(\"Alpha cutoff\",range(0.0,1.0)) = 0.5\n\t\t[HideInInspector] _Color(\"Main Color\",Color) = (1.0,1.0,1.0,1.0)\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            Cull off\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n\n\t\t\t#include \"../cginc/MyCginc.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\t//texture\n\t\t\tuniform sampler2D _MainTex;\n\t\t\tuniform sampler2D _MaskTex;\n\t\t\tuniform sampler2D _NormTex;\n\t\t\tuniform sampler2D _MetalnessMask;\n\t\t\tuniform sampler2D _EmissionMask;\n\t\t\tuniform sampler2D _DiffuseWrapTex;\n\t\t\tuniform sampler2D _FresnelWrapTex;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\t//DIFFUSE\n\t\t\tuniform half3 _EnvCol;\n\n\t\t\t//SPECULAR\n\t\t\tuniform half _SpecPow;\n\t\t\tuniform half _SpecInt;\n\t\t\tuniform half _EnvSpecInt;\n\n\t\t\t//rimLight\n\t\t\tuniform half3 _RimCol;\n\n\t\t\t//Emission\n\t\t\tuniform half _EmissionInt;\n\t\t\t\n\t\t\tuniform half _Cutoff;\n\t\t\tuniform half _Color;\n\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n\n\t\t\t\tfloat nDotl = dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr = dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn = dot(vDirWS,nDirWS);\n\n\t\t\t\t//采样纹理\n\t\t\t\thalf4 mainTex = tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex = tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask = tex2D(_MetalnessMask,i.uv0).r;//取一个通道即可\n\t\t\t\thalf emissionMask = tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip=lerp(8.0,1.0,maskTex.a);  //使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex = tex2D(_FresnelWrapTex,vDotn);\n\t\t\t\t//获取信息\n\t\t\t\thalf3 baseColor = mainTex.rgb;\n\t\t\t\thalf opacity = mainTex.a;\n\t\t\t\thalf specInt = maskTex.r;\n\t\t\t\thalf rimInt = maskTex.g;\n\t\t\t\thalf specTint = maskTex.b;\n\t\t\t\thalf specExp = maskTex.a;\n\n\t\t\t\t//漫反射颜色用metalness，镜面反射颜色用tintmask\n\t\t\t\thalf3 diffCol = lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\n\t\t\t\thalf3 specCol = lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n\n\t\t\t\t//Fresnel\n\t\t\t\thalf3 fresnel = lerp(fresnelTex,0.0,metalnessMask);\n\t\t\t\thalf fresnelCol = fresnel.r;\n\t\t\t\thalf fresnelRim = fresnel.g;//轮廓光\n\t\t\t\thalf fresnelSpec = fresnel.b;//镜面反射用\n\n\n\t\t\t\t//镜面反射\n\t\t\t\t//主光\n\t\t\t\thalf phong = pow(max(0.0,vDotr),specExp*_SpecPow);\n\t\t\t\thalf spec = phong*max(0.0,nDotl);//Phong*Lambert\n\t\t\t\tspec = max(spec,fresnelSpec);//注意phong的结果要和fresnelSpec混合起来，混合的方式是max\n\t\t\t\tspec = spec*_SpecInt;//乘一个高光强度方便调节范围\n\t\t\t\thalf3 dirSpec = specCol*spec*_LightColor0;\n\t\t\t\t//cubemap\n\t\t\t\thalf reflectInt = max(fresnelSpec,metalnessMask)*specInt;//计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\n\t\t\t\thalf3 envSpec = specCol*reflectInt*cubemap*_EnvSpecInt;//混合高光颜色，反射率、反射环境和强度\n\n\t\t\t\t//fresnel\n\t\t\t\thalf3 specRes = dirSpec*shadow+envSpec;\n\n\t\t\t\t//漫反射\n\t\t\t\t//主光：halflambert\n\t\t\t\thalf halfLambert = nDotl*0.5+0.5;\n\t\t\t\thalf3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\n\t\t\t\thalf3 dirDiff = var_DiffuseWrapTex*diffCol*_LightColor0;\n\t\t\t\t//环境：单色光\n\t\t\t\thalf3 envDiff = _EnvCol*diffCol;//环境光颜色*漫反射颜色\n\t\t\t\thalf3 diffRes = dirDiff*shadow+envDiff;\n\n\t\t\t\t//轮廓光\n\t\t\t\thalf3 rimLight = _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n\t\t\t\n\t\t\t\t//Emission\n\t\t\t\thalf3 emissionRes = diffCol*_EmissionInt*emissionMask;\n\n\t\t\t\tclip(opacity - _Cutoff);\n\n\t\t\t\thalf3 res = specRes+diffRes+rimLight+emissionRes;\n\n                return float4(res,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n\t//声明正确的回退shader\n    FallBack \"Legacy Shaders/Transparent/Cutout/VertexLit\"\n}\n\n```\n\n</details>\n\n#  最终效果\n\n\n\n![image-20210822170059378](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-庄懂的技术美术入门课学习笔记（六）/image-20210822170059378.png)\n","slug":"2021-08-20-庄懂的技术美术入门课学习笔记（六）","published":1,"updated":"2021-08-29T08:58:45.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100ly002j3svoazy8ec5a","content":"<h1 id=\"完整任务-Hero-Shader-In-Dota2\"><a href=\"#完整任务-Hero-Shader-In-Dota2\" class=\"headerlink\" title=\"完整任务-Hero Shader In Dota2\"></a>完整任务-Hero Shader In Dota2</h1><p><a href=\"https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish#overview\">链接</a></p>\n<p><a href=\"https://www.dota2.com/workshop/requirements/ogre_magi\">模型下载</a></p>\n<h1 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h1><p>可以直接在ps通道里面操作。把图像转为灰度格式，然后选中用来合并的文件的r/g/b通道，粘贴图像。</p>\n<p>在输出时输出<strong>tga图像</strong>，勾选<strong>alpha通道</strong>，并选择<strong>32位</strong>格式。</p>\n<p>在unity导入图片时不要勾选alpha is transparency。</p>\n<ol>\n<li><p>将basecolor 和 translucency贴图合并为一张。transluency作为alpha通道。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200527858.png\" alt=\"image-20210821200527858\" loading=\"lazy\"></p>\n</li>\n<li><p>specularMask，RimMask，TinyBaseMask，SpecularExponent作为RGBA四个通道合并为一张。注意处理图片上下翻转的问题。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200700134.png\" alt=\"image-20210821200700134\" loading=\"lazy\"></p>\n</li>\n<li><p>FresnelWrapColor，FresnelWrapRim，FresnelWrapSpec作为RGB通道合并为一张。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200826441.png\" alt=\"image-20210821200826441\" loading=\"lazy\"></p>\n</li>\n<li><p>剩下一系列图片都类似处理一遍。</p>\n</li>\n</ol>\n<h1 id=\"属性面板\"><a href=\"#属性面板\" class=\"headerlink\" title=\"属性面板\"></a>属性面板</h1><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">  Properties &#123;\n[Header(Texture)]\n_MainTex(&quot;RGB:颜色,A:透贴&quot;,2D )&#x3D; &quot;white&quot; &#123;&#125;\n_MaskTex(&quot;R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂&quot;)&#x3D;&quot;white&quot;&#123;&#125;\n[Normal]_NormTex(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n_MetalnessMask(&quot;金属度遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n_EmissionMask(&quot;自发光遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n_DiffuseWrapTex(&quot;颜色Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n_FresnelWrapTex(&quot;菲涅尔Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"向量准备和获取贴图信息\"><a href=\"#向量准备和获取贴图信息\" class=\"headerlink\" title=\"向量准备和获取贴图信息\"></a>向量准备和获取贴图信息</h1><blockquote>\n<p>注意这里使用specInt对cubemapMip做插值。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n&#x2F;&#x2F;向量准备\nfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\nfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\nfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\nfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\nfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\nfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\nfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;采样纹理\nhalf4 mainTex &#x3D; tex2D(_MainTex,i.uv0);\nhalf4 maskTex &#x3D; tex2D(_MaskTex,i.uv0);\nhalf metalnessMask &#x3D; tex2D(_MetalnessMask,i.uv0).r;&#x2F;&#x2F;取一个通道即可\nhalf emissionMask &#x3D; tex2D(_EmissionMask,i.uv0).r;\nhalf cubemapMip&#x3D;lerp(8.0,1.0,maskTex.a);  &#x2F;&#x2F;使用高光贴图对Mip插值\nhalf3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\nhalf3 fresnelTex &#x3D; tex2D(_FresnelWrapTex,vDotn);&#x2F;&#x2F;注意用vDotn来采样\n\n&#x2F;&#x2F;获取信息\nhalf3 baseColor &#x3D; mainTex.rgb;\nhalf opacity &#x3D; mainTex.a;\nhalf specInt &#x3D; maskTex.r;\nhalf rimInt &#x3D; maskTex.g;\nhalf specTint &#x3D; maskTex.b;\nhalf specExp &#x3D; maskTex.a;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"光照模型\"><a href=\"#光照模型\" class=\"headerlink\" title=\"光照模型\"></a>光照模型</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821220939073.png\" alt=\"image-20210821220939073\" loading=\"lazy\"></p>\n<h2 id=\"漫反射和镜面反射颜色\"><a href=\"#漫反射和镜面反射颜色\" class=\"headerlink\" title=\"漫反射和镜面反射颜色\"></a>漫反射和镜面反射颜色</h2><blockquote>\n<p>specTint指高光染色，一般只有金属的高光有颜色。</p>\n<p>所以将漫反射和镜面反射分开来处理，分别用metalnessMask和specTint来做插值。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;漫反射颜色用metalness，镜面反射颜色用tintmask\nhalf3 diffCol &#x3D; lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\nhalf3 specCol &#x3D; lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Fresnel的处理\"><a href=\"#Fresnel的处理\" class=\"headerlink\" title=\"Fresnel的处理\"></a>Fresnel的处理</h2><blockquote>\n<p>金属的fresnel程度比较弱，所以插值时根据matellic来插值，注意顺序。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821222652945.png\" alt=\"image-20210821222652945\" loading=\"lazy\"></p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;Fresnel\nhalf3 fresnel &#x3D; lerp(fresnelTex,0.0,metalnessMask);\nhalf fresnelCol &#x3D; fresnel.r;\nhalf fresnelRim &#x3D; fresnel.g;&#x2F;&#x2F;轮廓光\nhalf fresnelSpec &#x3D; fresnel.b;&#x2F;&#x2F;镜面反射用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出fresnel的效果如图，可以看见金属部分的fresnel效果被明显削弱。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821223506595.png\" alt=\"image-20210821223506595\" loading=\"lazy\"></p>\n<h2 id=\"主光\"><a href=\"#主光\" class=\"headerlink\" title=\"主光\"></a>主光</h2><h3 id=\"漫反射：使用Diffuse-Mask\"><a href=\"#漫反射：使用Diffuse-Mask\" class=\"headerlink\" title=\"漫反射：使用Diffuse Mask\"></a>漫反射：使用Diffuse Mask</h3><p>第一节课学习的内容，用一个常数和halfLambert组成uv坐标，对该图片采样。</p>\n<p><code>half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));</code></p>\n<p>这样可以给皮肤叠加3S效果。上面采样的结果如下：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822112047972.png\" alt=\"image-20210822112047972\" loading=\"lazy\"></p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;主光：halflambert\nhalf halfLambert &#x3D; nDotl*0.5+0.5;\nhalf3 var_DiffuseWrapTex &#x3D; tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\nhalf3 dirDiff &#x3D; var_DiffuseWrapTex*diffCol*_LightColor0;&#x2F;&#x2F;记得乘主光颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>由于美术给的贴图的SpecExp范围在0-1，不足以控制高光次幂的范围，所以需要在属性面板上添加一个_SpecPow来调节。</p>\n<p>高光强度同样加一个_SpecInt调节。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[Header(Specular)]\n[PowerSlider(2)] _SpecPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n_SpecInt(&quot;高光强度&quot;,range(0.0,10.0))&#x3D;5.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>计算主光镜面反射步骤：</p>\n<blockquote>\n<p>注意phong的结果要和fresnelSpec混合起来，混合的方式是max，也可以相加</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;镜面反射\n&#x2F;&#x2F;主光\nhalf phong &#x3D; pow(max(0.0,vDotr),specExp*_SpecPow);\nhalf spec &#x3D; phong*max(0.0,nDotl);&#x2F;&#x2F;Phong*Lambert\nspec &#x3D; max(spec,fresnelSpec);&#x2F;&#x2F;注意phong的结果要和fresnelSpec混合起来，混合的方式是max\nspec &#x3D; spec*_SpecInt;&#x2F;&#x2F;乘一个高光强度方便调节范围\nhalf3 dirSpec &#x3D; specCol*spec*_LightColor0;&#x2F;&#x2F;记得乘主光颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>得到结果：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822120043210.png\" alt=\"image-20210822120043210\" loading=\"lazy\"></p>\n<h2 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h2><h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;环境：单色光\nhalf3 envDiff &#x3D; _EnvCol*_EnvDiffInt*diffCol;&#x2F;&#x2F;环境光颜色*环境光漫反射强度*漫反射颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"镜面反射-1\"><a href=\"#镜面反射-1\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>使用cubemap</p>\n<ol>\n<li>计算反射率：考虑非金属（fresnel）和金属（metalness）的最大值</li>\n<li>混合高光颜色，反射率、反射环境和强度</li>\n</ol>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;cubemap\nhalf reflectInt &#x3D; max(fresnelSpec,metalnessMask)*specInt;&#x2F;&#x2F;计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\nhalf envSpec &#x3D; specCol*reflectInt*cubemap*_EnvSpecInt;&#x2F;&#x2F;混合高光颜色，反射率、反射环境和强度<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"轮廓光\"><a href=\"#轮廓光\" class=\"headerlink\" title=\"轮廓光\"></a>轮廓光</h2><blockquote>\n<p>只保留角色上半部分的轮廓光：乘max(0.0,nDirWS.g)</p>\n<p>定义轮廓光时使用HDR，使其可以直接调强度。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;轮廓光\nhalf3 rimLight &#x3D; _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822124126070.png\" alt=\"image-20210822124126070\" loading=\"lazy\"></p>\n<h2 id=\"自发光\"><a href=\"#自发光\" class=\"headerlink\" title=\"自发光\"></a>自发光</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;Emission\nhalf3 emissionRes &#x3D; diffCol*_EmissionInt*emissionMask;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h1 id=\"透明剪切\"><a href=\"#透明剪切\" class=\"headerlink\" title=\"透明剪切\"></a>透明剪切</h1><p>添加_Cutoff属性。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[HideInInspector] _Cutoff(&quot;Alpha cutoff&quot;,range(0.0,1.0)) &#x3D; 0.5&#x2F;&#x2F;必须叫_Cutoff,不能有差别\n    \n\nclip(opacity - _Cutoff);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153014157.png\" alt=\"image-20210822153014157\" loading=\"lazy\"></p>\n<h2 id=\"透明剪切投影修正\"><a href=\"#透明剪切投影修正\" class=\"headerlink\" title=\"透明剪切投影修正\"></a>透明剪切投影修正</h2><p>此时透明剪切的投影是错误的。</p>\n<p>原因是原来Fallback 到“Diffuse”，投影不支持剪切。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;在属性面板中添加_Color\n[HideInInspector] _Color(&quot;Main Color&quot;,Color) &#x3D; (1.0,1.0,1.0,1.0)\nuniform half _Color;\n\n&#x2F;&#x2F;声明正确的回退shader\nFallBack &quot;Legacy Shaders&#x2F;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153513102.png\" alt=\"image-20210822153513102\" loading=\"lazy\"></p>\n<h1 id=\"开启双面显示\"><a href=\"#开启双面显示\" class=\"headerlink\" title=\"开启双面显示\"></a>开启双面显示</h1><p>在PassTags后面声明<code>Cull off</code>即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153833360.png\" alt=\"image-20210822153833360\" loading=\"lazy\"></p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><details>\n    <summary>MagiShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Magi&#x2F;MagiShader&quot;\n&#123;\n    Properties &#123;\n\t\t[Header(Texture)]\n\t\t_MainTex(&quot;RGB:颜色,A:透贴&quot;,2D )&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_MaskTex(&quot;R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;\n\t\t[Normal]_NormTex(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_MetalnessMask(&quot;金属度遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n\t\t_EmissionMask(&quot;自发光遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n\t\t_DiffuseWrapTex(&quot;颜色Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_FresnelWrapTex(&quot;菲涅尔Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n\t\t[Header(Diffuse)]\n\t\t_EnvCol(&quot;环境光颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\n\t\t[Header(Specular)]\n\t\t[PowerSlider(2)] _SpecPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_SpecInt(&quot;高光强度&quot;,range(0.0,10.0))&#x3D;5.0\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0.0,10.0))&#x3D;1.0\n\n\t\t[Header(RimLight)]\n\t\t[HDR] _RimCol(&quot;轮廓光颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t[Header(Emission)]\n\t\t_EmissionInt(&quot;自发光强度&quot;,range(0.0,10.0))&#x3D;1.0\n\n\t\t[HideInInspector] _Cutoff(&quot;Alpha cutoff&quot;,range(0.0,1.0)) &#x3D; 0.5\n\t\t[HideInInspector] _Color(&quot;Main Color&quot;,Color) &#x3D; (1.0,1.0,1.0,1.0)\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            Cull off\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\n\t\t\t#include &quot;..&#x2F;cginc&#x2F;MyCginc.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\t&#x2F;&#x2F;texture\n\t\t\tuniform sampler2D _MainTex;\n\t\t\tuniform sampler2D _MaskTex;\n\t\t\tuniform sampler2D _NormTex;\n\t\t\tuniform sampler2D _MetalnessMask;\n\t\t\tuniform sampler2D _EmissionMask;\n\t\t\tuniform sampler2D _DiffuseWrapTex;\n\t\t\tuniform sampler2D _FresnelWrapTex;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\t&#x2F;&#x2F;DIFFUSE\n\t\t\tuniform half3 _EnvCol;\n\n\t\t\t&#x2F;&#x2F;SPECULAR\n\t\t\tuniform half _SpecPow;\n\t\t\tuniform half _SpecInt;\n\t\t\tuniform half _EnvSpecInt;\n\n\t\t\t&#x2F;&#x2F;rimLight\n\t\t\tuniform half3 _RimCol;\n\n\t\t\t&#x2F;&#x2F;Emission\n\t\t\tuniform half _EmissionInt;\n\t\t\t\n\t\t\tuniform half _Cutoff;\n\t\t\tuniform half _Color;\n\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;采样纹理\n\t\t\t\thalf4 mainTex &#x3D; tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex &#x3D; tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask &#x3D; tex2D(_MetalnessMask,i.uv0).r;&#x2F;&#x2F;取一个通道即可\n\t\t\t\thalf emissionMask &#x3D; tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip&#x3D;lerp(8.0,1.0,maskTex.a);  &#x2F;&#x2F;使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex &#x3D; tex2D(_FresnelWrapTex,vDotn);\n\t\t\t\t&#x2F;&#x2F;获取信息\n\t\t\t\thalf3 baseColor &#x3D; mainTex.rgb;\n\t\t\t\thalf opacity &#x3D; mainTex.a;\n\t\t\t\thalf specInt &#x3D; maskTex.r;\n\t\t\t\thalf rimInt &#x3D; maskTex.g;\n\t\t\t\thalf specTint &#x3D; maskTex.b;\n\t\t\t\thalf specExp &#x3D; maskTex.a;\n\n\t\t\t\t&#x2F;&#x2F;漫反射颜色用metalness，镜面反射颜色用tintmask\n\t\t\t\thalf3 diffCol &#x3D; lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\n\t\t\t\thalf3 specCol &#x3D; lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n\n\t\t\t\t&#x2F;&#x2F;Fresnel\n\t\t\t\thalf3 fresnel &#x3D; lerp(fresnelTex,0.0,metalnessMask);\n\t\t\t\thalf fresnelCol &#x3D; fresnel.r;\n\t\t\t\thalf fresnelRim &#x3D; fresnel.g;&#x2F;&#x2F;轮廓光\n\t\t\t\thalf fresnelSpec &#x3D; fresnel.b;&#x2F;&#x2F;镜面反射用\n\n\n\t\t\t\t&#x2F;&#x2F;镜面反射\n\t\t\t\t&#x2F;&#x2F;主光\n\t\t\t\thalf phong &#x3D; pow(max(0.0,vDotr),specExp*_SpecPow);\n\t\t\t\thalf spec &#x3D; phong*max(0.0,nDotl);&#x2F;&#x2F;Phong*Lambert\n\t\t\t\tspec &#x3D; max(spec,fresnelSpec);&#x2F;&#x2F;注意phong的结果要和fresnelSpec混合起来，混合的方式是max\n\t\t\t\tspec &#x3D; spec*_SpecInt;&#x2F;&#x2F;乘一个高光强度方便调节范围\n\t\t\t\thalf3 dirSpec &#x3D; specCol*spec*_LightColor0;\n\t\t\t\t&#x2F;&#x2F;cubemap\n\t\t\t\thalf reflectInt &#x3D; max(fresnelSpec,metalnessMask)*specInt;&#x2F;&#x2F;计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\n\t\t\t\thalf3 envSpec &#x3D; specCol*reflectInt*cubemap*_EnvSpecInt;&#x2F;&#x2F;混合高光颜色，反射率、反射环境和强度\n\n\t\t\t\t&#x2F;&#x2F;fresnel\n\t\t\t\thalf3 specRes &#x3D; dirSpec*shadow+envSpec;\n\n\t\t\t\t&#x2F;&#x2F;漫反射\n\t\t\t\t&#x2F;&#x2F;主光：halflambert\n\t\t\t\thalf halfLambert &#x3D; nDotl*0.5+0.5;\n\t\t\t\thalf3 var_DiffuseWrapTex &#x3D; tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\n\t\t\t\thalf3 dirDiff &#x3D; var_DiffuseWrapTex*diffCol*_LightColor0;\n\t\t\t\t&#x2F;&#x2F;环境：单色光\n\t\t\t\thalf3 envDiff &#x3D; _EnvCol*diffCol;&#x2F;&#x2F;环境光颜色*漫反射颜色\n\t\t\t\thalf3 diffRes &#x3D; dirDiff*shadow+envDiff;\n\n\t\t\t\t&#x2F;&#x2F;轮廓光\n\t\t\t\thalf3 rimLight &#x3D; _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n\t\t\t\n\t\t\t\t&#x2F;&#x2F;Emission\n\t\t\t\thalf3 emissionRes &#x3D; diffCol*_EmissionInt*emissionMask;\n\n\t\t\t\tclip(opacity - _Cutoff);\n\n\t\t\t\thalf3 res &#x3D; specRes+diffRes+rimLight+emissionRes;\n\n                return float4(res,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;声明正确的回退shader\n    FallBack &quot;Legacy Shaders&#x2F;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822170059378.png\" alt=\"image-20210822170059378\" loading=\"lazy\"></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<h1 id=\"完整任务-Hero-Shader-In-Dota2\"><a href=\"#完整任务-Hero-Shader-In-Dota2\" class=\"headerlink\" title=\"完整任务-Hero Shader In Dota2\"></a>完整任务-Hero Shader In Dota2</h1><p><a href=\"https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish#overview\">链接</a></p>\n<p><a href=\"https://www.dota2.com/workshop/requirements/ogre_magi\">模型下载</a></p>\n<h1 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h1><p>可以直接在ps通道里面操作。把图像转为灰度格式，然后选中用来合并的文件的r/g/b通道，粘贴图像。</p>\n<p>在输出时输出<strong>tga图像</strong>，勾选<strong>alpha通道</strong>，并选择<strong>32位</strong>格式。</p>\n<p>在unity导入图片时不要勾选alpha is transparency。</p>\n<ol>\n<li><p>将basecolor 和 translucency贴图合并为一张。transluency作为alpha通道。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200527858.png\" alt=\"image-20210821200527858\"></p>\n</li>\n<li><p>specularMask，RimMask，TinyBaseMask，SpecularExponent作为RGBA四个通道合并为一张。注意处理图片上下翻转的问题。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200700134.png\" alt=\"image-20210821200700134\"></p>\n</li>\n<li><p>FresnelWrapColor，FresnelWrapRim，FresnelWrapSpec作为RGB通道合并为一张。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821200826441.png\" alt=\"image-20210821200826441\"></p>\n</li>\n<li><p>剩下一系列图片都类似处理一遍。</p>\n</li>\n</ol>\n<h1 id=\"属性面板\"><a href=\"#属性面板\" class=\"headerlink\" title=\"属性面板\"></a>属性面板</h1><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">  Properties &#123;\n[Header(Texture)]\n_MainTex(&quot;RGB:颜色,A:透贴&quot;,2D )&#x3D; &quot;white&quot; &#123;&#125;\n_MaskTex(&quot;R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂&quot;)&#x3D;&quot;white&quot;&#123;&#125;\n[Normal]_NormTex(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n_MetalnessMask(&quot;金属度遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n_EmissionMask(&quot;自发光遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n_DiffuseWrapTex(&quot;颜色Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n_FresnelWrapTex(&quot;菲涅尔Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"向量准备和获取贴图信息\"><a href=\"#向量准备和获取贴图信息\" class=\"headerlink\" title=\"向量准备和获取贴图信息\"></a>向量准备和获取贴图信息</h1><blockquote>\n<p>注意这里使用specInt对cubemapMip做插值。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n&#x2F;&#x2F;向量准备\nfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\nfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\nfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\nfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\nfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\nfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\nfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;采样纹理\nhalf4 mainTex &#x3D; tex2D(_MainTex,i.uv0);\nhalf4 maskTex &#x3D; tex2D(_MaskTex,i.uv0);\nhalf metalnessMask &#x3D; tex2D(_MetalnessMask,i.uv0).r;&#x2F;&#x2F;取一个通道即可\nhalf emissionMask &#x3D; tex2D(_EmissionMask,i.uv0).r;\nhalf cubemapMip&#x3D;lerp(8.0,1.0,maskTex.a);  &#x2F;&#x2F;使用高光贴图对Mip插值\nhalf3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\nhalf3 fresnelTex &#x3D; tex2D(_FresnelWrapTex,vDotn);&#x2F;&#x2F;注意用vDotn来采样\n\n&#x2F;&#x2F;获取信息\nhalf3 baseColor &#x3D; mainTex.rgb;\nhalf opacity &#x3D; mainTex.a;\nhalf specInt &#x3D; maskTex.r;\nhalf rimInt &#x3D; maskTex.g;\nhalf specTint &#x3D; maskTex.b;\nhalf specExp &#x3D; maskTex.a;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"光照模型\"><a href=\"#光照模型\" class=\"headerlink\" title=\"光照模型\"></a>光照模型</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821220939073.png\" alt=\"image-20210821220939073\"></p>\n<h2 id=\"漫反射和镜面反射颜色\"><a href=\"#漫反射和镜面反射颜色\" class=\"headerlink\" title=\"漫反射和镜面反射颜色\"></a>漫反射和镜面反射颜色</h2><blockquote>\n<p>specTint指高光染色，一般只有金属的高光有颜色。</p>\n<p>所以将漫反射和镜面反射分开来处理，分别用metalnessMask和specTint来做插值。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;漫反射颜色用metalness，镜面反射颜色用tintmask\nhalf3 diffCol &#x3D; lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\nhalf3 specCol &#x3D; lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Fresnel的处理\"><a href=\"#Fresnel的处理\" class=\"headerlink\" title=\"Fresnel的处理\"></a>Fresnel的处理</h2><blockquote>\n<p>金属的fresnel程度比较弱，所以插值时根据matellic来插值，注意顺序。</p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821222652945.png\" alt=\"image-20210821222652945\"></p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;Fresnel\nhalf3 fresnel &#x3D; lerp(fresnelTex,0.0,metalnessMask);\nhalf fresnelCol &#x3D; fresnel.r;\nhalf fresnelRim &#x3D; fresnel.g;&#x2F;&#x2F;轮廓光\nhalf fresnelSpec &#x3D; fresnel.b;&#x2F;&#x2F;镜面反射用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出fresnel的效果如图，可以看见金属部分的fresnel效果被明显削弱。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-19-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210821223506595.png\" alt=\"image-20210821223506595\"></p>\n<h2 id=\"主光\"><a href=\"#主光\" class=\"headerlink\" title=\"主光\"></a>主光</h2><h3 id=\"漫反射：使用Diffuse-Mask\"><a href=\"#漫反射：使用Diffuse-Mask\" class=\"headerlink\" title=\"漫反射：使用Diffuse Mask\"></a>漫反射：使用Diffuse Mask</h3><p>第一节课学习的内容，用一个常数和halfLambert组成uv坐标，对该图片采样。</p>\n<p><code>half3 var_DiffuseWrapTex = tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));</code></p>\n<p>这样可以给皮肤叠加3S效果。上面采样的结果如下：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822112047972.png\" alt=\"image-20210822112047972\"></p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;主光：halflambert\nhalf halfLambert &#x3D; nDotl*0.5+0.5;\nhalf3 var_DiffuseWrapTex &#x3D; tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\nhalf3 dirDiff &#x3D; var_DiffuseWrapTex*diffCol*_LightColor0;&#x2F;&#x2F;记得乘主光颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>由于美术给的贴图的SpecExp范围在0-1，不足以控制高光次幂的范围，所以需要在属性面板上添加一个_SpecPow来调节。</p>\n<p>高光强度同样加一个_SpecInt调节。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[Header(Specular)]\n[PowerSlider(2)] _SpecPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n_SpecInt(&quot;高光强度&quot;,range(0.0,10.0))&#x3D;5.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>计算主光镜面反射步骤：</p>\n<blockquote>\n<p>注意phong的结果要和fresnelSpec混合起来，混合的方式是max，也可以相加</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;镜面反射\n&#x2F;&#x2F;主光\nhalf phong &#x3D; pow(max(0.0,vDotr),specExp*_SpecPow);\nhalf spec &#x3D; phong*max(0.0,nDotl);&#x2F;&#x2F;Phong*Lambert\nspec &#x3D; max(spec,fresnelSpec);&#x2F;&#x2F;注意phong的结果要和fresnelSpec混合起来，混合的方式是max\nspec &#x3D; spec*_SpecInt;&#x2F;&#x2F;乘一个高光强度方便调节范围\nhalf3 dirSpec &#x3D; specCol*spec*_LightColor0;&#x2F;&#x2F;记得乘主光颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>得到结果：</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822120043210.png\" alt=\"image-20210822120043210\"></p>\n<h2 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h2><h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;环境：单色光\nhalf3 envDiff &#x3D; _EnvCol*_EnvDiffInt*diffCol;&#x2F;&#x2F;环境光颜色*环境光漫反射强度*漫反射颜色<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"镜面反射-1\"><a href=\"#镜面反射-1\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>使用cubemap</p>\n<ol>\n<li>计算反射率：考虑非金属（fresnel）和金属（metalness）的最大值</li>\n<li>混合高光颜色，反射率、反射环境和强度</li>\n</ol>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;cubemap\nhalf reflectInt &#x3D; max(fresnelSpec,metalnessMask)*specInt;&#x2F;&#x2F;计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\nhalf envSpec &#x3D; specCol*reflectInt*cubemap*_EnvSpecInt;&#x2F;&#x2F;混合高光颜色，反射率、反射环境和强度<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"轮廓光\"><a href=\"#轮廓光\" class=\"headerlink\" title=\"轮廓光\"></a>轮廓光</h2><blockquote>\n<p>只保留角色上半部分的轮廓光：乘max(0.0,nDirWS.g)</p>\n<p>定义轮廓光时使用HDR，使其可以直接调强度。</p>\n</blockquote>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;轮廓光\nhalf3 rimLight &#x3D; _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822124126070.png\" alt=\"image-20210822124126070\"></p>\n<h2 id=\"自发光\"><a href=\"#自发光\" class=\"headerlink\" title=\"自发光\"></a>自发光</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;Emission\nhalf3 emissionRes &#x3D; diffCol*_EmissionInt*emissionMask;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h1 id=\"透明剪切\"><a href=\"#透明剪切\" class=\"headerlink\" title=\"透明剪切\"></a>透明剪切</h1><p>添加_Cutoff属性。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[HideInInspector] _Cutoff(&quot;Alpha cutoff&quot;,range(0.0,1.0)) &#x3D; 0.5&#x2F;&#x2F;必须叫_Cutoff,不能有差别\n    \n\nclip(opacity - _Cutoff);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153014157.png\" alt=\"image-20210822153014157\"></p>\n<h2 id=\"透明剪切投影修正\"><a href=\"#透明剪切投影修正\" class=\"headerlink\" title=\"透明剪切投影修正\"></a>透明剪切投影修正</h2><p>此时透明剪切的投影是错误的。</p>\n<p>原因是原来Fallback 到“Diffuse”，投影不支持剪切。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;在属性面板中添加_Color\n[HideInInspector] _Color(&quot;Main Color&quot;,Color) &#x3D; (1.0,1.0,1.0,1.0)\nuniform half _Color;\n\n&#x2F;&#x2F;声明正确的回退shader\nFallBack &quot;Legacy Shaders&#x2F;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153513102.png\" alt=\"image-20210822153513102\"></p>\n<h1 id=\"开启双面显示\"><a href=\"#开启双面显示\" class=\"headerlink\" title=\"开启双面显示\"></a>开启双面显示</h1><p>在PassTags后面声明<code>Cull off</code>即可。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822153833360.png\" alt=\"image-20210822153833360\"></p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><details>\n    <summary>MagiShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Magi&#x2F;MagiShader&quot;\n&#123;\n    Properties &#123;\n\t\t[Header(Texture)]\n\t\t_MainTex(&quot;RGB:颜色,A:透贴&quot;,2D )&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_MaskTex(&quot;R:高光强度,G:边缘光强度,B:高光染色,A:高光次幂&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;\n\t\t[Normal]_NormTex(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_MetalnessMask(&quot;金属度遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n\t\t_EmissionMask(&quot;自发光遮罩&quot;,2D) &#x3D; &quot;black&quot; &#123;&#125;\n\t\t_DiffuseWrapTex(&quot;颜色Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_FresnelWrapTex(&quot;菲涅尔Wrap图&quot;,2D) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n\t\t[Header(Diffuse)]\n\t\t_EnvCol(&quot;环境光颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\n\t\t[Header(Specular)]\n\t\t[PowerSlider(2)] _SpecPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_SpecInt(&quot;高光强度&quot;,range(0.0,10.0))&#x3D;5.0\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0.0,10.0))&#x3D;1.0\n\n\t\t[Header(RimLight)]\n\t\t[HDR] _RimCol(&quot;轮廓光颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t[Header(Emission)]\n\t\t_EmissionInt(&quot;自发光强度&quot;,range(0.0,10.0))&#x3D;1.0\n\n\t\t[HideInInspector] _Cutoff(&quot;Alpha cutoff&quot;,range(0.0,1.0)) &#x3D; 0.5\n\t\t[HideInInspector] _Color(&quot;Main Color&quot;,Color) &#x3D; (1.0,1.0,1.0,1.0)\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            Cull off\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\n\t\t\t#include &quot;..&#x2F;cginc&#x2F;MyCginc.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\t&#x2F;&#x2F;texture\n\t\t\tuniform sampler2D _MainTex;\n\t\t\tuniform sampler2D _MaskTex;\n\t\t\tuniform sampler2D _NormTex;\n\t\t\tuniform sampler2D _MetalnessMask;\n\t\t\tuniform sampler2D _EmissionMask;\n\t\t\tuniform sampler2D _DiffuseWrapTex;\n\t\t\tuniform sampler2D _FresnelWrapTex;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\t&#x2F;&#x2F;DIFFUSE\n\t\t\tuniform half3 _EnvCol;\n\n\t\t\t&#x2F;&#x2F;SPECULAR\n\t\t\tuniform half _SpecPow;\n\t\t\tuniform half _SpecInt;\n\t\t\tuniform half _EnvSpecInt;\n\n\t\t\t&#x2F;&#x2F;rimLight\n\t\t\tuniform half3 _RimCol;\n\n\t\t\t&#x2F;&#x2F;Emission\n\t\t\tuniform half _EmissionInt;\n\t\t\t\n\t\t\tuniform half _Cutoff;\n\t\t\tuniform half _Color;\n\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;采样纹理\n\t\t\t\thalf4 mainTex &#x3D; tex2D(_MainTex,i.uv0);\n\t\t\t\thalf4 maskTex &#x3D; tex2D(_MaskTex,i.uv0);\n\t\t\t\thalf metalnessMask &#x3D; tex2D(_MetalnessMask,i.uv0).r;&#x2F;&#x2F;取一个通道即可\n\t\t\t\thalf emissionMask &#x3D; tex2D(_EmissionMask,i.uv0).r;\n\t\t\t\thalf cubemapMip&#x3D;lerp(8.0,1.0,maskTex.a);  &#x2F;&#x2F;使用高光贴图对Mip插值\n\t\t\t\thalf3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,cubemapMip));\n\t\t\t\thalf3 fresnelTex &#x3D; tex2D(_FresnelWrapTex,vDotn);\n\t\t\t\t&#x2F;&#x2F;获取信息\n\t\t\t\thalf3 baseColor &#x3D; mainTex.rgb;\n\t\t\t\thalf opacity &#x3D; mainTex.a;\n\t\t\t\thalf specInt &#x3D; maskTex.r;\n\t\t\t\thalf rimInt &#x3D; maskTex.g;\n\t\t\t\thalf specTint &#x3D; maskTex.b;\n\t\t\t\thalf specExp &#x3D; maskTex.a;\n\n\t\t\t\t&#x2F;&#x2F;漫反射颜色用metalness，镜面反射颜色用tintmask\n\t\t\t\thalf3 diffCol &#x3D; lerp(baseColor,half3(0.0,0.0,0.0),metalnessMask);\n\t\t\t\thalf3 specCol &#x3D; lerp(baseColor,half3(0.3,0.3,0.3),specTint)*specInt;\n\n\t\t\t\t&#x2F;&#x2F;Fresnel\n\t\t\t\thalf3 fresnel &#x3D; lerp(fresnelTex,0.0,metalnessMask);\n\t\t\t\thalf fresnelCol &#x3D; fresnel.r;\n\t\t\t\thalf fresnelRim &#x3D; fresnel.g;&#x2F;&#x2F;轮廓光\n\t\t\t\thalf fresnelSpec &#x3D; fresnel.b;&#x2F;&#x2F;镜面反射用\n\n\n\t\t\t\t&#x2F;&#x2F;镜面反射\n\t\t\t\t&#x2F;&#x2F;主光\n\t\t\t\thalf phong &#x3D; pow(max(0.0,vDotr),specExp*_SpecPow);\n\t\t\t\thalf spec &#x3D; phong*max(0.0,nDotl);&#x2F;&#x2F;Phong*Lambert\n\t\t\t\tspec &#x3D; max(spec,fresnelSpec);&#x2F;&#x2F;注意phong的结果要和fresnelSpec混合起来，混合的方式是max\n\t\t\t\tspec &#x3D; spec*_SpecInt;&#x2F;&#x2F;乘一个高光强度方便调节范围\n\t\t\t\thalf3 dirSpec &#x3D; specCol*spec*_LightColor0;\n\t\t\t\t&#x2F;&#x2F;cubemap\n\t\t\t\thalf reflectInt &#x3D; max(fresnelSpec,metalnessMask)*specInt;&#x2F;&#x2F;计算反射率，考虑非金属（fresnel）和金属（metalness）的最大值\n\t\t\t\thalf3 envSpec &#x3D; specCol*reflectInt*cubemap*_EnvSpecInt;&#x2F;&#x2F;混合高光颜色，反射率、反射环境和强度\n\n\t\t\t\t&#x2F;&#x2F;fresnel\n\t\t\t\thalf3 specRes &#x3D; dirSpec*shadow+envSpec;\n\n\t\t\t\t&#x2F;&#x2F;漫反射\n\t\t\t\t&#x2F;&#x2F;主光：halflambert\n\t\t\t\thalf halfLambert &#x3D; nDotl*0.5+0.5;\n\t\t\t\thalf3 var_DiffuseWrapTex &#x3D; tex2D(_DiffuseWrapTex,half2(halfLambert,2.0));\n\t\t\t\thalf3 dirDiff &#x3D; var_DiffuseWrapTex*diffCol*_LightColor0;\n\t\t\t\t&#x2F;&#x2F;环境：单色光\n\t\t\t\thalf3 envDiff &#x3D; _EnvCol*diffCol;&#x2F;&#x2F;环境光颜色*漫反射颜色\n\t\t\t\thalf3 diffRes &#x3D; dirDiff*shadow+envDiff;\n\n\t\t\t\t&#x2F;&#x2F;轮廓光\n\t\t\t\thalf3 rimLight &#x3D; _RimCol*rimInt*fresnelRim*max(0.0,nDirWS.g);\n\t\t\t\n\t\t\t\t&#x2F;&#x2F;Emission\n\t\t\t\thalf3 emissionRes &#x3D; diffCol*_EmissionInt*emissionMask;\n\n\t\t\t\tclip(opacity - _Cutoff);\n\n\t\t\t\thalf3 res &#x3D; specRes+diffRes+rimLight+emissionRes;\n\n                return float4(res,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;声明正确的回退shader\n    FallBack &quot;Legacy Shaders&#x2F;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-20-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/image-20210822170059378.png\" alt=\"image-20210822170059378\"></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-07-25T17:12:06.810Z","updated":"1985-10-26T08:15:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100lz002k3svodi2khcny","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo generate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo generate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"2021-08-18-庄懂的技术美术入门课学习笔记（四）","date":"2021-08-18T08:16:26.000Z","_content":"\n> 对应课程9-10课内容\n\n# 法线\n\n> [TBN空间](https://blog.csdn.net/bonchoix/article/details/8619624)\n\n## ShaderForge自主实现读取法线贴图\n\n法线贴图的信息是经过编码的，需要通过`UnpackNormal(tex2D(normalMap,uv))`来解码。\n\n![image-20210818182522503](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182522503.png)\n\n前面这部分也可以用Transform结点代替。记得要改下面的设置：From Tangent to World\n\n![image-20210818213856432](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213856432.png)\n\n结点输出结果如下：输出的法线信息不会随模型旋转而改变。![image-20210818182418574](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182418574.png)\n\n## Code\n\n<details>\n    <summary>ReadNormalShader.shader</summary>\n\n\n```c#\n\nShader \"Class4/ReadNormalShader\" {\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.uv0 = v.uv0;\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0));\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));\n\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\t//准备点积信息\n\t\t\t\tfloat nDotl = dot(nDirWS, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n\n# 菲涅尔\n\n>*什么是菲涅耳效应？*\n>\n>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。\n>\n>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？\n>\n>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：\n>\n>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)\n\n![image-20210818204437765](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818204437765.png)\n\n<div class=\"warning\">\n\n> 菲涅尔用于影响环境光的镜面反射效果\n\n</div>\n\n## Shader Forge实现\n\n用观察方向和法线方向点乘，然后再通过One Minus结点，得到中间黑四周亮的效果。\n\n然后可以加一个Power结点，用EXP来控制范围。\n\n![image-20210818213335314](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213335314.png)\n\nShaderForge也自带Fresnel结点。\n\n\n\n\n\n# 环境的镜面反射\n\n\n\n## Matcap\n\n> 思路：\n>\n> 1. 获得法线贴图后，把结果从切线空间转到观察空间。\n> 2. 然后提取出R和G通道，remap到0-1后作为uv采样一张matcap贴图。（R通道沿屏幕朝左是-1，朝右是1；G通道沿屏幕朝下是-1，朝上是1）\n> 3. 切换金属和非金属可以在把法线的结果从切线空间转到世界空间后再加一个菲涅尔效果，然后用菲涅尔次幂来调节。\n\n![image-20210818221223851](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818221223851.png)\n\n### Code\n\n在参数输入面板时注意默认值：`_Matcap(\"Matcap\", 2D ) = \"gray\"{}`\n\n注意处理matcap贴图时需要先把观察空间的法线结果取r和g通道，reshape到0-1范围内作为uv坐标`float2 matcapUV = nDirVS.rg * 0.5 + 0.5;`，然后再用该uv坐标对贴图进行采样`float matcap = tex2D(_Matcap, matcapUV);`\n\n<details>\n    <summary>MatcapShader.shader</summary>\n\n```c#\nShader \"Class4/MatcapShader\"\n{\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_Matcap(\"Matcap\", 2D ) = \"gray\"{}\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform sampler2D _Matcap;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//uv0\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0=v.uv0;\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 nDirVS = mul(UNITY_MATRIX_V,float4(nDirWS,0.0));//world to view\n\n\t\t\t\t//中间量准备\n\t\t\t\tfloat2 matcapUV = nDirVS.rg * 0.5 + 0.5;//reshape\n\t\t\t\tfloat nDotv = dot(nDirWS,vDirWS);\n\n\t\t\t\t//光照模型\n\t\t\t\tfloat matcap = tex2D(_Matcap, matcapUV);\n\t\t\t\tfloat fresnel = pow(1.0 - nDotv,_FresnelExp);\n\n\t\t\t\tfloat3 envSpecLighting = matcap*fresnel*_EnvSpecInt;\n\n\n                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n\n```\n\n</details>\n\n## CubeMap\n\n### 生成Mipmap\n\n从网上下载一张HDR的全景图片，然后在ps里修改图像大小为512*512，修改为8位图像，再另存为tga格式。\n\n#### 导入Unity\n\n注意修改Texture设置为Shape，另外Mapping的方式设置为latitude，默认是错的；为了让低精度的效果更自然，需要选择Convolution Type为Specular。FixupEdge Seams最好也勾上。\n\n![image-20210819114859407](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819114859407.png)\n\n### ShaderForge实现\n\n主要思路是获得观察方向，然后通过观察方向在物体表面反弹后的方向来对cubemap采样。所以输入Cubemap的是vrDir。\n\nNormalmap+Transform结点(切线空间转世界空间)相当于获得物体法线。\n\n![image-20210819113658345](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819113658345.png)\n\n另外一个输入MIP指的是mip级别，相当于调节粗糙值。\n\n可以在贴图的预览处调节滑块预览不同mip值的效果。\n\n![image-20210819115506510](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819115506510.png)\n\n### Code\n\n注意参数面板的类型设置：\n\n```c#\nNormalMap(\"法线贴图\",2D) = \"bump\" {}\n_CubeMap(\"环境球\", Cube ) = \"Skybox\"{}\n\n//对于cubemap使用特殊的samplerCUBE采样\nuniform sampler2D _NormalMap;\nuniform samplerCUBE _CubeMap;\n\n//片元着色器中读取Cubemap\nfloat3 vrDirWS = reflect(-vDirWS,nDirWS);//记得获取观察方向的反射方向\nfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n```\n\n<details>\n    <summary>CubemapShader.shader</summary>\n\n```c#\n\nShader \"Class4/CubemapShader\" {\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_CubeMap(\"环境球\", Cube ) = \"_Skybox\"{}\n\t\t_CubemapMip(\"环境球MIP\",range(0,7)) = 0\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n\t\t_Occlusion (\"AO\",2D) = \"white\" {}\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\t\t\t\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\n\t\t\t\t//中间量,做Fresnel\n\t\t\t\tfloat vdotn = dot(vDirWS,nDirWS);\n\n\t\t\t\t//cubemap\n\t\t\t\tfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\n\t\t\t\tfloat fresnel = pow(1.0-vdotn,_FresnelExp);\n\t\t\t\tfloat occlusion = tex2D(_Occlusion,i.uv0).r;\n\t\t\t\tfloat3 envSpecLighting = cubemap*fresnel*_EnvSpecInt*occlusion;\n\n\n\n                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n# 综合应用\n\n![image-20210819172558238](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819172558238.png)\n\n## Code\n\n> mul()表示向量和矩阵相乘\n>\n> 获得环境光源的信息：\n>\n> 方向：`float lDir= _WorldSpaceLightPos0.xyz;`\n>\n> 颜色：`_LightColor0`\n\n<details>\n    <summary>OldSchoolProShader</summary>\n\n```c#\nShader \"Class4/OldSchoolProShader\"\n{\n    Properties {\n\t\t[Header(Texture)]\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t[Header(Diffuse)]\n\t\t_BaseCol(\"基本颜色\",color)=(1.0,0.0,0.0,1.0)\n\t\t//_LightCol(\"光照颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_Intensity(\"光照强度\",range(0,5))=1\n\t\t_EnvIntensity(\"环境光强度\",range(0,5))=1\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t[Header(Specular)]\n\t\t_SpecularPow(\"高光次幂\",range(1,90))= 30\n\t\t_CubemapMip(\"环境球MIP\",range(0,7)) = 0\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\t//uniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n////// Light:\n\t\t\t\tfloat nDotl = dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr = dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn = dot(vDirWS,nDirWS);\n\n\t\t\t\tfloat lambert = max(0.0,nDotl);\n\t\t\t\t//float specCol = var_SpecTex.rgb;\n\t\t\t\t//float specPow = lerp(_SpecularPow,1.0,var_SpecTex.a);  //高光贴图,用rgb通道存储颜色，a通道存储光滑度\n\t\t\t\tfloat phong = pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t///直接光照\n\t\t\t\tfloat3 lightRes =_LightColor0*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n////// env:\n\n\t\t\t\t//环境光漫反射\n\t\t\t\tfloat upMask = max(0.0,nDirWS.g);\n\t\t\t\tfloat downMask = max(0.0,-nDirWS.g);\n\t\t\t\tfloat sideMask = 1.0-upMask-downMask;\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//环境光镜面反射\n\t\t\t\t//float cubemapMip=lerp(_CubemapMip,1.0,var_SpecTex.a);  //高光贴图\n\t\t\t\tfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\t\t\t\tfloat fresnel = pow(1.0-vDotn,_FresnelExp);\n\n\t\t\t\t//环境光遮罩\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv0);\n\n\t\t\t\t//环境光\n\t\t\t\tfloat3 envSpec = cubemap*_EnvSpecInt*fresnel;\n\t\t\t\tfloat3 envDiff = envCol*_BaseCol*_EnvIntensity;\n\t\t\t\tfloat3 envRes = (envSpec+envDiff)*occlusion;\n\n\t\t\t\tfloat3 finalRGB = lightRes+envRes;\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n","source":"_posts/2021-08-18-庄懂的技术美术入门课学习笔记（四）.md","raw":"---\ntitle: 2021-08-18-庄懂的技术美术入门课学习笔记（四）\ndate: 2021-08-18 16:16:26\ntags:\n  - 法线\n  - 菲涅尔\n  - Matcap贴图\n  - Cubemap贴图\ncategories:\n  - 庄懂的技术美术入门课学习笔记\n---\n\n> 对应课程9-10课内容\n\n# 法线\n\n> [TBN空间](https://blog.csdn.net/bonchoix/article/details/8619624)\n\n## ShaderForge自主实现读取法线贴图\n\n法线贴图的信息是经过编码的，需要通过`UnpackNormal(tex2D(normalMap,uv))`来解码。\n\n![image-20210818182522503](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182522503.png)\n\n前面这部分也可以用Transform结点代替。记得要改下面的设置：From Tangent to World\n\n![image-20210818213856432](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213856432.png)\n\n结点输出结果如下：输出的法线信息不会随模型旋转而改变。![image-20210818182418574](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818182418574.png)\n\n## Code\n\n<details>\n    <summary>ReadNormalShader.shader</summary>\n\n\n```c#\n\nShader \"Class4/ReadNormalShader\" {\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.uv0 = v.uv0;\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n////// Lighting:\n////// Emissive:\n\t\t\t\t//准备向量\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0));\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));\n\n\t\t\t\tfloat3 lDir = normalize(_WorldSpaceLightPos0.xyz);//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\t//准备点积信息\n\t\t\t\tfloat nDotl = dot(nDirWS, lDir );//点乘\n\t\t\t\tfloat lambert = max(0.0, nDotl);//把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n```\n\n</details>\n\n\n\n# 菲涅尔\n\n>*什么是菲涅耳效应？*\n>\n>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是**物体材质反射率随角度改变**的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。\n>\n>理论上，对于所有表面光滑的物体来说，**视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。**那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？\n>\n>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：\n>\n>![img](https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg)\n\n![image-20210818204437765](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818204437765.png)\n\n<div class=\"warning\">\n\n> 菲涅尔用于影响环境光的镜面反射效果\n\n</div>\n\n## Shader Forge实现\n\n用观察方向和法线方向点乘，然后再通过One Minus结点，得到中间黑四周亮的效果。\n\n然后可以加一个Power结点，用EXP来控制范围。\n\n![image-20210818213335314](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818213335314.png)\n\nShaderForge也自带Fresnel结点。\n\n\n\n\n\n# 环境的镜面反射\n\n\n\n## Matcap\n\n> 思路：\n>\n> 1. 获得法线贴图后，把结果从切线空间转到观察空间。\n> 2. 然后提取出R和G通道，remap到0-1后作为uv采样一张matcap贴图。（R通道沿屏幕朝左是-1，朝右是1；G通道沿屏幕朝下是-1，朝上是1）\n> 3. 切换金属和非金属可以在把法线的结果从切线空间转到世界空间后再加一个菲涅尔效果，然后用菲涅尔次幂来调节。\n\n![image-20210818221223851](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210818221223851.png)\n\n### Code\n\n在参数输入面板时注意默认值：`_Matcap(\"Matcap\", 2D ) = \"gray\"{}`\n\n注意处理matcap贴图时需要先把观察空间的法线结果取r和g通道，reshape到0-1范围内作为uv坐标`float2 matcapUV = nDirVS.rg * 0.5 + 0.5;`，然后再用该uv坐标对贴图进行采样`float matcap = tex2D(_Matcap, matcapUV);`\n\n<details>\n    <summary>MatcapShader.shader</summary>\n\n```c#\nShader \"Class4/MatcapShader\"\n{\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_Matcap(\"Matcap\", 2D ) = \"gray\"{}\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform sampler2D _Matcap;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//uv0\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0=v.uv0;\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 nDirVS = mul(UNITY_MATRIX_V,float4(nDirWS,0.0));//world to view\n\n\t\t\t\t//中间量准备\n\t\t\t\tfloat2 matcapUV = nDirVS.rg * 0.5 + 0.5;//reshape\n\t\t\t\tfloat nDotv = dot(nDirWS,vDirWS);\n\n\t\t\t\t//光照模型\n\t\t\t\tfloat matcap = tex2D(_Matcap, matcapUV);\n\t\t\t\tfloat fresnel = pow(1.0 - nDotv,_FresnelExp);\n\n\t\t\t\tfloat3 envSpecLighting = matcap*fresnel*_EnvSpecInt;\n\n\n                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n\n```\n\n</details>\n\n## CubeMap\n\n### 生成Mipmap\n\n从网上下载一张HDR的全景图片，然后在ps里修改图像大小为512*512，修改为8位图像，再另存为tga格式。\n\n#### 导入Unity\n\n注意修改Texture设置为Shape，另外Mapping的方式设置为latitude，默认是错的；为了让低精度的效果更自然，需要选择Convolution Type为Specular。FixupEdge Seams最好也勾上。\n\n![image-20210819114859407](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819114859407.png)\n\n### ShaderForge实现\n\n主要思路是获得观察方向，然后通过观察方向在物体表面反弹后的方向来对cubemap采样。所以输入Cubemap的是vrDir。\n\nNormalmap+Transform结点(切线空间转世界空间)相当于获得物体法线。\n\n![image-20210819113658345](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819113658345.png)\n\n另外一个输入MIP指的是mip级别，相当于调节粗糙值。\n\n可以在贴图的预览处调节滑块预览不同mip值的效果。\n\n![image-20210819115506510](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819115506510.png)\n\n### Code\n\n注意参数面板的类型设置：\n\n```c#\nNormalMap(\"法线贴图\",2D) = \"bump\" {}\n_CubeMap(\"环境球\", Cube ) = \"Skybox\"{}\n\n//对于cubemap使用特殊的samplerCUBE采样\nuniform sampler2D _NormalMap;\nuniform samplerCUBE _CubeMap;\n\n//片元着色器中读取Cubemap\nfloat3 vrDirWS = reflect(-vDirWS,nDirWS);//记得获取观察方向的反射方向\nfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n```\n\n<details>\n    <summary>CubemapShader.shader</summary>\n\n```c#\n\nShader \"Class4/CubemapShader\" {\n    Properties {\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_CubeMap(\"环境球\", Cube ) = \"_Skybox\"{}\n\t\t_CubemapMip(\"环境球MIP\",range(0,7)) = 0\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n\t\t_Occlusion (\"AO\",2D) = \"white\" {}\n    }\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\t\t\t\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n            };\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\n\t\t\t\t//中间量,做Fresnel\n\t\t\t\tfloat vdotn = dot(vDirWS,nDirWS);\n\n\t\t\t\t//cubemap\n\t\t\t\tfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\n\t\t\t\tfloat fresnel = pow(1.0-vdotn,_FresnelExp);\n\t\t\t\tfloat occlusion = tex2D(_Occlusion,i.uv0).r;\n\t\t\t\tfloat3 envSpecLighting = cubemap*fresnel*_EnvSpecInt*occlusion;\n\n\n\n                return float4(envSpecLighting,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n# 综合应用\n\n![image-20210819172558238](https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-庄懂的技术美术入门课学习笔记（四）/image-20210819172558238.png)\n\n## Code\n\n> mul()表示向量和矩阵相乘\n>\n> 获得环境光源的信息：\n>\n> 方向：`float lDir= _WorldSpaceLightPos0.xyz;`\n>\n> 颜色：`_LightColor0`\n\n<details>\n    <summary>OldSchoolProShader</summary>\n\n```c#\nShader \"Class4/OldSchoolProShader\"\n{\n    Properties {\n\t\t[Header(Texture)]\n\t\t_Occlusion(\"AO贴图\",2d)= \"white\" {}\n\t\t_NormalMap(\"法线贴图\",2D) = \"bump\" {}\n\t\t_CubeMap(\"环境球\", cube ) = \"_Skybox\"{}\n\n\t\t[Header(Diffuse)]\n\t\t_BaseCol(\"基本颜色\",color)=(1.0,0.0,0.0,1.0)\n\t\t//_LightCol(\"光照颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_Intensity(\"光照强度\",range(0,5))=1\n\t\t_EnvIntensity(\"环境光强度\",range(0,5))=1\n\t\t_EnvUpCol(\"顶部颜色\",color)=(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(\"底部颜色\",color)=(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(\"侧面颜色\",color)=(0.5,0.5,0.5,1.0)\n\n\t\t[Header(Specular)]\n\t\t_SpecularPow(\"高光次幂\",range(1,90))= 30\n\t\t_CubemapMip(\"环境球MIP\",range(0,7)) = 0\n\t\t_FresnelExp(\"菲涅尔次幂\",range(0,10)) = 1\n\t\t_EnvSpecInt(\"环境镜面反射强度\",range(0,5))=0.2\n\n\n\t\t}\n    SubShader {\n        Tags {\n            \"RenderType\"=\"Opaque\"\n        }\n        LOD 100\n        Pass {\n            Name \"FORWARD\"\n            Tags {\n                \"LightMode\"=\"ForwardBase\"\n            }\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"AutoLight.cginc\"  //使用unity投影必须包含\n\t\t\t#include \"Lighting.cginc\"  //使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\t//uniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput {\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;//获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;//将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;//切线\n            };\n            struct VertexOutput {\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;//世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            };\n\n\t\t\t//输入结构>>>顶点Shader>>>输出结构\n            VertexOutput vert (VertexInput v) {\n                VertexOutput o = (VertexOutput)0;\n                o.pos = UnityObjectToClipPos( v.vertex );//转换到裁剪空间\n\t\t\t\to.posWS = mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS = UnityObjectToWorldNormal(v.normal);//由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS = normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS = normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 = v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            }\n            float4 frag(VertexOutput i) : COLOR {\n\t\t\t//准备向量 \n\n\t\t\t\tfloat3 lDir = _WorldSpaceLightPos0.xyz;//Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t//向量准备\n\t\t\t\tfloat3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS = UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS = normalize(mul(nDirTS,TBN));//tangent to world\n\t\t\t\tfloat3 vrDirWS = reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS = reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow = LIGHT_ATTENUATION(i);\n\n////// Light:\n\t\t\t\tfloat nDotl = dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr = dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn = dot(vDirWS,nDirWS);\n\n\t\t\t\tfloat lambert = max(0.0,nDotl);\n\t\t\t\t//float specCol = var_SpecTex.rgb;\n\t\t\t\t//float specPow = lerp(_SpecularPow,1.0,var_SpecTex.a);  //高光贴图,用rgb通道存储颜色，a通道存储光滑度\n\t\t\t\tfloat phong = pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t///直接光照\n\t\t\t\tfloat3 lightRes =_LightColor0*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n////// env:\n\n\t\t\t\t//环境光漫反射\n\t\t\t\tfloat upMask = max(0.0,nDirWS.g);\n\t\t\t\tfloat downMask = max(0.0,-nDirWS.g);\n\t\t\t\tfloat sideMask = 1.0-upMask-downMask;\n\t\t\t\tfloat3 envCol= _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t//环境光镜面反射\n\t\t\t\t//float cubemapMip=lerp(_CubemapMip,1.0,var_SpecTex.a);  //高光贴图\n\t\t\t\tfloat3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\t\t\t\tfloat fresnel = pow(1.0-vDotn,_FresnelExp);\n\n\t\t\t\t//环境光遮罩\n\t\t\t\tfloat occlusion=tex2D(_Occlusion,i.uv0);\n\n\t\t\t\t//环境光\n\t\t\t\tfloat3 envSpec = cubemap*_EnvSpecInt*fresnel;\n\t\t\t\tfloat3 envDiff = envCol*_BaseCol*_EnvIntensity;\n\t\t\t\tfloat3 envRes = (envSpec+envDiff)*occlusion;\n\n\t\t\t\tfloat3 finalRGB = lightRes+envRes;\n\n                return float4(finalRGB,1.0);//注意代码规范，转化为float4 rgba\n            }\n            ENDCG\n        }\n    }\n    FallBack \"Diffuse\"\n}\n\n```\n\n</details>\n\n","slug":"2021-08-18-庄懂的技术美术入门课学习笔记（四）","published":1,"updated":"2021-08-29T08:58:40.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksx100m5003f3svoc7kn7ef9","content":"<blockquote>\n<p>对应课程9-10课内容</p>\n</blockquote>\n<h1 id=\"法线\"><a href=\"#法线\" class=\"headerlink\" title=\"法线\"></a>法线</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/bonchoix/article/details/8619624\">TBN空间</a></p>\n</blockquote>\n<h2 id=\"ShaderForge自主实现读取法线贴图\"><a href=\"#ShaderForge自主实现读取法线贴图\" class=\"headerlink\" title=\"ShaderForge自主实现读取法线贴图\"></a>ShaderForge自主实现读取法线贴图</h2><p>法线贴图的信息是经过编码的，需要通过<code>UnpackNormal(tex2D(normalMap,uv))</code>来解码。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818182522503.png\" alt=\"image-20210818182522503\" loading=\"lazy\"></p>\n<p>前面这部分也可以用Transform结点代替。记得要改下面的设置：From Tangent to World</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818213856432.png\" alt=\"image-20210818213856432\" loading=\"lazy\"></p>\n<p>结点输出结果如下：输出的法线信息不会随模型旋转而改变。<img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818182418574.png\" alt=\"image-20210818182418574\" loading=\"lazy\"></p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><details>\n    <summary>ReadNormalShader.shader</summary>\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\nShader &quot;Class4&#x2F;ReadNormalShader&quot; &#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0));\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));\n\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\t&#x2F;&#x2F;准备点积信息\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n\n<h1 id=\"菲涅尔\"><a href=\"#菲涅尔\" class=\"headerlink\" title=\"菲涅尔\"></a>菲涅尔</h1><blockquote>\n<p><em>什么是菲涅耳效应？</em></p>\n<p>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是<strong>物体材质反射率随角度改变</strong>的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。</p>\n<p>理论上，对于所有表面光滑的物体来说，<strong>视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。</strong>那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？</p>\n<p>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：</p>\n<p><img src=\"https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg\" alt=\"img\" loading=\"lazy\"></p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818204437765.png\" alt=\"image-20210818204437765\" loading=\"lazy\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>菲涅尔用于影响环境光的镜面反射效果</p>\n</blockquote>\n</div>\n\n<h2 id=\"Shader-Forge实现\"><a href=\"#Shader-Forge实现\" class=\"headerlink\" title=\"Shader Forge实现\"></a>Shader Forge实现</h2><p>用观察方向和法线方向点乘，然后再通过One Minus结点，得到中间黑四周亮的效果。</p>\n<p>然后可以加一个Power结点，用EXP来控制范围。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818213335314.png\" alt=\"image-20210818213335314\" loading=\"lazy\"></p>\n<p>ShaderForge也自带Fresnel结点。</p>\n<h1 id=\"环境的镜面反射\"><a href=\"#环境的镜面反射\" class=\"headerlink\" title=\"环境的镜面反射\"></a>环境的镜面反射</h1><h2 id=\"Matcap\"><a href=\"#Matcap\" class=\"headerlink\" title=\"Matcap\"></a>Matcap</h2><blockquote>\n<p>思路：</p>\n<ol>\n<li>获得法线贴图后，把结果从切线空间转到观察空间。</li>\n<li>然后提取出R和G通道，remap到0-1后作为uv采样一张matcap贴图。（R通道沿屏幕朝左是-1，朝右是1；G通道沿屏幕朝下是-1，朝上是1）</li>\n<li>切换金属和非金属可以在把法线的结果从切线空间转到世界空间后再加一个菲涅尔效果，然后用菲涅尔次幂来调节。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818221223851.png\" alt=\"image-20210818221223851\" loading=\"lazy\"></p>\n<h3 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h3><p>在参数输入面板时注意默认值：<code>_Matcap(&quot;Matcap&quot;, 2D ) = &quot;gray&quot;&#123;&#125;</code></p>\n<p>注意处理matcap贴图时需要先把观察空间的法线结果取r和g通道，reshape到0-1范围内作为uv坐标<code>float2 matcapUV = nDirVS.rg * 0.5 + 0.5;</code>，然后再用该uv坐标对贴图进行采样<code>float matcap = tex2D(_Matcap, matcapUV);</code></p>\n<details>\n    <summary>MatcapShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class4&#x2F;MatcapShader&quot;\n&#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_Matcap(&quot;Matcap&quot;, 2D ) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform sampler2D _Matcap;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;uv0\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0&#x3D;v.uv0;\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 nDirVS &#x3D; mul(UNITY_MATRIX_V,float4(nDirWS,0.0));&#x2F;&#x2F;world to view\n\n\t\t\t\t&#x2F;&#x2F;中间量准备\n\t\t\t\tfloat2 matcapUV &#x3D; nDirVS.rg * 0.5 + 0.5;&#x2F;&#x2F;reshape\n\t\t\t\tfloat nDotv &#x3D; dot(nDirWS,vDirWS);\n\n\t\t\t\t&#x2F;&#x2F;光照模型\n\t\t\t\tfloat matcap &#x3D; tex2D(_Matcap, matcapUV);\n\t\t\t\tfloat fresnel &#x3D; pow(1.0 - nDotv,_FresnelExp);\n\n\t\t\t\tfloat3 envSpecLighting &#x3D; matcap*fresnel*_EnvSpecInt;\n\n\n                return float4(envSpecLighting,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h2 id=\"CubeMap\"><a href=\"#CubeMap\" class=\"headerlink\" title=\"CubeMap\"></a>CubeMap</h2><h3 id=\"生成Mipmap\"><a href=\"#生成Mipmap\" class=\"headerlink\" title=\"生成Mipmap\"></a>生成Mipmap</h3><p>从网上下载一张HDR的全景图片，然后在ps里修改图像大小为512*512，修改为8位图像，再另存为tga格式。</p>\n<h4 id=\"导入Unity\"><a href=\"#导入Unity\" class=\"headerlink\" title=\"导入Unity\"></a>导入Unity</h4><p>注意修改Texture设置为Shape，另外Mapping的方式设置为latitude，默认是错的；为了让低精度的效果更自然，需要选择Convolution Type为Specular。FixupEdge Seams最好也勾上。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819114859407.png\" alt=\"image-20210819114859407\" loading=\"lazy\"></p>\n<h3 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h3><p>主要思路是获得观察方向，然后通过观察方向在物体表面反弹后的方向来对cubemap采样。所以输入Cubemap的是vrDir。</p>\n<p>Normalmap+Transform结点(切线空间转世界空间)相当于获得物体法线。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819113658345.png\" alt=\"image-20210819113658345\" loading=\"lazy\"></p>\n<p>另外一个输入MIP指的是mip级别，相当于调节粗糙值。</p>\n<p>可以在贴图的预览处调节滑块预览不同mip值的效果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819115506510.png\" alt=\"image-20210819115506510\" loading=\"lazy\"></p>\n<h3 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h3><p>注意参数面板的类型设置：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n_CubeMap(&quot;环境球&quot;, Cube ) &#x3D; &quot;Skybox&quot;&#123;&#125;\n\n&#x2F;&#x2F;对于cubemap使用特殊的samplerCUBE采样\nuniform sampler2D _NormalMap;\nuniform samplerCUBE _CubeMap;\n\n&#x2F;&#x2F;片元着色器中读取Cubemap\nfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);&#x2F;&#x2F;记得获取观察方向的反射方向\nfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<details>\n    <summary>CubemapShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\nShader &quot;Class4&#x2F;CubemapShader&quot; &#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, Cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\t\t_CubemapMip(&quot;环境球MIP&quot;,range(0,7)) &#x3D; 0\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n\t\t_Occlusion (&quot;AO&quot;,2D) &#x3D; &quot;white&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\t\t\t\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;中间量,做Fresnel\n\t\t\t\tfloat vdotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;cubemap\n\t\t\t\tfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\n\t\t\t\tfloat fresnel &#x3D; pow(1.0-vdotn,_FresnelExp);\n\t\t\t\tfloat occlusion &#x3D; tex2D(_Occlusion,i.uv0).r;\n\t\t\t\tfloat3 envSpecLighting &#x3D; cubemap*fresnel*_EnvSpecInt*occlusion;\n\n\n\n                return float4(envSpecLighting,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"综合应用\"><a href=\"#综合应用\" class=\"headerlink\" title=\"综合应用\"></a>综合应用</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819172558238.png\" alt=\"image-20210819172558238\" loading=\"lazy\"></p>\n<h2 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h2><blockquote>\n<p>mul()表示向量和矩阵相乘</p>\n<p>获得环境光源的信息：</p>\n<p>方向：<code>float lDir= _WorldSpaceLightPos0.xyz;</code></p>\n<p>颜色：<code>_LightColor0</code></p>\n</blockquote>\n<details>\n    <summary>OldSchoolProShader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class4&#x2F;OldSchoolProShader&quot;\n&#123;\n    Properties &#123;\n\t\t[Header(Texture)]\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n\t\t[Header(Diffuse)]\n\t\t_BaseCol(&quot;基本颜色&quot;,color)&#x3D;(1.0,0.0,0.0,1.0)\n\t\t&#x2F;&#x2F;_LightCol(&quot;光照颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_Intensity(&quot;光照强度&quot;,range(0,5))&#x3D;1\n\t\t_EnvIntensity(&quot;环境光强度&quot;,range(0,5))&#x3D;1\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t[Header(Specular)]\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_CubemapMip(&quot;环境球MIP&quot;,range(0,7)) &#x3D; 0\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\t&#x2F;&#x2F;uniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Light:\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\tfloat lambert &#x3D; max(0.0,nDotl);\n\t\t\t\t&#x2F;&#x2F;float specCol &#x3D; var_SpecTex.rgb;\n\t\t\t\t&#x2F;&#x2F;float specPow &#x3D; lerp(_SpecularPow,1.0,var_SpecTex.a);  &#x2F;&#x2F;高光贴图,用rgb通道存储颜色，a通道存储光滑度\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t&#x2F;&#x2F;&#x2F;直接光照\n\t\t\t\tfloat3 lightRes &#x3D;_LightColor0*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; env:\n\n\t\t\t\t&#x2F;&#x2F;环境光漫反射\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDirWS.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDirWS.g);\n\t\t\t\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;环境光镜面反射\n\t\t\t\t&#x2F;&#x2F;float cubemapMip&#x3D;lerp(_CubemapMip,1.0,var_SpecTex.a);  &#x2F;&#x2F;高光贴图\n\t\t\t\tfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\t\t\t\tfloat fresnel &#x3D; pow(1.0-vDotn,_FresnelExp);\n\n\t\t\t\t&#x2F;&#x2F;环境光遮罩\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv0);\n\n\t\t\t\t&#x2F;&#x2F;环境光\n\t\t\t\tfloat3 envSpec &#x3D; cubemap*_EnvSpecInt*fresnel;\n\t\t\t\tfloat3 envDiff &#x3D; envCol*_BaseCol*_EnvIntensity;\n\t\t\t\tfloat3 envRes &#x3D; (envSpec+envDiff)*occlusion;\n\n\t\t\t\tfloat3 finalRGB &#x3D; lightRes+envRes;\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n","site":{"data":{"style/banner":"","yun":{"banner":{"enable":true,"src":"/js/ui/banner.js","border":false,"cloud":{"enable":true,"color":"white"},"go_down":{"enable":true,"icon":"icon-arrow-down-s-line"},"title":["HQZ","BLOG"]},"mode":"light","notice":{"enable":false,"content":"Thanks for playing my game."},"menu":{"home":{"path":"/","icon":"icon-home-4-line"},"list":[{"type":"archives","path":"/archives/","icon":"icon-archive-line"},{"type":"categories","path":"/categories/","icon":"icon-folder-2-line"},{"type":"tags","path":"/tags/","icon":"icon-price-tag-3-line"}],"custom":{"title":"相册","path":"/albums/","icon":"icon-gallery-line"}},"trianglify":{"enable":true,"cellSize":100,"width":800,"height":600,"palette":"[\"Blues\"]","opacity":0.7},"avatar":{"enable":true,"url":"https://z3.ax1x.com/2021/08/29/hGY55T.jpg","rounded":true,"opacity":1,"mickey_mouse":false,"status":{"enable":true,"emoji":"😭","message":"不想上学"}},"bg_image":{"enable":true,"opacity":0.8},"post_card":{"opacity":0.9},"sidebar":{"bg_image":null,"tagcloud":{"enable":false,"amount":20}},"social":[{"name":"GitHub","link":"https://github.com/HQiuzi","icon":"icon-github-line","color":"#6e5494"},{"name":"E-Mail","link":"hqz_1013@163.com","icon":"icon-mail-line","color":"#8E71C1"}],"pages":null,"say":{"enable":false},"codeblock":{"copy_btn":true,"prismjs":{"light":"default","dark":"tomorrow"}},"reward":{"enable":false},"custom":{"style":"source/_data/style/*"},"albums":{"enable":true},"wordcloud":{"enable":false}},"style/sidebar":".site-state-item-icon .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n.sidebar .links-of-author .icon {\n  width: 1.3rem;\n  height: 1.3rem;\n}\n"}},"excerpt":"","more":"<blockquote>\n<p>对应课程9-10课内容</p>\n</blockquote>\n<h1 id=\"法线\"><a href=\"#法线\" class=\"headerlink\" title=\"法线\"></a>法线</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/bonchoix/article/details/8619624\">TBN空间</a></p>\n</blockquote>\n<h2 id=\"ShaderForge自主实现读取法线贴图\"><a href=\"#ShaderForge自主实现读取法线贴图\" class=\"headerlink\" title=\"ShaderForge自主实现读取法线贴图\"></a>ShaderForge自主实现读取法线贴图</h2><p>法线贴图的信息是经过编码的，需要通过<code>UnpackNormal(tex2D(normalMap,uv))</code>来解码。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818182522503.png\" alt=\"image-20210818182522503\"></p>\n<p>前面这部分也可以用Transform结点代替。记得要改下面的设置：From Tangent to World</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818213856432.png\" alt=\"image-20210818213856432\"></p>\n<p>结点输出结果如下：输出的法线信息不会随模型旋转而改变。<img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818182418574.png\" alt=\"image-20210818182418574\"></p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><details>\n    <summary>ReadNormalShader.shader</summary>\n\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\nShader &quot;Class4&#x2F;ReadNormalShader&quot; &#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 :TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Lighting:\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Emissive:\n\t\t\t\t&#x2F;&#x2F;准备向量\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0));\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));\n\n\t\t\t\tfloat3 lDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t\n\t\t\t\t&#x2F;&#x2F;准备点积信息\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS, lDir );&#x2F;&#x2F;点乘\n\t\t\t\tfloat lambert &#x3D; max(0.0, nDotl);&#x2F;&#x2F;把负数部分取0\n\n                return float4(lambert,lambert,lambert,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n\n\n<h1 id=\"菲涅尔\"><a href=\"#菲涅尔\" class=\"headerlink\" title=\"菲涅尔\"></a>菲涅尔</h1><blockquote>\n<p><em>什么是菲涅耳效应？</em></p>\n<p>简要地说，物体在不同角度观察下，表面的反射率是不一样的。菲涅耳效应模拟的就是<strong>物体材质反射率随角度改变</strong>的效果。肥皂泡在边缘处，即视线与表面夹角处比较小时，反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。下图右中，池塘远处的水面看上去像镜面一样，近处的水面则更透彻，这同样是由于菲涅耳效应——在不同视角观察下物体材质反射率不同。</p>\n<p>理论上，对于所有表面光滑的物体来说，<strong>视线与物体表面几乎平行时，即与表面法线夹角（gazing angle）为 90 度时，都会看上去像镜面一样（100% 的反射率）。</strong>那么问题来了，如果垂直盯着物体表面看，即与表面法线夹角为 0 的话，那么有多少光线被反射，有多少光线被吸收／折射？</p>\n<p>这取决于物体的物理特性。随视线夹角变化时，反射比率大致类似这样：</p>\n<p><img src=\"https://pic3.zhimg.com/80/ebf6136b3d1a2250b78136944aa23586_720w.jpg\" alt=\"img\"></p>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818204437765.png\" alt=\"image-20210818204437765\"></p>\n<div class=\"warning\">\n\n<blockquote>\n<p>菲涅尔用于影响环境光的镜面反射效果</p>\n</blockquote>\n</div>\n\n<h2 id=\"Shader-Forge实现\"><a href=\"#Shader-Forge实现\" class=\"headerlink\" title=\"Shader Forge实现\"></a>Shader Forge实现</h2><p>用观察方向和法线方向点乘，然后再通过One Minus结点，得到中间黑四周亮的效果。</p>\n<p>然后可以加一个Power结点，用EXP来控制范围。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818213335314.png\" alt=\"image-20210818213335314\"></p>\n<p>ShaderForge也自带Fresnel结点。</p>\n<h1 id=\"环境的镜面反射\"><a href=\"#环境的镜面反射\" class=\"headerlink\" title=\"环境的镜面反射\"></a>环境的镜面反射</h1><h2 id=\"Matcap\"><a href=\"#Matcap\" class=\"headerlink\" title=\"Matcap\"></a>Matcap</h2><blockquote>\n<p>思路：</p>\n<ol>\n<li>获得法线贴图后，把结果从切线空间转到观察空间。</li>\n<li>然后提取出R和G通道，remap到0-1后作为uv采样一张matcap贴图。（R通道沿屏幕朝左是-1，朝右是1；G通道沿屏幕朝下是-1，朝上是1）</li>\n<li>切换金属和非金属可以在把法线的结果从切线空间转到世界空间后再加一个菲涅尔效果，然后用菲涅尔次幂来调节。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210818221223851.png\" alt=\"image-20210818221223851\"></p>\n<h3 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h3><p>在参数输入面板时注意默认值：<code>_Matcap(&quot;Matcap&quot;, 2D ) = &quot;gray&quot;&#123;&#125;</code></p>\n<p>注意处理matcap贴图时需要先把观察空间的法线结果取r和g通道，reshape到0-1范围内作为uv坐标<code>float2 matcapUV = nDirVS.rg * 0.5 + 0.5;</code>，然后再用该uv坐标对贴图进行采样<code>float matcap = tex2D(_Matcap, matcapUV);</code></p>\n<details>\n    <summary>MatcapShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class4&#x2F;MatcapShader&quot;\n&#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_Matcap(&quot;Matcap&quot;, 2D ) &#x3D; &quot;gray&quot;&#123;&#125;\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform sampler2D _Matcap;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;uv0\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0&#x3D;v.uv0;\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 nDirVS &#x3D; mul(UNITY_MATRIX_V,float4(nDirWS,0.0));&#x2F;&#x2F;world to view\n\n\t\t\t\t&#x2F;&#x2F;中间量准备\n\t\t\t\tfloat2 matcapUV &#x3D; nDirVS.rg * 0.5 + 0.5;&#x2F;&#x2F;reshape\n\t\t\t\tfloat nDotv &#x3D; dot(nDirWS,vDirWS);\n\n\t\t\t\t&#x2F;&#x2F;光照模型\n\t\t\t\tfloat matcap &#x3D; tex2D(_Matcap, matcapUV);\n\t\t\t\tfloat fresnel &#x3D; pow(1.0 - nDotv,_FresnelExp);\n\n\t\t\t\tfloat3 envSpecLighting &#x3D; matcap*fresnel*_EnvSpecInt;\n\n\n                return float4(envSpecLighting,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h2 id=\"CubeMap\"><a href=\"#CubeMap\" class=\"headerlink\" title=\"CubeMap\"></a>CubeMap</h2><h3 id=\"生成Mipmap\"><a href=\"#生成Mipmap\" class=\"headerlink\" title=\"生成Mipmap\"></a>生成Mipmap</h3><p>从网上下载一张HDR的全景图片，然后在ps里修改图像大小为512*512，修改为8位图像，再另存为tga格式。</p>\n<h4 id=\"导入Unity\"><a href=\"#导入Unity\" class=\"headerlink\" title=\"导入Unity\"></a>导入Unity</h4><p>注意修改Texture设置为Shape，另外Mapping的方式设置为latitude，默认是错的；为了让低精度的效果更自然，需要选择Convolution Type为Specular。FixupEdge Seams最好也勾上。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819114859407.png\" alt=\"image-20210819114859407\"></p>\n<h3 id=\"ShaderForge实现\"><a href=\"#ShaderForge实现\" class=\"headerlink\" title=\"ShaderForge实现\"></a>ShaderForge实现</h3><p>主要思路是获得观察方向，然后通过观察方向在物体表面反弹后的方向来对cubemap采样。所以输入Cubemap的是vrDir。</p>\n<p>Normalmap+Transform结点(切线空间转世界空间)相当于获得物体法线。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819113658345.png\" alt=\"image-20210819113658345\"></p>\n<p>另外一个输入MIP指的是mip级别，相当于调节粗糙值。</p>\n<p>可以在贴图的预览处调节滑块预览不同mip值的效果。</p>\n<p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819115506510.png\" alt=\"image-20210819115506510\"></p>\n<h3 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h3><p>注意参数面板的类型设置：</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n_CubeMap(&quot;环境球&quot;, Cube ) &#x3D; &quot;Skybox&quot;&#123;&#125;\n\n&#x2F;&#x2F;对于cubemap使用特殊的samplerCUBE采样\nuniform sampler2D _NormalMap;\nuniform samplerCUBE _CubeMap;\n\n&#x2F;&#x2F;片元着色器中读取Cubemap\nfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);&#x2F;&#x2F;记得获取观察方向的反射方向\nfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<details>\n    <summary>CubemapShader.shader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\nShader &quot;Class4&#x2F;CubemapShader&quot; &#123;\n    Properties &#123;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, Cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\t\t_CubemapMip(&quot;环境球MIP&quot;,range(0,7)) &#x3D; 0\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n\t\t_Occlusion (&quot;AO&quot;,2D) &#x3D; &quot;white&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\t\t\t\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n            &#125;;\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;中间量,做Fresnel\n\t\t\t\tfloat vdotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\t&#x2F;&#x2F;cubemap\n\t\t\t\tfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\n\t\t\t\tfloat fresnel &#x3D; pow(1.0-vdotn,_FresnelExp);\n\t\t\t\tfloat occlusion &#x3D; tex2D(_Occlusion,i.uv0).r;\n\t\t\t\tfloat3 envSpecLighting &#x3D; cubemap*fresnel*_EnvSpecInt*occlusion;\n\n\n\n                return float4(envSpecLighting,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n<h1 id=\"综合应用\"><a href=\"#综合应用\" class=\"headerlink\" title=\"综合应用\"></a>综合应用</h1><p><img src=\"https://github.com/HQiuzi/HQiuzi.github.io/raw/hexo/images/2021-08-18-%E5%BA%84%E6%87%82%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/image-20210819172558238.png\" alt=\"image-20210819172558238\"></p>\n<h2 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h2><blockquote>\n<p>mul()表示向量和矩阵相乘</p>\n<p>获得环境光源的信息：</p>\n<p>方向：<code>float lDir= _WorldSpaceLightPos0.xyz;</code></p>\n<p>颜色：<code>_LightColor0</code></p>\n</blockquote>\n<details>\n    <summary>OldSchoolProShader</summary>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Shader &quot;Class4&#x2F;OldSchoolProShader&quot;\n&#123;\n    Properties &#123;\n\t\t[Header(Texture)]\n\t\t_Occlusion(&quot;AO贴图&quot;,2d)&#x3D; &quot;white&quot; &#123;&#125;\n\t\t_NormalMap(&quot;法线贴图&quot;,2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\t\t_CubeMap(&quot;环境球&quot;, cube ) &#x3D; &quot;_Skybox&quot;&#123;&#125;\n\n\t\t[Header(Diffuse)]\n\t\t_BaseCol(&quot;基本颜色&quot;,color)&#x3D;(1.0,0.0,0.0,1.0)\n\t\t&#x2F;&#x2F;_LightCol(&quot;光照颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_Intensity(&quot;光照强度&quot;,range(0,5))&#x3D;1\n\t\t_EnvIntensity(&quot;环境光强度&quot;,range(0,5))&#x3D;1\n\t\t_EnvUpCol(&quot;顶部颜色&quot;,color)&#x3D;(1.0,1.0,1.0,1.0)\n\t\t_EnvDownCol(&quot;底部颜色&quot;,color)&#x3D;(0.0,0.0,0.0,1.0)\n\t\t_EnvSideCol(&quot;侧面颜色&quot;,color)&#x3D;(0.5,0.5,0.5,1.0)\n\n\t\t[Header(Specular)]\n\t\t_SpecularPow(&quot;高光次幂&quot;,range(1,90))&#x3D; 30\n\t\t_CubemapMip(&quot;环境球MIP&quot;,range(0,7)) &#x3D; 0\n\t\t_FresnelExp(&quot;菲涅尔次幂&quot;,range(0,10)) &#x3D; 1\n\t\t_EnvSpecInt(&quot;环境镜面反射强度&quot;,range(0,5))&#x3D;0.2\n\n\n\t\t&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n        LOD 100\n        Pass &#123;\n            Name &quot;FORWARD&quot;\n            Tags &#123;\n                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;\n            &#125;\n            \n            \n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include &quot;UnityCG.cginc&quot;\n\t\t\t#include &quot;AutoLight.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n\t\t\t#include &quot;Lighting.cginc&quot;  &#x2F;&#x2F;使用unity投影必须包含\n            #pragma multi_compile_fwdbase_fullshadows\n            #pragma multi_compile_fog\n            #pragma target 3.0\n\n\t\t\tuniform float3 _BaseCol;\n\t\t\t&#x2F;&#x2F;uniform float3 _LightCol;\n\t\t\tuniform float _SpecularPow;\n\t\t\tuniform float _Intensity;\n\t\t\tuniform float _EnvIntensity;\n\t\t\tuniform sampler2D _Occlusion;\n\t\t\tuniform float3 _EnvUpCol;\n\t\t\tuniform float3 _EnvDownCol;\n\t\t\tuniform float3 _EnvSideCol;\n\n\t\t\tuniform sampler2D _NormalMap;\n\t\t\tuniform samplerCUBE _CubeMap;\n\t\t\tuniform float _CubemapMip;\n\t\t\tuniform float _FresnelExp;\n\t\t\tuniform float _EnvSpecInt;\n\n            struct VertexInput &#123;\n                float4 vertex : POSITION;\n\t\t\t\tfloat3 normal : NORMAL;&#x2F;&#x2F;获取法线信息\n\t\t\t\tfloat2 uv0 : TEXCOORD0;&#x2F;&#x2F;将模型uv信息输入进来\n\t\t\t\tfloat4 tangent : TANGENT;&#x2F;&#x2F;切线\n            &#125;;\n            struct VertexOutput &#123;\n                float4 pos : SV_POSITION;\n\t\t\t\tfloat2 uv0 : TEXCOORD0;\n\t\t\t\tfloat3 nDirWS : TEXCOORD1;\n\t\t\t\tfloat3 tDirWS : TEXCOORD2;\n\t\t\t\tfloat3 bDirWS : TEXCOORD3;\n\t\t\t\tfloat4 posWS : TEXCOORD4;&#x2F;&#x2F;世界定点信息\n\t\t\t\tLIGHTING_COORDS(5,6)\n\t\t\t\t\n            &#125;;\n\n\t\t\t&#x2F;&#x2F;输入结构&gt;&gt;&gt;顶点Shader&gt;&gt;&gt;输出结构\n            VertexOutput vert (VertexInput v) &#123;\n                VertexOutput o &#x3D; (VertexOutput)0;\n                o.pos &#x3D; UnityObjectToClipPos( v.vertex );&#x2F;&#x2F;转换到裁剪空间\n\t\t\t\to.posWS &#x3D; mul(unity_ObjectToWorld,v.vertex);\n\t\t\t\to.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);&#x2F;&#x2F;由模型法线信息换算的世界空间法线信息\n\t\t\t\to.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld,float4(v.tangent.xyz,0.0)).xyz);\n\t\t\t\to.bDirWS &#x3D; normalize(cross(o.nDirWS,o.tDirWS)*v.tangent.w);\n\t\t\t\to.uv0 &#x3D; v.uv0;\n\n\t\t\t\tTRANSFER_VERTEX_TO_FRAGMENT(o)\n\n                return o;\n            &#125;\n            float4 frag(VertexOutput i) : COLOR &#123;\n\t\t\t&#x2F;&#x2F;准备向量 \n\n\t\t\t\tfloat3 lDir &#x3D; _WorldSpaceLightPos0.xyz;&#x2F;&#x2F;Pos0是平行光，xyz代表方向坐标，这里最好做一下正则化\n\t\t\t\t&#x2F;&#x2F;向量准备\n\t\t\t\tfloat3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);\n\t\t\t\tfloat3 nDirTS &#x3D; UnpackNormal(tex2D(_NormalMap,i.uv0)).rgb;\n\t\t\t\tfloat3x3 TBN &#x3D; float3x3(i.tDirWS,i.bDirWS,i.nDirWS);\n\t\t\t\tfloat3 nDirWS &#x3D; normalize(mul(nDirTS,TBN));&#x2F;&#x2F;tangent to world\n\t\t\t\tfloat3 vrDirWS &#x3D; reflect(-vDirWS,nDirWS);\n\t\t\t\tfloat3 rDirWS &#x3D; reflect(-lDir,nDirWS);\n\n\t\t\t\tfloat shadow &#x3D; LIGHT_ATTENUATION(i);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Light:\n\t\t\t\tfloat nDotl &#x3D; dot(nDirWS,lDir);\n\t\t\t\tfloat vDotr &#x3D; dot(vDirWS,rDirWS);\n\t\t\t\tfloat vDotn &#x3D; dot(vDirWS,nDirWS);\n\n\t\t\t\tfloat lambert &#x3D; max(0.0,nDotl);\n\t\t\t\t&#x2F;&#x2F;float specCol &#x3D; var_SpecTex.rgb;\n\t\t\t\t&#x2F;&#x2F;float specPow &#x3D; lerp(_SpecularPow,1.0,var_SpecTex.a);  &#x2F;&#x2F;高光贴图,用rgb通道存储颜色，a通道存储光滑度\n\t\t\t\tfloat phong &#x3D; pow(max(0.0,vDotr),_SpecularPow);\n\n\t\t\t\t&#x2F;&#x2F;&#x2F;直接光照\n\t\t\t\tfloat3 lightRes &#x3D;_LightColor0*(_BaseCol*lambert+phong)*_Intensity*shadow;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; env:\n\n\t\t\t\t&#x2F;&#x2F;环境光漫反射\n\t\t\t\tfloat upMask &#x3D; max(0.0,nDirWS.g);\n\t\t\t\tfloat downMask &#x3D; max(0.0,-nDirWS.g);\n\t\t\t\tfloat sideMask &#x3D; 1.0-upMask-downMask;\n\t\t\t\tfloat3 envCol&#x3D; _EnvUpCol*upMask+_EnvDownCol*downMask+_EnvSideCol*sideMask;\n\n\t\t\t\t&#x2F;&#x2F;环境光镜面反射\n\t\t\t\t&#x2F;&#x2F;float cubemapMip&#x3D;lerp(_CubemapMip,1.0,var_SpecTex.a);  &#x2F;&#x2F;高光贴图\n\t\t\t\tfloat3 cubemap &#x3D; texCUBElod(_CubeMap, float4(vrDirWS,_CubemapMip));\n\t\t\t\tfloat fresnel &#x3D; pow(1.0-vDotn,_FresnelExp);\n\n\t\t\t\t&#x2F;&#x2F;环境光遮罩\n\t\t\t\tfloat occlusion&#x3D;tex2D(_Occlusion,i.uv0);\n\n\t\t\t\t&#x2F;&#x2F;环境光\n\t\t\t\tfloat3 envSpec &#x3D; cubemap*_EnvSpecInt*fresnel;\n\t\t\t\tfloat3 envDiff &#x3D; envCol*_BaseCol*_EnvIntensity;\n\t\t\t\tfloat3 envRes &#x3D; (envSpec+envDiff)*occlusion;\n\n\t\t\t\tfloat3 finalRGB &#x3D; lightRes+envRes;\n\n                return float4(finalRGB,1.0);&#x2F;&#x2F;注意代码规范，转化为float4 rgba\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n</details>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cksx100l100093svo09ac7io5","category_id":"cksx100kx00043svoe0jihimq","_id":"cksx100l7000h3svobpjo07xv"},{"post_id":"cksx100ks00013svo3u9i8tmt","category_id":"cksx100kx00043svoe0jihimq","_id":"cksx100l9000l3svo9bvc8pa3"},{"post_id":"cksx100kv00033svo6bp36w0q","category_id":"cksx100l4000c3svo5r2t7sxj","_id":"cksx100l9000n3svo8v8mfrox"},{"post_id":"cksx100l8000k3svo9399dzvk","category_id":"cksx100kx00043svoe0jihimq","_id":"cksx100ld000r3svodw2397zl"},{"post_id":"cksx100kz00073svo5jba9ljr","category_id":"cksx100l7000i3svo848428jf","_id":"cksx100le000u3svo9ch09vlb"},{"post_id":"cksx100l3000b3svo2964dgbp","category_id":"cksx100l7000i3svo848428jf","_id":"cksx100le000v3svo6cnn0tlv"},{"post_id":"cksx100l5000f3svocxs4cql7","category_id":"cksx100ld000s3svo7k18f4i5","_id":"cksx100lf00103svo6uuif0l5"},{"post_id":"cksx100l7000g3svog7wh3cnk","category_id":"cksx100ld000s3svo7k18f4i5","_id":"cksx100lg00143svo8pc98esy"},{"post_id":"cksx100l9000m3svo3hzv36gn","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100lh001a3svo20fi7xd1"},{"post_id":"cksx100lc000q3svoeesc0lov","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100li001c3svogncg55jm"},{"post_id":"cksx100lw002g3svo6i9i3yka","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100m0002l3svo8y37d3ln"},{"post_id":"cksx100lx002h3svo5i5ie6y0","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100m0002m3svoh1n96q98"},{"post_id":"cksx100ly002j3svoazy8ec5a","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100m0002o3svo36427mqq"},{"post_id":"cksx100m5003f3svoc7kn7ef9","category_id":"cksx100lf000z3svobrf6fhd3","_id":"cksx100m6003h3svoerpt2sf1"}],"PostTag":[{"post_id":"cksx100ks00013svo3u9i8tmt","tag_id":"cksx100ky00053svo7tfyfifr","_id":"cksx100lf000y3svoax9rf7bb"},{"post_id":"cksx100ks00013svo3u9i8tmt","tag_id":"cksx100l4000d3svo3ovvcoeq","_id":"cksx100lf00113svobspsgoji"},{"post_id":"cksx100ks00013svo3u9i8tmt","tag_id":"cksx100l8000j3svohv0h1wif","_id":"cksx100lg00133svo8zm67ioo"},{"post_id":"cksx100ks00013svo3u9i8tmt","tag_id":"cksx100la000p3svo96g1aidk","_id":"cksx100lg00153svo7rkg6657"},{"post_id":"cksx100ks00013svo3u9i8tmt","tag_id":"cksx100le000t3svo9junffeb","_id":"cksx100lh00183svoftng2mk9"},{"post_id":"cksx100kz00073svo5jba9ljr","tag_id":"cksx100le000x3svoa8iw4xu5","_id":"cksx100lh00193svo6sm43o9r"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100le000t3svo9junffeb","_id":"cksx100lj001h3svofu5hcv9g"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100lg00173svo36oq1wr3","_id":"cksx100lj001i3svo05uxd5by"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100lh001b3svo6x822h9o","_id":"cksx100lj001k3svoakhj1d27"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100li001d3svo7eu46nd0","_id":"cksx100lj001l3svoaksd74ba"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100li001e3svoh1wz4pp6","_id":"cksx100lk001n3svod6qc5utt"},{"post_id":"cksx100l100093svo09ac7io5","tag_id":"cksx100li001f3svocva8bswh","_id":"cksx100lk001o3svo7vgodkjp"},{"post_id":"cksx100l3000b3svo2964dgbp","tag_id":"cksx100le000t3svo9junffeb","_id":"cksx100lk001q3svo6x691nqh"},{"post_id":"cksx100l5000f3svocxs4cql7","tag_id":"cksx100lj001j3svoatsb65yb","_id":"cksx100lk001r3svobt5z3s0k"},{"post_id":"cksx100l5000f3svocxs4cql7","tag_id":"cksx100lj001m3svo7bma0n74","_id":"cksx100lk001t3svoappq4ukm"},{"post_id":"cksx100l7000g3svog7wh3cnk","tag_id":"cksx100lk001p3svo1ufnfv5d","_id":"cksx100lk001u3svoa8cxc4pj"},{"post_id":"cksx100l8000k3svo9399dzvk","tag_id":"cksx100lk001s3svo0lujbq1h","_id":"cksx100ll001w3svofz7x5oy6"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100ll001v3svogmww980m","_id":"cksx100lo00233svoff0u1ecp"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100ll001x3svoc4nh0p4t","_id":"cksx100lo00243svoed1h7a8a"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100ln001y3svoac7959sm","_id":"cksx100lo00263svobkbu112y"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100ln001z3svogn7m7no7","_id":"cksx100lp00273svo3f052usu"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100ln00203svohq6cbkuu","_id":"cksx100lp00293svo9iu3fdp5"},{"post_id":"cksx100l9000m3svo3hzv36gn","tag_id":"cksx100lo00213svogaoddfpv","_id":"cksx100lp002a3svo1omg70zz"},{"post_id":"cksx100lc000q3svoeesc0lov","tag_id":"cksx100lo00223svo4697860o","_id":"cksx100lp002c3svo1taug6qm"},{"post_id":"cksx100lc000q3svoeesc0lov","tag_id":"cksx100lo00253svo8smc4gfc","_id":"cksx100lp002d3svodpnh67n0"},{"post_id":"cksx100lc000q3svoeesc0lov","tag_id":"cksx100lp00283svo7bhp36v3","_id":"cksx100lp002e3svo7i96bd4k"},{"post_id":"cksx100lc000q3svoeesc0lov","tag_id":"cksx100lp002b3svo0ruv2rjq","_id":"cksx100lp002f3svo2w4a2q9e"},{"post_id":"cksx100lw002g3svo6i9i3yka","tag_id":"cksx100ly002i3svob7zg40cu","_id":"cksx100m1002r3svo1gz7bj14"},{"post_id":"cksx100lw002g3svo6i9i3yka","tag_id":"cksx100m0002n3svo513u7gs6","_id":"cksx100m1002s3svofxz6bdc9"},{"post_id":"cksx100lw002g3svo6i9i3yka","tag_id":"cksx100m0002p3svo74ym72aj","_id":"cksx100m1002u3svoawuqfcdm"},{"post_id":"cksx100lx002h3svo5i5ie6y0","tag_id":"cksx100m1002q3svodvu5ftxl","_id":"cksx100m2002y3svo3dya2p72"},{"post_id":"cksx100lx002h3svo5i5ie6y0","tag_id":"cksx100m1002t3svo64tq68wp","_id":"cksx100m2002z3svo60dt4r8l"},{"post_id":"cksx100lx002h3svo5i5ie6y0","tag_id":"cksx100m1002v3svoba7b9m1l","_id":"cksx100m200313svo99nch6sn"},{"post_id":"cksx100lx002h3svo5i5ie6y0","tag_id":"cksx100m1002w3svo0tlp1no4","_id":"cksx100m200323svo0mmyfgaw"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m2002x3svogxk78foz","_id":"cksx100m400383svohss2dpo7"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m200303svo7hfsak7h","_id":"cksx100m400393svo9xla5zzt"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m200333svoa5st9c0v","_id":"cksx100m4003a3svo19df54lp"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m300343svo5fyx2zoh","_id":"cksx100m4003b3svoapm24gfu"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m300353svo6m3tgot4","_id":"cksx100m4003c3svo42ra4u6u"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m300363svogm345q65","_id":"cksx100m4003d3svofi3eh54f"},{"post_id":"cksx100ly002j3svoazy8ec5a","tag_id":"cksx100m300373svo23qh4cy4","_id":"cksx100m4003e3svod4mw2ilf"},{"post_id":"cksx100m5003f3svoc7kn7ef9","tag_id":"cksx100m6003g3svo1zre8k50","_id":"cksx100m7003k3svobyb79siw"},{"post_id":"cksx100m5003f3svoc7kn7ef9","tag_id":"cksx100lo00213svogaoddfpv","_id":"cksx100m7003l3svo6mce0jla"},{"post_id":"cksx100m5003f3svoc7kn7ef9","tag_id":"cksx100m6003i3svo1s923qnh","_id":"cksx100m7003m3svo5e6d34u9"},{"post_id":"cksx100m5003f3svoc7kn7ef9","tag_id":"cksx100m6003j3svo6ygs8hpw","_id":"cksx100m7003n3svo6bmka79g"}],"Tag":[{"name":"Action","_id":"cksx100ky00053svo7tfyfifr"},{"name":"数值管理","_id":"cksx100l4000d3svo3ovvcoeq"},{"name":"ScriptObject","_id":"cksx100l8000j3svohv0h1wif"},{"name":"UI跟随物体","_id":"cksx100la000p3svo96g1aidk"},{"name":"Unity","_id":"cksx100le000t3svo9junffeb"},{"name":"hexo","_id":"cksx100le000x3svoa8iw4xu5"},{"name":"场景切换","_id":"cksx100lg00173svo36oq1wr3"},{"name":"GameManager","_id":"cksx100lh001b3svo6x822h9o"},{"name":"单例模式","_id":"cksx100li001d3svo7eu46nd0"},{"name":"UI隐藏","_id":"cksx100li001e3svoh1wz4pp6"},{"name":"状态切换","_id":"cksx100li001f3svocva8bswh"},{"name":"3d辅助","_id":"cksx100lj001j3svoatsb65yb"},{"name":"Daz","_id":"cksx100lj001m3svo7bma0n74"},{"name":"渐变映射","_id":"cksx100lk001p3svo1ufnfv5d"},{"name":"Blender贴图绘制","_id":"cksx100lk001s3svo0lujbq1h"},{"name":"光照模型","_id":"cksx100ll001v3svogmww980m"},{"name":"Lambert","_id":"cksx100ll001x3svoc4nh0p4t"},{"name":"卡通渲染","_id":"cksx100ln001y3svoac7959sm"},{"name":"半色调Halftone","_id":"cksx100ln001z3svogn7m7no7"},{"name":"3S效果","_id":"cksx100ln00203svohq6cbkuu"},{"name":"菲涅尔","_id":"cksx100lo00213svogaoddfpv"},{"name":"反射","_id":"cksx100lo00223svo4697860o"},{"name":"Phong","_id":"cksx100lo00253svo8smc4gfc"},{"name":"Blinn-Phong","_id":"cksx100lp00283svo7bhp36v3"},{"name":"BRDF","_id":"cksx100lp002b3svo0ruv2rjq"},{"name":"环境光","_id":"cksx100ly002i3svob7zg40cu"},{"name":"AO","_id":"cksx100m0002n3svo513u7gs6"},{"name":"投影","_id":"cksx100m0002p3svo74ym72aj"},{"name":"参数","_id":"cksx100m1002q3svodvu5ftxl"},{"name":"输入类型","_id":"cksx100m1002t3svo64tq68wp"},{"name":"输出类型","_id":"cksx100m1002v3svoba7b9m1l"},{"name":"顶点操作","_id":"cksx100m1002w3svo0tlp1no4"},{"name":"Hero Shader In Dota2","_id":"cksx100m2002x3svogxk78foz"},{"name":"贴图使用","_id":"cksx100m200303svo7hfsak7h"},{"name":"透明剪切","_id":"cksx100m200333svoa5st9c0v"},{"name":"轮廓光","_id":"cksx100m300343svo5fyx2zoh"},{"name":"自发光","_id":"cksx100m300353svo6m3tgot4"},{"name":"双面显示","_id":"cksx100m300363svogm345q65"},{"name":"贴图资源优化","_id":"cksx100m300373svo23qh4cy4"},{"name":"法线","_id":"cksx100m6003g3svo1zre8k50"},{"name":"Matcap贴图","_id":"cksx100m6003i3svo1s923qnh"},{"name":"Cubemap贴图","_id":"cksx100m6003j3svo6ygs8hpw"}]}}